【未完成版本】大家好 欢迎回来 现在到了展示图像处理中稀疏建模例子的时候了 在这之前 我们还得干件事 回忆一下我们学习了什么 我们有一个K列的字典 K个原子 每个原子是N维的 现在 我们要处理的信号是什么呢？ 我们需要花点时间来讨论它 基本思路很简单 我们要来讨论图像 y是我们的数据 即有噪声的图像 一整张图像 x就是我们想要寻找的 现在 我们并不是要处理整张图片 而是分块 (patches) 处理 这是R R表示在(i,j)处提取图像块的二元矩阵 所以 在一幅图像中 对每一个像素 我们在它四周构建一个块 或者 我们也可以考虑(i,j)位于块的左上角 坐标系的选取可以是任意的 然后我们提取出块 比如说 之前谈论过的8x8的块 现在我们选取块的方法跟JPEG中的方法有所不同 这一点很重要 在这里 我们选取的块都是重叠的 所以 对一张图片 我们选取一个块 然后我们选取旁边的块 再选取旁边的块 对每一个像素 假定它位于块的左上角 我们构建一个8x8的块 这个二元矩阵能够提取出这个块 对于这个块 我们使用学习好的字典来获得它的稀疏编码 这是稀疏度 所以我们不是立刻处理整张图像 而是处理 这幅图像中所有重叠的块 这个是我们以前讨论过的 针对单个块的模型 我们要构造一个字典 比如说 能够同时处理给定图像的所有重叠块 注意这里 我们是要对信号做优化 这表示整个图像 我们要找到稀疏编码 这是第二个部分 过会我们将会看到 我们也要学习字典 我们可以离线学习字典 或先学习然后使它适应于图像 我们会马上讲解它 再提一下 这仅仅是一个提取块的二元矩阵 所以想象你有一幅图像 然后选取一个块 对它做稀疏编码 然后选取下一个块 再做稀疏编码 现在字典是怎么得到呢？ 第一种方法是由一个数据库训练得到 你可以离线做这个 由一个数据库训练得到 第二种方法 和我们就要看到的没有什么不同 就是使用图像本身 遍历这幅图像所有的块 而这已经给了我们很多的训练数据 基本的思路是 一般我们会结合这两种方法 这是一种可能 所以 我们可以通过一堆现成的图像来离线学习字典 然后将此作为K-SVD所用字典的初始值 然后我们针对新的图像 尽管它有噪声 我们调整字典来适应图像 对于特定的某幅图像迭代运行字典适应、K-SVD、稀疏编码 字典适应、稀疏编码 这是一种选择 另一种就是完全忘记这些 然后从任意的字典开始 并且只在这幅图像中学习字典 所以 我们有很多选择 但要根据应用来选择 如果很急的话 也没有运行去噪算法的时间 我们可以不必更新字典 可以用一个数据库来训练字典 比方说 你要处理人脸 你可以用人脸数据库来训练字典 然后你就可以使用这个字典 如果你有计算时间 使字典适应于特定的图像 这总是要好些的 我们有一堆的数据来做这个 因为我们可以使用图像中所有的块 再说一遍 这就是一般化的公式 现在D也加入进来了 因为D是我们从特定的图像中学习得到的 或者我们需要调整预先学习好的字典 来适应当前的图片 这是我们的数据 我们必须重建这幅图像 必须计算编码 必须计算共同的字典 一个用于图像中所有块的字典 我们不允许每个块使用不同的字典 这很荒谬 所以 我们需要优化三个参数 基本思路很简单 先将其中两个固定 再优化第三个 比如说 忽略x 假设x是不变的 忽略这一项 再固定D 然后做稀疏编码 这是K-SVD的第一个部分 接下来 固定这个编码 更新字典 这是一个迭代的过程 即K-SVD 所以 对一幅图像 仔细检查每一个块 每个块都作为矩阵x的列 矩阵x我们在前一个视频里见过 然后你对所有这些做K-SVD 懂了吗？ 对每一个块用稀疏编码方法编码 完成编码后 就更新字典 接着又一遍的编码 再更新字典 当你完成了字典的计算 剩下的就只有计算x了 所以 你不用再计算编码了 也不用再更新字典了 当D和α都已经固定时 你就可以解决这个问题了 当然 这个约束条件没了 x只在这里和这里出现 很容易得出 结果就是块的加权平均 我们知道 每个像素被多个块所覆盖 让我在这里画出来 比如说 有一幅图像 这是一个像素点 现在 有多个块覆盖那个像素点 比如说 这个块的左底部角落覆盖了像素点 这个块也覆盖了像素点 让我用不同的颜色标记一下 这个块也是 那么 一共有多少个块呢？ 如果是块的大小是8x8的话 我们就有64个块覆盖那个像素 除非这个像素是在图像的边界 我们先忽略这些边界的像素 对于这些块 我们使用之前的字典对它们做稀疏编码 这个字典 是从图像的所有块中学习得来的 对于每一个块 计算它们的稀疏编码 我们可以用Dα来重建这些块 这里的α是针对每一个块ij 计算出的最优值 每一个块都被重建了 那如何重建这个像素呢？ 我们取所有块的平均值 也可以做加权平均 这个定理告诉了你如何做加权平均 如果像素点在块的中间 那么 这个块就 比像素点在角落的块要更重要 但这仅仅是个技巧 你也可以重建每个块 运用稀疏编码和学习好的字典 如果块的大小是8x8的话 你可以仅仅对这64个块取平均 你需要做的就是这些 对每个块做稀疏编码 运用K-SVD来学习字典 现在 我认为我们已经做好看例子的准备了 让我们从一幅非彩色的灰色图像开始 这是源图像 这是带噪声的图像 我们加了高斯噪声 噪声方差为20 我们可以从这幅图像中 随机选取块来初始化字典 我们不再有这幅图像 这只是做个参照 这才是我们所拥有的图像 我们可以用这里的块来初始化 也可以用离线学习好的字典来初始化 或者我们也可以其他不错的值来初始化字典 离线余弦变换的字典 那是用在JPEG中的字典 我们知道这是一个很棒的算法 这个字典也很好 在这个例子中 我们用它来初始化字典 然后用图像中所有的块 所有可能的块来更新字典 学习字典 然后利用学好的字典 运用稀疏编码来编码每个块 接着 对所有覆盖该像素点的块求平均 瞧 这就是我们学习好的字典 【未完成版本】从DCT字典转化到它的过程是很有意思的 这是一张通过这两个过程降噪恢复出来的图片 其中一个是利用稀疏编码将块投影到字典空间上 然后对这些块求平均 然后我们就得到了结果 这个是原始图像 这个是我们拿到的有噪声的图像 这个是降噪了的图像 很重要的一点是 字典的适应性因为噪声数据有所下降 但是结果 仍然非常好 我希望大家再观察一下 从图像中学习到的这个字典的类型 例如 它学习到了这里的这些纹理 这个字典学习到了很多不同种类的纹理 它已经根据图像做出了调整 那么现在我们看看如何处理颜色 其实有非常多的方法可以处理颜色 其中一个最简单的方法是 我们用 8 x 8 小片 x 3 来替代单一的 8 x 8 的小片 我们可以对每个颜色分量单独处理 就如我们在图像修复或者压缩里做的一样 但是我们也可以用 8 x 8 x 3 的小片来做这个 我们把所有的颜色拼起来 然后做完全一样的 K-SVD 稀疏建模 让我们来看看一些结果 我们先看看原始图像 它只作为参考 因为我们实际上没有原始图像 我们只有这个有噪音的图像 一个有噪音的版本 接着 我们运行 K-SVD 大小的选择是 8 x 8 x 3 还是 5 x 5 x 3 则根据大家自己的决定 然后我们就会得到一个很好的图像降噪结果 这里这个 是对噪声测量的标准 用分贝(dB)表示结果的质量 这里是另一个例子 我们从参考图片开始 这只是个参考用的原始图片 这里有噪声 图像质量非常差 我们添加了许多噪声 然后通过一个漂亮的稀疏表建模技术将其重建了 细节重建非常好 测量结果也相对很高 当然最重要的还是重建的质量 我们从这里到这里 再做一次字典学习 这个例子中 我们用现成的预先学习的字典初始化字典 然后再将其用 K-SVD 对这张图片进行数次迭代 以适应这张噪声图片 现在 我们就可以利用字典做图像恢复了 图像修复是一个比较特别的噪声的例子 这种噪声 非常强导致有的像素丢失了 有许多方式可以定义图像修复这种类型的挑战 其中一个是将图像中 80% 的像素丢弃 这个也跟压缩感知有关 我们将在这周的最后一个视频里谈谈它 我们将 80% 的像素丢弃 我们说 好吧 像素没了 所以这些地方用黑色(0)来表示 这就好比噪声实在太强烈 导致这里什么都没有 之后我们只需要在这张图片上 运行稀疏表模型和 K-SVD 这些是丢失了的部分 我们从这张图像出发 然后这里是重建的结果 再一次地 我们得到了一个非常非常有趣的结果 我们只有 20% 的像素 然后成功地得到了一个很好的图像重建 再一次地 我们从这里到这里 这张图片只用作参考 我们来看看彩色的情况 同样是丢失了 80% 这里是重建结果 还是一样 我觉得这是一个 非常好的结果 对于这个例子 我们从 一个已经从自然图像数据库学习过的字典出发 然后通过数次迭代使其与这张图片相适应 最后对每一片都重建 并且对每一个像素 将与之邻接的小片平均 得到这个图像 我觉得这是一个非常惊人的结果 它展示这个技术的强大之处 这是另一个例子 这次我们并不丢弃像素 我们对其 做的处理跟我们在讲图像恢复的时候一样 我们在图像表面写字 然后来做重建 同样 一个非常好的重建结果 可以用稀疏表建模 和从这张噪声图像学习过的字典的方法来得到 现在 我们还可以对视频做恢复 我们可以丢弃 80% 的像素 现在 同样地 我们还有好几种不同的选择 我们可以一帧一帧地处理 或者我们也可以在X Y T这样的三维 小片上做处理 我们在前几周讲解视频恢复的视频中已经讲述这些 我们取一些小片 比如说 比如说三帧一起 五帧一起 那么小片就有了时序信息 当我们确定了使用那种小片之后 我们运行跟之前讲过的完全一样的稀疏表建模 然后我将播放一下这个视频 原始的这个视频是拿来做参考的 实际上我们没有这个 我们是要从这里到这里来做字典学习 让我来播放几帧看看 这是一帧 这又是一帧 请注意结果的质量 也就是重建的结果 另一帧 又一帧 同样地 我们 通过对每一帧都做从这个到这个处理 我们可以发现这个重建的结果 跟这里这个我们不能获取的原始视频非常接近 这只是另一帧罢了 现在我想再讲讲下一张幻灯片 我想以去马赛克来结束本次视频 这是最后一个例子 我们之前已经见过这种特殊类型的图像恢复 先让我解释一下问题在哪 绝大多数照相机都没有完全收集红、绿、蓝的信息 它们玩了一个小技巧 一个像素只收集红色 下一个像素只手机绿色 然后红色 绿色 如此循环 对于下一行 它们收集 绿色 蓝色 绿色 蓝色 如此循环 所以 对于每一个像素 它们只有一种颜色分量 红的 绿的 或者蓝的 我们要做的就是插值 为了展现出图像 我们必须对每一个像素 都重建出红色、绿色 和蓝色 这是一种插值 或者也是一种颜色修复 我们可以将这个问题看作颜色恢复 不同于丢弃整个像素 这里是每个像素丢弃了 两个颜色分量 有时候丢弃的是红色和绿色 有时候丢掉的是绿色和蓝色 有时候丢掉的是红色和蓝色 想象一下 我们有一个 n x n x 3 的阵列 有时候里面有数据 有时候没有 现在我们已经知道稀疏表建模 对于整个像素都丢失的情况非常有效 即使 80% 的像素都完全丢失了 那么我们对这种图片来跑一下稀疏表建模 这也叫做去马赛克 这个过程在所有消费数字照相机里都会出现 非常昂贵的数字照相机会真正地收集全部红色、全部绿色 以及全部蓝色 但是普通消费级相机 先收集这样的马赛克 然后通过去马赛克生成全彩图像 这里我们见到了一个用稀疏表建模 从这种模式 重建彩色图像的例子 这是一个彩色图像恢复中的特例 它比图像恢复更简单 因为我们并非失去了 80% 的整个像素 我们的每一个像素只丢失了 一些颜色通道 得到的结果当然非常非常好 我们将其局部放大 然后可以看到这些结果非常非常好 这些实际上是去马赛克中的最好结果之一 它们是用稀疏表建模技术得到的 这些只是稀疏表建模的一些例子 最近几年 稀疏表建模在图像处理中 使用得非常多 在图像分类和其他 图像处理的挑战如去噪 恢复和去马赛克中也有使用 我觉得这些已经展示出了这个 有很多数学原理的理论的重要性 还有这些很酷的应用 这周我们还将学习稀疏表建模的一些东西 还有关于压缩感知和这两者之间的联系 我将会在接下来的视频中讲解它们 谢谢大家 一会见【未完成版本】