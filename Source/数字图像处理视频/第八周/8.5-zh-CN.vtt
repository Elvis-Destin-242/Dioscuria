WEBVTT

1
00:00:00.000 --> 00:00:05.422
【未完成版本】大家好 欢迎回来 
现在到了展示图像处理中稀疏建模例子的时候了 

2
00:00:05.422 --> 00:00:12.381
在这之前 我们还得干件事 

3
00:00:12.381 --> 00:00:15.273
回忆一下我们学习了什么 

4
00:00:15.273 --> 00:00:22.051
我们有一个K列的字典 K个原子 每个原子是N维的 

5
00:00:22.051 --> 00:00:28.829
现在 我们要处理的信号是什么呢？ 

6
00:00:28.829 --> 00:00:33.800
我们需要花点时间来讨论它 

7
00:00:33.800 --> 00:00:40.200
基本思路很简单 我们要来讨论图像 

8
00:00:40.200 --> 00:00:44.041
y是我们的数据 即有噪声的图像 

9
00:00:44.041 --> 00:00:48.430
一整张图像
x就是我们想要寻找的 

10
00:00:48.430 --> 00:00:52.772
现在 我们并不是要处理整张图片 

11
00:00:52.772 --> 00:00:57.519
而是分块 (patches) 处理 这是R 

12
00:00:57.519 --> 00:01:05.497
R表示在(i,j)处提取图像块的二元矩阵 

13
00:01:05.497 --> 00:01:13.943
所以 在一幅图像中 对每一个像素 我们在它四周构建一个块 

14
00:01:13.943 --> 00:01:18.637
或者 我们也可以考虑(i,j)位于块的左上角 

15
00:01:18.637 --> 00:01:24.440
坐标系的选取可以是任意的 然后我们提取出块 

16
00:01:24.440 --> 00:01:29.476
比如说 之前谈论过的8x8的块 

17
00:01:29.476 --> 00:01:36.047
现在我们选取块的方法跟JPEG中的方法有所不同 这一点很重要 

18
00:01:36.047 --> 00:01:41.083
在这里 我们选取的块都是重叠的 

19
00:01:41.083 --> 00:01:45.399
所以 对一张图片 我们选取一个块 

20
00:01:45.399 --> 00:01:48.443
然后我们选取旁边的块 再选取旁边的块 

21
00:01:48.443 --> 00:01:52.140
对每一个像素 假定它位于块的左上角 

22
00:01:52.140 --> 00:01:59.087
我们构建一个8x8的块 这个二元矩阵能够提取出这个块 

23
00:01:59.087 --> 00:02:05.858
对于这个块 我们使用学习好的字典来获得它的稀疏编码 

24
00:02:05.858 --> 00:02:09.640
这是稀疏度 

25
00:02:09.640 --> 00:02:15.585
所以我们不是立刻处理整张图像 而是处理 

26
00:02:15.585 --> 00:02:21.204
这幅图像中所有重叠的块 这个是我们以前讨论过的 

27
00:02:21.204 --> 00:02:25.032
针对单个块的模型 

28
00:02:25.032 --> 00:02:30.652
我们要构造一个字典 比如说 

29
00:02:30.652 --> 00:02:35.050
能够同时处理给定图像的所有重叠块 

30
00:02:35.050 --> 00:02:43.258
注意这里 我们是要对信号做优化 

31
00:02:43.258 --> 00:02:47.480
这表示整个图像 我们要找到稀疏编码 

32
00:02:47.480 --> 00:02:51.623
这是第二个部分 过会我们将会看到 

33
00:02:51.623 --> 00:02:57.171
我们也要学习字典 我们可以离线学习字典 

34
00:02:57.171 --> 00:03:01.947
或先学习然后使它适应于图像 我们会马上讲解它 

35
00:03:01.947 --> 00:03:07.425
再提一下 这仅仅是一个提取块的二元矩阵   

36
00:03:07.425 --> 00:03:10.936
所以想象你有一幅图像 然后选取一个块 

37
00:03:10.936 --> 00:03:14.097
对它做稀疏编码 然后选取下一个块 

38
00:03:14.097 --> 00:03:18.030
再做稀疏编码 现在字典是怎么得到呢？ 

39
00:03:18.030 --> 00:03:21.888
第一种方法是由一个数据库训练得到 

40
00:03:21.888 --> 00:03:26.061
你可以离线做这个 由一个数据库训练得到 

41
00:03:26.061 --> 00:03:32.125
第二种方法 和我们就要看到的没有什么不同 

42
00:03:32.125 --> 00:03:38.030
就是使用图像本身 遍历这幅图像所有的块 

43
00:03:38.030 --> 00:03:42.125
而这已经给了我们很多的训练数据 

44
00:03:42.125 --> 00:03:46.850
基本的思路是 一般我们会结合这两种方法 

45
00:03:46.850 --> 00:03:52.526
这是一种可能 所以 我们可以通过一堆现成的图像来离线学习字典 

46
00:03:52.526 --> 00:03:59.106
然后将此作为K-SVD所用字典的初始值 

47
00:03:59.106 --> 00:04:03.354
然后我们针对新的图像 

48
00:04:03.354 --> 00:04:08.435
尽管它有噪声 我们调整字典来适应图像 

49
00:04:08.435 --> 00:04:14.266
对于特定的某幅图像迭代运行字典适应、K-SVD、稀疏编码 

50
00:04:14.266 --> 00:04:19.930
字典适应、稀疏编码 

51
00:04:19.930 --> 00:04:24.121
这是一种选择 另一种就是完全忘记这些 

52
00:04:24.121 --> 00:04:28.090
然后从任意的字典开始 并且只在这幅图像中学习字典 

53
00:04:28.090 --> 00:04:33.204
所以 我们有很多选择 但要根据应用来选择 

54
00:04:33.204 --> 00:04:36.164
如果很急的话 

55
00:04:36.164 --> 00:04:41.143
也没有运行去噪算法的时间 我们可以不必更新字典 

56
00:04:41.143 --> 00:04:44.507
可以用一个数据库来训练字典 

57
00:04:44.507 --> 00:04:50.024
比方说 你要处理人脸 你可以用人脸数据库来训练字典 

58
00:04:50.024 --> 00:04:54.306
然后你就可以使用这个字典 如果你有计算时间 

59
00:04:54.306 --> 00:04:59.887
使字典适应于特定的图像 这总是要好些的 

60
00:04:59.887 --> 00:05:03.253
我们有一堆的数据来做这个 

61
00:05:03.253 --> 00:05:06.200
因为我们可以使用图像中所有的块 

62
00:05:06.200 --> 00:05:12.141
再说一遍 这就是一般化的公式 现在D也加入进来了 

63
00:05:12.141 --> 00:05:18.836
因为D是我们从特定的图像中学习得到的 

64
00:05:18.836 --> 00:05:23.606
或者我们需要调整预先学习好的字典 来适应当前的图片 

65
00:05:23.606 --> 00:05:29.138
这是我们的数据 我们必须重建这幅图像 

66
00:05:29.138 --> 00:05:34.971
必须计算编码 必须计算共同的字典 

67
00:05:34.971 --> 00:05:38.705
一个用于图像中所有块的字典 

68
00:05:38.705 --> 00:05:42.516
我们不允许每个块使用不同的字典 

69
00:05:42.516 --> 00:05:48.115
这很荒谬 所以 我们需要优化三个参数 

70
00:05:48.115 --> 00:05:53.793
基本思路很简单 先将其中两个固定 再优化第三个 

71
00:05:53.793 --> 00:05:55.660
比如说 

72
00:05:55.660 --> 00:06:02.363
忽略x 假设x是不变的 

73
00:06:02.363 --> 00:06:08.930
忽略这一项 再固定D 然后做稀疏编码 

74
00:06:08.930 --> 00:06:15.150
这是K-SVD的第一个部分 接下来 固定这个编码 

75
00:06:15.150 --> 00:06:21.440
更新字典 这是一个迭代的过程 即K-SVD 

76
00:06:21.440 --> 00:06:26.071
所以 对一幅图像 仔细检查每一个块 

77
00:06:26.071 --> 00:06:29.508
每个块都作为矩阵x的列 

78
00:06:29.508 --> 00:06:32.948
矩阵x我们在前一个视频里见过 

79
00:06:32.948 --> 00:06:35.897
然后你对所有这些做K-SVD 懂了吗？ 

80
00:06:35.897 --> 00:06:39.478
对每一个块用稀疏编码方法编码 

81
00:06:39.478 --> 00:06:44.744
完成编码后 就更新字典 接着又一遍的编码 再更新字典 

82
00:06:44.744 --> 00:06:48.465
当你完成了字典的计算 

83
00:06:48.465 --> 00:06:53.380
剩下的就只有计算x了 所以 你不用再计算编码了 

84
00:06:53.380 --> 00:06:56.400
也不用再更新字典了 

85
00:06:56.400 --> 00:07:03.393
当D和α都已经固定时 你就可以解决这个问题了 

86
00:07:03.393 --> 00:07:06.627
当然 这个约束条件没了 

87
00:07:06.627 --> 00:07:13.620
x只在这里和这里出现 很容易得出 

88
00:07:13.620 --> 00:07:17.904
结果就是块的加权平均 

89
00:07:17.904 --> 00:07:23.848
我们知道 每个像素被多个块所覆盖 

90
00:07:23.848 --> 00:07:27.520
让我在这里画出来 比如说 

91
00:07:27.520 --> 00:07:31.813
有一幅图像 这是一个像素点 

92
00:07:31.813 --> 00:07:35.876
现在 有多个块覆盖那个像素点 

93
00:07:35.876 --> 00:07:41.703
比如说 这个块的左底部角落覆盖了像素点 

94
00:07:41.703 --> 00:07:45.460
这个块也覆盖了像素点 

95
00:07:45.460 --> 00:07:52.188
让我用不同的颜色标记一下 

96
00:07:52.188 --> 00:07:55.427
 这个块也是 那么 一共有多少个块呢？  

97
00:07:55.427 --> 00:08:01.297
如果是块的大小是8x8的话 我们就有64个块覆盖那个像素 

98
00:08:01.297 --> 00:08:05.026
除非这个像素是在图像的边界 

99
00:08:05.026 --> 00:08:10.420
我们先忽略这些边界的像素 对于这些块 

100
00:08:10.420 --> 00:08:16.766
我们使用之前的字典对它们做稀疏编码 这个字典 

101
00:08:16.766 --> 00:08:21.605
是从图像的所有块中学习得来的 对于每一个块 

102
00:08:21.605 --> 00:08:29.080
计算它们的稀疏编码 我们可以用Dα来重建这些块 

103
00:08:29.080 --> 00:08:38.960
这里的α是针对每一个块ij 计算出的最优值 

104
00:08:38.960 --> 00:08:43.477
每一个块都被重建了 那如何重建这个像素呢？ 

105
00:08:43.477 --> 00:08:48.119
我们取所有块的平均值 也可以做加权平均 

106
00:08:48.119 --> 00:08:50.817
这个定理告诉了你如何做加权平均 

107
00:08:50.817 --> 00:08:55.334
如果像素点在块的中间 那么 这个块就 

108
00:08:55.334 --> 00:09:00.102
比像素点在角落的块要更重要 

109
00:09:00.102 --> 00:09:02.800
但这仅仅是个技巧 你也可以重建每个块 

110
00:09:02.800 --> 00:09:07.694
运用稀疏编码和学习好的字典 

111
00:09:07.694 --> 00:09:14.170
如果块的大小是8x8的话 你可以仅仅对这64个块取平均 

112
00:09:14.170 --> 00:09:20.174
你需要做的就是这些 对每个块做稀疏编码 运用K-SVD来学习字典 

113
00:09:20.174 --> 00:09:25.046
现在 我认为我们已经做好看例子的准备了 

114
00:09:25.046 --> 00:09:29.070
让我们从一幅非彩色的灰色图像开始 

115
00:09:29.070 --> 00:09:32.958
这是源图像 

116
00:09:32.958 --> 00:09:37.251
这是带噪声的图像 我们加了高斯噪声 

117
00:09:37.251 --> 00:09:41.868
噪声方差为20 我们可以从这幅图像中 

118
00:09:41.868 --> 00:09:47.457
随机选取块来初始化字典 我们不再有这幅图像 

119
00:09:47.457 --> 00:09:51.669
这只是做个参照 这才是我们所拥有的图像 

120
00:09:51.669 --> 00:09:58.104
我们可以用这里的块来初始化 也可以用离线学习好的字典来初始化 

121
00:09:58.104 --> 00:10:03.043
或者我们也可以其他不错的值来初始化字典 

122
00:10:03.043 --> 00:10:07.069
离线余弦变换的字典 

123
00:10:07.069 --> 00:10:12.312
那是用在JPEG中的字典 我们知道这是一个很棒的算法 

124
00:10:12.312 --> 00:10:14.819
这个字典也很好 

125
00:10:14.819 --> 00:10:18.086
在这个例子中 我们用它来初始化字典 

126
00:10:18.086 --> 00:10:24.620
然后用图像中所有的块 所有可能的块来更新字典 

127
00:10:24.620 --> 00:10:29.223
学习字典 然后利用学好的字典 运用稀疏编码来编码每个块 

128
00:10:29.223 --> 00:10:35.152
接着 对所有覆盖该像素点的块求平均 

129
00:10:35.152 --> 00:10:39.911
瞧 这就是我们学习好的字典 

130
00:10:39.911 --> 00:10:44.124
【未完成版本】从DCT字典转化到它的过程是很有意思的 

131
00:10:44.124 --> 00:10:49.351
这是一张通过这两个过程降噪恢复出来的图片 

132
00:10:49.351 --> 00:10:56.411
其中一个是利用稀疏编码将块投影到字典空间上 

133
00:10:56.411 --> 00:11:03.118
然后对这些块求平均 

134
00:11:03.118 --> 00:11:05.637
然后我们就得到了结果 

135
00:11:05.637 --> 00:11:10.936
这个是原始图像 这个是我们拿到的有噪声的图像 这个是降噪了的图像 

136
00:11:10.936 --> 00:11:14.170
很重要的一点是 

137
00:11:14.170 --> 00:11:19.606
字典的适应性因为噪声数据有所下降 但是结果 

138
00:11:19.606 --> 00:11:22.496
仍然非常好 我希望大家再观察一下 

139
00:11:22.496 --> 00:11:26.556
从图像中学习到的这个字典的类型 

140
00:11:26.556 --> 00:11:32.130
例如 它学习到了这里的这些纹理   

141
00:11:32.130 --> 00:11:37.360
这个字典学习到了很多不同种类的纹理 它已经根据图像做出了调整 

142
00:11:37.360 --> 00:11:42.115
那么现在我们看看如何处理颜色 其实有非常多的方法可以处理颜色 

143
00:11:42.115 --> 00:11:47.345
其中一个最简单的方法是 我们用 8 x 8 小片 x 3 

144
00:11:47.345 --> 00:11:50.334
来替代单一的 8 x 8 的小片 

145
00:11:50.334 --> 00:11:54.750
我们可以对每个颜色分量单独处理 

146
00:11:54.750 --> 00:11:58.011
就如我们在图像修复或者压缩里做的一样 

147
00:11:58.011 --> 00:12:02.019
但是我们也可以用 8 x 8 x 3 的小片来做这个 

148
00:12:02.019 --> 00:12:07.521
我们把所有的颜色拼起来 然后做完全一样的 K-SVD 稀疏建模 

149
00:12:07.521 --> 00:12:11.700
让我们来看看一些结果 

150
00:12:11.700 --> 00:12:16.660
我们先看看原始图像 它只作为参考 因为我们实际上没有原始图像 

151
00:12:16.660 --> 00:12:20.427
我们只有这个有噪音的图像   

152
00:12:20.427 --> 00:12:25.372
一个有噪音的版本 接着 我们运行 K-SVD 

153
00:12:25.372 --> 00:12:31.415
大小的选择是 8 x 8 x 3 还是 5 x 5 x 3 则根据大家自己的决定 

154
00:12:31.415 --> 00:12:35.654
然后我们就会得到一个很好的图像降噪结果 

155
00:12:35.654 --> 00:12:39.264
这里这个 

156
00:12:39.264 --> 00:12:45.386
是对噪声测量的标准 用分贝(dB)表示结果的质量 

157
00:12:45.386 --> 00:12:48.121
这里是另一个例子 

158
00:12:48.121 --> 00:12:53.890
我们从参考图片开始 这只是个参考用的原始图片 

159
00:12:53.890 --> 00:12:55.527
这里有噪声 

160
00:12:55.527 --> 00:12:58.490
图像质量非常差 

161
00:12:58.490 --> 00:13:05.039
我们添加了许多噪声 然后通过一个漂亮的稀疏表建模技术将其重建了 

162
00:13:05.039 --> 00:13:09.795
细节重建非常好 

163
00:13:09.795 --> 00:13:14.332
测量结果也相对很高 

164
00:13:14.332 --> 00:13:18.630
当然最重要的还是重建的质量 

165
00:13:18.630 --> 00:13:21.632
我们从这里到这里 

166
00:13:21.632 --> 00:13:27.774
再做一次字典学习 这个例子中 

167
00:13:27.774 --> 00:13:33.372
我们用现成的预先学习的字典初始化字典 

168
00:13:33.372 --> 00:13:37.080
然后再将其用 K-SVD 对这张图片进行数次迭代 以适应这张噪声图片 

169
00:13:37.080 --> 00:13:41.073
现在 我们就可以利用字典做图像恢复了 

170
00:13:41.073 --> 00:13:46.493
图像修复是一个比较特别的噪声的例子 这种噪声 

171
00:13:46.493 --> 00:13:51.406
非常强导致有的像素丢失了   

172
00:13:51.406 --> 00:13:54.875
有许多方式可以定义图像修复这种类型的挑战 

173
00:13:54.875 --> 00:13:59.851
其中一个是将图像中 80% 的像素丢弃 

174
00:13:59.851 --> 00:14:05.720
这个也跟压缩感知有关 我们将在这周的最后一个视频里谈谈它 

175
00:14:05.720 --> 00:14:11.284
我们将 80% 的像素丢弃 

176
00:14:11.284 --> 00:14:16.009
我们说 好吧 像素没了 所以这些地方用黑色(0)来表示    

177
00:14:16.009 --> 00:14:20.430
这就好比噪声实在太强烈 

178
00:14:20.430 --> 00:14:25.816
导致这里什么都没有 之后我们只需要在这张图片上 

179
00:14:25.816 --> 00:14:31.835
运行稀疏表模型和 K-SVD 这些是丢失了的部分 

180
00:14:31.835 --> 00:14:36.270
我们从这张图像出发 然后这里是重建的结果 

181
00:14:36.270 --> 00:14:39.619
再一次地 我们得到了一个非常非常有趣的结果 

182
00:14:39.619 --> 00:14:45.679
我们只有 20% 的像素 然后成功地得到了一个很好的图像重建 

183
00:14:45.679 --> 00:14:51.101
再一次地 我们从这里到这里 这张图片只用作参考 

184
00:14:51.101 --> 00:14:56.045
我们来看看彩色的情况 同样是丢失了 80%   

185
00:14:56.045 --> 00:15:00.111
这里是重建结果 还是一样 我觉得这是一个 

186
00:15:00.111 --> 00:15:03.972
非常好的结果 对于这个例子 我们从 

187
00:15:03.972 --> 00:15:09.815
一个已经从自然图像数据库学习过的字典出发 

188
00:15:09.815 --> 00:15:16.673
然后通过数次迭代使其与这张图片相适应 

189
00:15:16.673 --> 00:15:23.109
最后对每一片都重建 并且对每一个像素 将与之邻接的小片平均 得到这个图像 

190
00:15:23.109 --> 00:15:29.940
我觉得这是一个非常惊人的结果 它展示这个技术的强大之处 

191
00:15:29.940 --> 00:15:35.854
这是另一个例子 这次我们并不丢弃像素 我们对其 

192
00:15:35.854 --> 00:15:40.348
做的处理跟我们在讲图像恢复的时候一样 

193
00:15:40.348 --> 00:15:45.316
我们在图像表面写字 然后来做重建 

194
00:15:45.316 --> 00:15:51.467
同样 一个非常好的重建结果 可以用稀疏表建模   

195
00:15:51.467 --> 00:15:57.460
和从这张噪声图像学习过的字典的方法来得到 

196
00:15:57.460 --> 00:16:03.275
现在 我们还可以对视频做恢复 我们可以丢弃 80% 的像素 

197
00:16:03.275 --> 00:16:06.575
现在 同样地 我们还有好几种不同的选择 

198
00:16:06.575 --> 00:16:11.974
我们可以一帧一帧地处理 或者我们也可以在X Y T这样的三维 

199
00:16:11.974 --> 00:16:13.568
小片上做处理 

200
00:16:13.568 --> 00:16:19.337
我们在前几周讲解视频恢复的视频中已经讲述这些 

201
00:16:19.337 --> 00:16:23.262
我们取一些小片 比如说 

202
00:16:23.262 --> 00:16:28.986
比如说三帧一起 五帧一起 那么小片就有了时序信息 

203
00:16:28.986 --> 00:16:33.095
当我们确定了使用那种小片之后 

204
00:16:33.095 --> 00:16:38.820
我们运行跟之前讲过的完全一样的稀疏表建模 

205
00:16:38.820 --> 00:16:43.150
然后我将播放一下这个视频 

206
00:16:43.150 --> 00:16:46.480
原始的这个视频是拿来做参考的 

207
00:16:46.480 --> 00:16:51.588
实际上我们没有这个 我们是要从这里到这里来做字典学习 

208
00:16:51.588 --> 00:16:54.919
让我来播放几帧看看 

209
00:16:54.919 --> 00:17:00.915
这是一帧 这又是一帧 请注意结果的质量 

210
00:17:00.915 --> 00:17:03.210
也就是重建的结果 另一帧 

211
00:17:03.210 --> 00:17:07.559
又一帧 同样地 我们 

212
00:17:07.559 --> 00:17:11.322
通过对每一帧都做从这个到这个处理 

213
00:17:11.322 --> 00:17:17.344
我们可以发现这个重建的结果 

214
00:17:17.344 --> 00:17:22.530
跟这里这个我们不能获取的原始视频非常接近 这只是另一帧罢了 

215
00:17:22.530 --> 00:17:32.340
现在我想再讲讲下一张幻灯片 我想以去马赛克来结束本次视频 

216
00:17:32.340 --> 00:17:37.420
这是最后一个例子 我们之前已经见过这种特殊类型的图像恢复 

217
00:17:37.420 --> 00:17:42.430
先让我解释一下问题在哪 

218
00:17:42.430 --> 00:17:47.290
绝大多数照相机都没有完全收集红、绿、蓝的信息 

219
00:17:47.290 --> 00:17:52.637
它们玩了一个小技巧 一个像素只收集红色 

220
00:17:52.637 --> 00:17:57.984
下一个像素只手机绿色 然后红色 绿色 如此循环 

221
00:17:57.984 --> 00:18:03.899
对于下一行 它们收集 绿色 蓝色 绿色 蓝色 

222
00:18:03.899 --> 00:18:08.273
如此循环 所以 对于每一个像素 它们只有一种颜色分量 

223
00:18:08.273 --> 00:18:11.230
红的 绿的 

224
00:18:11.230 --> 00:18:14.772
或者蓝的 我们要做的就是插值 

225
00:18:14.772 --> 00:18:18.464
为了展现出图像 

226
00:18:18.464 --> 00:18:22.157
我们必须对每一个像素 都重建出红色、绿色 和蓝色 

227
00:18:22.157 --> 00:18:27.056
这是一种插值 或者也是一种颜色修复 

228
00:18:27.056 --> 00:18:32.633
我们可以将这个问题看作颜色恢复 

229
00:18:32.633 --> 00:18:38.367
不同于丢弃整个像素 这里是每个像素丢弃了 

230
00:18:38.367 --> 00:18:43.118
两个颜色分量 有时候丢弃的是红色和绿色 

231
00:18:43.118 --> 00:18:45.902
有时候丢掉的是绿色和蓝色 

232
00:18:45.902 --> 00:18:48.501
有时候丢掉的是红色和蓝色 

233
00:18:48.501 --> 00:18:51.409
想象一下 我们有一个 

234
00:18:51.409 --> 00:18:55.988
n x n x 3 的阵列 有时候里面有数据 

235
00:18:55.988 --> 00:18:59.448
有时候没有 现在我们已经知道稀疏表建模 

236
00:18:59.448 --> 00:19:03.818
对于整个像素都丢失的情况非常有效 

237
00:19:03.818 --> 00:19:07.208
即使 80% 的像素都完全丢失了 

238
00:19:07.208 --> 00:19:11.351
那么我们对这种图片来跑一下稀疏表建模 这也叫做去马赛克 

239
00:19:11.351 --> 00:19:15.871
这个过程在所有消费数字照相机里都会出现 

240
00:19:15.871 --> 00:19:21.898
非常昂贵的数字照相机会真正地收集全部红色、全部绿色 

241
00:19:21.898 --> 00:19:27.473
以及全部蓝色 但是普通消费级相机 先收集这样的马赛克 

242
00:19:27.473 --> 00:19:33.190
然后通过去马赛克生成全彩图像 

243
00:19:33.190 --> 00:19:39.096
这里我们见到了一个用稀疏表建模 从这种模式 

244
00:19:39.096 --> 00:19:43.743
重建彩色图像的例子 这是一个彩色图像恢复中的特例 

245
00:19:43.743 --> 00:19:48.619
它比图像恢复更简单 

246
00:19:48.619 --> 00:19:54.485
因为我们并非失去了 80% 的整个像素 我们的每一个像素只丢失了 

247
00:19:54.485 --> 00:19:58.828
一些颜色通道 得到的结果当然非常非常好 

248
00:19:58.828 --> 00:20:04.742
我们将其局部放大 然后可以看到这些结果非常非常好 

249
00:20:04.742 --> 00:20:08.046
这些实际上是去马赛克中的最好结果之一 

250
00:20:08.046 --> 00:20:13.753
它们是用稀疏表建模技术得到的 

251
00:20:13.753 --> 00:20:17.182
这些只是稀疏表建模的一些例子 

252
00:20:17.182 --> 00:20:21.051
最近几年 稀疏表建模在图像处理中 

253
00:20:21.051 --> 00:20:25.989
使用得非常多 在图像分类和其他 

254
00:20:25.989 --> 00:20:31.060
图像处理的挑战如去噪 恢复和去马赛克中也有使用 

255
00:20:31.060 --> 00:20:36.291
我觉得这些已经展示出了这个 

256
00:20:36.291 --> 00:20:39.301
有很多数学原理的理论的重要性 

257
00:20:39.301 --> 00:20:42.670
还有这些很酷的应用 

258
00:20:42.670 --> 00:20:47.686
这周我们还将学习稀疏表建模的一些东西 

259
00:20:47.686 --> 00:20:52.218
还有关于压缩感知和这两者之间的联系 

260
00:20:52.218 --> 00:20:54.455
我将会在接下来的视频中讲解它们 

261
00:20:54.455 --> 00:20:56.933
谢谢大家 一会见【未完成版本】