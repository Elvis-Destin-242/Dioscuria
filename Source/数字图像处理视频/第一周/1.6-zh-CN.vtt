WEBVTT

1
00:00:00.000 --> 00:00:06.835
利用上一个视频讲到的离散二维数组 

2
00:00:06.835 --> 00:00:13.495
计算机可以这样描绘出图像   

3
00:00:13.495 --> 00:00:18.276
也就是我们从这张连续的图片 得到了这个二维离散数组 

4
00:00:18.276 --> 00:00:21.271
现在我们就可以对这些图片进行处理了 

5
00:00:21.271 --> 00:00:25.703
现在图像在我们的电脑中 它们可被看成像素的二维数组 

6
00:00:25.703 --> 00:00:30.614
我们就能够基于此进行各种各样的处理   

7
00:00:30.614 --> 00:00:35.496
就如我们前几节课视频看到的那样 在接下来几周里 

8
00:00:35.496 --> 00:00:39.815
我们将会学到一些非常复杂的操作 我们先从一些简单的例子开始 

9
00:00:39.815 --> 00:00:44.372
它们虽然简单但却非常有用 

10
00:00:44.372 --> 00:00:47.094
能够让我们知道如何真正地处理这些图片 

11
00:00:47.094 --> 00:00:51.768
你也可以用自己的电脑 来实践我一会给大家演示的例子 

12
00:00:51.768 --> 00:00:56.621
如果你有MATLAB这样的软件 这只需要几分钟时间或者更短 

13
00:00:56.621 --> 00:01:01.420
MATLAB 是一种常被用来处理二维数组的软件 

14
00:01:01.420 --> 00:01:06.728
当有了一个二维矩阵 我们可以就开始 

15
00:01:06.728 --> 00:01:10.726
探讨邻域处理 要记住 我们有一个二维数组 

16
00:01:10.726 --> 00:01:15.352
现在我们要在像素层面探讨 在这里我画了一个像素点 

17
00:01:15.352 --> 00:01:20.153
我要问哪些像素和这个像素相邻 

18
00:01:20.153 --> 00:01:25.793
这里介绍图像处理中的两种邻域 

19
00:01:25.793 --> 00:01:29.528
一种称之为 “4邻域” 

20
00:01:29.528 --> 00:01:34.634
只包含画出的这四个点 也就是说你只能 

21
00:01:34.634 --> 00:01:38.673
去找上下左右的四个像素 所以这就是 4领域 

22
00:01:38.673 --> 00:01:44.012
另一种常见的类型就是 “8邻域” 

23
00:01:44.012 --> 00:01:48.202
你或许已经猜出来是怎么回事了 

24
00:01:48.202 --> 00:01:53.029
如果是这个像素点 就要取环绕着它的所有相邻像素 

25
00:01:53.029 --> 00:01:59.769
你可以和刚才一样 看到上下左右的点 

26
00:01:59.769 --> 00:02:04.687
你也可以看到像左上角 这样的对角邻像素 

27
00:02:04.687 --> 00:02:10.152
举个例子 看看这张图 

28
00:02:10.152 --> 00:02:14.517
这个像素的 4邻域像素中 

29
00:02:14.517 --> 00:02:19.063
不包括这个点 因此 这两个 1 不相邻 

30
00:02:19.063 --> 00:02:23.908
这是因为4邻域关系 并不包括对角线位置的点 

31
00:02:23.908 --> 00:02:28.232
而在8邻域像素关系中 它们就是相邻像素了 

32
00:02:28.232 --> 00:02:32.406
当然 这个概念也可以迁移用于像素组中 

33
00:02:32.406 --> 00:02:38.145
上面这个像素组和下面的这个像素组存在8邻域的关系 

34
00:02:38.145 --> 00:02:41.649
因为有一个 1 在这儿 而另一个 1 在它的对角线上 

35
00:02:41.649 --> 00:02:44.363
这时可以考虑对角线上的点 

36
00:02:44.363 --> 00:02:50.423
现在 如果我们考虑的是4邻域的话 我可以说 

37
00:02:50.423 --> 00:02:54.132
上面这一组 1 与下面这一组 1 是不相邻的 

38
00:02:54.132 --> 00:02:57.516
因为从这个 1 出发 我们只能向下找 

39
00:02:57.516 --> 00:03:01.142
在下面这个组中 我看不到和它相邻的“1” 

40
00:03:01.142 --> 00:03:04.365
在这个 1 的右边 也没有 1   

41
00:03:04.365 --> 00:03:10.490
因此 我们能够进行什么样的操作取决于在这个离散空间中 

42
00:03:10.490 --> 00:03:15.386
是如何定义邻域的 我们将会看到这很重要 

43
00:03:15.386 --> 00:03:19.717
这种邻域 在现代图像处理中最为常见 

44
00:03:19.717 --> 00:03:22.855
但是了解这种领域也很重要 

45
00:03:22.855 --> 00:03:26.747
尤其是在我们进行图像分割或者类似的操作时 

46
00:03:26.747 --> 00:03:31.016
再比如说 我们今后会谈到 

47
00:03:31.016 --> 00:03:34.597
我们会讲解 三维图像 

48
00:03:34.597 --> 00:03:37.804
不是那种平面上的有灰度值的图像 

49
00:03:37.804 --> 00:03:40.640
就像这样 每个像素都有一个灰度值的这个平面 

50
00:03:40.640 --> 00:03:45.387
但是我们将要说到的体积图像 位于其空间内的每个点 

51
00:03:45.387 --> 00:03:48.532
称之为 体素 (voxel) 都有灰度值 

52
00:03:48.532 --> 00:03:53.156
邻域关系对于这种图像而言非常重要 

53
00:03:53.156 --> 00:03:56.609
比如说 在医学图像中 判断这个器官和另一个器官是否相邻 

54
00:03:56.609 --> 00:04:00.863
我们就需要界定邻域关系 

55
00:04:00.863 --> 00:04:04.480
在图像分割的时候 也是如此 

56
00:04:04.480 --> 00:04:09.651
邻域如此重要 但现在我们仅就二维数组中进行讨论 

57
00:04:09.651 --> 00:04:14.670
我们对在二维数组 进行一些简单的操作 

58
00:04:14.670 --> 00:04:19.614
比如说我们可以叠加它们 记住 每一个点 例如这张图 

59
00:04:19.614 --> 00:04:25.546
每个点都有相应的值 因此 我可以把这张图像叠加到第二张上 

60
00:04:25.546 --> 00:04:29.020
所以我可以把图像一 

61
00:04:29.020 --> 00:04:36.120
加到图像二上 这就意味着 我特意在这画一个小图像 

62
00:04:36.120 --> 00:04:40.530
图像为三行三列 

63
00:04:40.530 --> 00:04:44.677
我取这个点的值与另外这个点的值相加 

64
00:04:44.677 --> 00:04:50.301
我假设这个值是7 另一个的值是10 那么结果就是17 

65
00:04:50.301 --> 00:04:53.886
下一个像素我也这么处理 

66
00:04:53.886 --> 00:04:56.557
这种图像相加很简单 

67
00:04:56.557 --> 00:05:00.072
是一种简单却又很重要的处理方法 

68
00:05:00.072 --> 00:05:03.024
我们看看这个操作 

69
00:05:03.024 --> 00:05:07.338
这里有好几张NASA拍摄的同一个星系的图像 

70
00:05:07.338 --> 00:05:11.853
他们拍摄 再拍摄  重复多次 得到越来越多的图像 

71
00:05:11.853 --> 00:05:15.195
这张图像噪点很多 这些图像排列在一起 

72
00:05:15.195 --> 00:05:18.244
他们不移动相机 什么都不变 

73
00:05:18.244 --> 00:05:21.880
然后一张接一张拍摄 再叠加起来 

74
00:05:21.880 --> 00:05:26.954
随着他们对图像的叠加 图像开始变得越来越清晰 

75
00:05:26.954 --> 00:05:30.760
因此这里 他们叠加了五张 

76
00:05:30.760 --> 00:05:35.358
然后又叠加十张 直到叠加了100张 

77
00:05:35.358 --> 00:05:41.242
也就是他们把 I1+I2 的操作进行了100次   

78
00:05:41.242 --> 00:05:46.104
就是把一百张的星系图片 叠加到一起 

79
00:05:46.104 --> 00:05:50.304
使得得到的图像开始变得越来越清晰 这是因为图像有噪声 

80
00:05:50.304 --> 00:05:54.872
这些图像中的场景固定不变 

81
00:05:54.872 --> 00:06:00.324
这些噪声却不断变化 当你把图片都叠加起来 

82
00:06:00.324 --> 00:06:05.636
相当于叠加了图片中拍摄对象的像素值 而噪声又是随机的 

83
00:06:05.636 --> 00:06:10.012
这样噪声就显得微不足道了 当我们讨论如何处理空间噪声 

84
00:06:10.012 --> 00:06:14.919
以及讨论如何增强图像的时候 我们将非常详细地讨论这个话题 

85
00:06:14.919 --> 00:06:20.091
那么基本思路就是 我们可以简单地将一些二维数组相加 

86
00:06:20.091 --> 00:06:25.323
从而完成一些有趣的处理 我们还可以做其他的事情 

87
00:06:25.323 --> 00:06:30.263
我们还可以对图像进行掩模处理或者相减运算 

88
00:06:30.263 --> 00:06:38.193
我们可以看到这幅图像 还有这幅图像 

89
00:06:38.193 --> 00:06:42.974
这是同一场景在不同情况下拍摄的两张图像   

90
00:06:42.974 --> 00:06:46.234
接下来 我们找出了它们之间的差别 

91
00:06:46.234 --> 00:06:49.929
你看 这个凸显出来的不同之处 

92
00:06:49.929 --> 00:06:55.507
可能对于医生来讲非常非常重要 而这是增强以后的图像 

93
00:06:55.507 --> 00:07:00.796
我们往后会讲到如何增强图像 

94
00:07:00.796 --> 00:07:03.984
例如 通过改变灰度值的分布使其更加清晰 

95
00:07:03.984 --> 00:07:14.700
那么这里 上面两幅图我们标记为 I1、I2 然后进行了 I1-I2 

96
00:07:14.700 --> 00:07:19.805
如果不关心正负的话 我们有时候也会取绝对值 

97
00:07:19.805 --> 00:07:22.656
有时 我们只是移走所有负数值的像素 

98
00:07:22.656 --> 00:07:25.905
这样就把负值都变成了 0 

99
00:07:25.905 --> 00:07:31.160
这再一次证明了这种简单的操作也具有重要意义 

100
00:07:31.160 --> 00:07:35.919
有时 我们也可以对图像进行逻辑运算 

101
00:07:35.919 --> 00:07:42.299
我们可以对图像A和图像B 做A并B的运算 

102
00:07:42.299 --> 00:07:46.877
让我们假设这部分 (A部分) 的值都是255 

103
00:07:46.877 --> 00:07:50.351
其余部分都是0 B部分的值也全部是255 

104
00:07:50.351 --> 00:07:53.456
然后得到并集 这个图我们得到了交集 

105
00:07:53.456 --> 00:07:58.779
即 在A和B中 值为255或者白色值的所有像素 

106
00:07:58.779 --> 00:08:04.102
同理 想一想用你的电脑你可以对二维数组进行哪些运算 

107
00:08:04.102 --> 00:08:10.016
你也可以对图像进行相同操作 现在我们知道了 

108
00:08:10.016 --> 00:08:16.590
用计算机操作二维数组是多么重要 我们还能对一幅图像进行反相 

109
00:08:16.590 --> 00:08:22.742
基本思想是 这部分特别黑的地方是0 

110
00:08:22.742 --> 00:08:28.020
最亮的这个点是255 

111
00:08:28.020 --> 00:08:33.988
然后我们可以进行反相 将0变成255 

112
00:08:33.988 --> 00:08:38.600
将255变成0 在坐标里表示就是这样 

113
00:08:38.600 --> 00:08:46.580
假设横轴是输入 纵轴是输出   

114
00:08:46.580 --> 00:08:51.516
画出来就是这样的 0对应成255 255对应成0 

115
00:08:51.516 --> 00:08:57.250
我们对图像反相操作 利用这个我们可以发现一些有趣的事情   

116
00:08:57.250 --> 00:09:02.694
也许反相后的图像会比原来的图像 

117
00:09:02.694 --> 00:09:06.541
更容易从中观察到一些对象 

118
00:09:06.541 --> 00:09:12.276
总结一下 数组的这些简单操作可通过计算机运用于图像处理之中 

119
00:09:12.276 --> 00:09:16.450
我们也能做不同的空间操作 

120
00:09:16.450 --> 00:09:19.546
比如图像叠加 我用一张图片 

121
00:09:19.546 --> 00:09:21.610
再拿另一张图片 然后相加 

122
00:09:21.610 --> 00:09:25.806
或是图像反相之类 但是我们还能做一些更复杂的事情 

123
00:09:25.806 --> 00:09:30.966
事实上我们还可以把图像中一个像素替换为的与之相邻像素的平均值 

124
00:09:30.966 --> 00:09:34.612
注意 需要先定义相邻像素的类型 

125
00:09:34.612 --> 00:09:35.644
好的？ 

126
00:09:35.644 --> 00:09:39.360
因此 我们可以设为 8邻域 我们之前讲到过这个 

127
00:09:41.080 --> 00:09:47.944
我可以把这个像素替换为所有像素的平均值 也包括它自己 

128
00:09:47.944 --> 00:09:51.728
因而我们只要把所有像素的值相加 

129
00:09:51.728 --> 00:09:56.920
然后再除以9 把得到的数值赋给这个像素 

130
00:09:56.920 --> 00:10:00.088
这个是原图 

131
00:10:00.088 --> 00:10:04.136
我们把每一个像素点都做了这样的处理然后是这样 

132
00:10:04.136 --> 00:10:08.611
所以对于这个像素 我把它标记在这里 

133
00:10:08.611 --> 00:10:14.575
我们找到了它的 8邻域 然后把这个像素替换为 

134
00:10:14.575 --> 00:10:18.321
周围所有像素的平均值 

135
00:10:18.321 --> 00:10:21.992
然后对于下一个像素 我们也这样做 

136
00:10:21.992 --> 00:10:29.574
这里发生了交叠 我用另外一个颜色标出来 

137
00:10:29.574 --> 00:10:34.439
因此 这个像素会用到这个 这个 这个 

138
00:10:34.439 --> 00:10:42.651
这个 这个 这个 这个 还有这个 蓝色的点则用到了这个 

139
00:10:42.651 --> 00:10:49.370
这个和这个 这是它自己的 8邻域 

140
00:10:49.370 --> 00:10:54.285
之所以会交叠 是因为我们一次变换一个像素 

141
00:10:54.285 --> 00:10:58.057
然后我们对图像中每个像素都是这样一个一个处理 

142
00:10:58.057 --> 00:11:00.885
极力推荐你做一下这个小练习 

143
00:11:00.885 --> 00:11:05.127
这就是我们得到的结果 我们移除了噪点 

144
00:11:05.127 --> 00:11:08.842
但却得到一张很模糊的图像 我将会说明为什么会这样 

145
00:11:08.842 --> 00:11:12.809
在一些情况下 这是一种的很有用的图像处理应用 

146
00:11:12.809 --> 00:11:15.617
我们将会了解这是怎么实现的 

147
00:11:15.617 --> 00:11:20.561
我们所选取的相邻像素 事实上并非那么简单 

148
00:11:20.561 --> 00:11:25.627
当像素间变化比较大时 我们不会用到另一边的像素 

149
00:11:25.627 --> 00:11:28.679
因此 最终可能只用了 6个像素进行平均 

150
00:11:28.679 --> 00:11:32.830
而不是通常 9个像素的平均 

151
00:11:32.830 --> 00:11:37.626
这是一种非常简单的操作 每个像素被替换为一种线性组合 

152
00:11:37.626 --> 00:11:42.400
在这里 就是指替换为周围像素的平均值 

153
00:11:42.400 --> 00:11:46.908
另一种图像处理方式是图像变换 

154
00:11:46.908 --> 00:11:50.584
我们可以做各种不同的图像变换 

155
00:11:50.584 --> 00:11:54.330
这个是我们没有变化的原始图像 

156
00:11:54.330 --> 00:11:57.650
我们可以对它进行缩放 比如使其变大 

157
00:11:57.650 --> 00:12:01.561
我们也可以让图像旋转、移动、平移等等 

158
00:12:01.561 --> 00:12:05.177
我们可以用数组进行平移变换 

159
00:12:05.177 --> 00:12:10.565
我们还可以用数组进行旋转变换和缩放变换 

160
00:12:10.565 --> 00:12:16.837
它们都是计算机中的二维数组 因此我们可以进行任意的这些操作 

161
00:12:16.837 --> 00:12:20.453
这就是操作的效果 如果我们要旋转图像 

162
00:12:20.453 --> 00:12:26.380
我们要进行旋转变换 我们把 T 所在的图像整个旋转 

163
00:12:26.380 --> 00:12:29.530
从而看上去这个 T 被旋转了一些角度 

164
00:12:29.530 --> 00:12:34.780
放大边缘看一下 这再一次说明了离散化的问题 

165
00:12:34.780 --> 00:12:40.465
当我画一条直线的时候 

166
00:12:40.465 --> 00:12:46.410
放在这个离散化的图像中 如果是这么竖直画的话 

167
00:12:46.410 --> 00:12:52.493
就不会有问题 但是 当一条直线这样画 

168
00:12:52.493 --> 00:12:55.799
不位于中间 而是穿过对角线方向 

169
00:12:55.799 --> 00:12:59.675
就会产生像我们在这看到的这种不完整的效果 

170
00:12:59.675 --> 00:13:03.213
像素点越多的话 

171
00:13:03.213 --> 00:13:08.100
我们就越难察觉这种问题 这里我们只讨论旋转的可能后果 

172
00:13:08.100 --> 00:13:14.334
对图像进行不同操作的可能后果 

173
00:13:14.334 --> 00:13:20.147
这是一个完整的例子 我希望你能看看它 

174
00:13:20.147 --> 00:13:23.686
这是我的原始图像 这是旋转后的图像 

175
00:13:23.686 --> 00:13:29.076
我们也可以把它转回来 看上去还算不错 

176
00:13:29.076 --> 00:13:33.771
但还是有些不同 这是两幅图像的不同之处 

177
00:13:33.771 --> 00:13:38.061
如果要写出来这个过程 

178
00:13:38.061 --> 00:13:42.380
我有一张图 I 然后我旋转它 R(I) 

179
00:13:43.900 --> 00:13:50.240
这个的结果 就得到了这个图 

180
00:13:50.240 --> 00:13:57.746
再朝相反方向旋转它 就能得到这幅图 

181
00:13:57.746 --> 00:14:02.589
然后两张图相减 也就是这个部分减去 I   

182
00:14:02.589 --> 00:14:07.879
这是 I  这是旋转后的图像 这是逆旋转的图像 

183
00:14:07.879 --> 00:14:12.694
这个是相减后的图像 两者不同的原因就是 

184
00:14:12.694 --> 00:14:18.322
因为采样和离散化 我们在之前的视频中讨论过 

185
00:14:18.322 --> 00:14:22.963
还有一点 我们可以实现的 

186
00:14:22.963 --> 00:14:28.146
将在下一周讲述关于图像压缩的话题时讨论 

187
00:14:28.146 --> 00:14:31.601
我们可以对图像进行变换 

188
00:14:31.601 --> 00:14:36.982
你们在数字信号处理的课程中已经知道了 有一种变换是 

189
00:14:36.982 --> 00:14:41.899
傅里叶变换 (Fourier transform) 我们可以对一幅图像进行傅里叶变换 

190
00:14:41.899 --> 00:14:45.686
而在图像压缩中非常重要的一点是 

191
00:14:45.686 --> 00:14:48.875
我们不做傅里叶变换 我们要进行一种 

192
00:14:48.875 --> 00:14:52.330
叫做离散余弦变换 (Discrete Cosine Transform) 的变换 

193
00:14:52.330 --> 00:15:00.323
这是一幅图像 我们对它进行傅里叶变换 

194
00:15:00.323 --> 00:15:03.030
这是傅里叶变换后的图像 

195
00:15:03.030 --> 00:15:09.520
你现在所看到的是噪声能够在傅里叶域中滤除掉 

196
00:15:09.520 --> 00:15:15.573
我不在这讨论关于傅里叶的信号处理 (signal processing) 的背景知识 

197
00:15:15.573 --> 00:15:21.072
而且我们也不需要了解很多 我将会在今后每周 

198
00:15:21.072 --> 00:15:25.529
的课程中讲到那周需要的背景知识 实际上我们也不会用到太多的傅里叶 

199
00:15:25.529 --> 00:15:28.648
如果你不具备这些知识 那么不用傅里叶变换 

200
00:15:28.648 --> 00:15:32.086
我们也可以完成许多的图像处理 

201
00:15:32.086 --> 00:15:36.606
因此 你也不必去上数字信号处理的课程 别担心 

202
00:15:36.606 --> 00:15:40.489
除了这一页幻灯片 我们不用傅里叶就可以完成所有事情 

203
00:15:40.489 --> 00:15:44.691
所以 不用担心 但如果你们熟悉傅里叶的话 

204
00:15:44.691 --> 00:15:49.592
你就能看到滤波的效果 比如说 这个是滤波器 

205
00:15:49.592 --> 00:15:51.630
这是处理后的结果 因此 我完成了变换 

206
00:15:51.630 --> 00:15:55.012
经过滤波和逆变换 得到了一张非常清晰的图像 

207
00:15:55.012 --> 00:15:59.272
再重复一遍 如果你们熟悉基本的关于傅里叶变换的信号处理知识 

208
00:15:59.272 --> 00:16:04.284
这里也只会用到傅里叶滤波器 

209
00:16:04.284 --> 00:16:09.170
如果你们对此不太熟悉的话 你可以理解为我把这幅图像 

210
00:16:09.170 --> 00:16:14.495
这个二维数组变换为另一个不同的二维数组 

211
00:16:14.495 --> 00:16:19.570
然后我进行了一些操作 然后又变换回来 我就得到了一张清晰的图像 

212
00:16:19.570 --> 00:16:25.160
再一次 这只是为了直观地展示我们所做的 

213
00:16:25.160 --> 00:16:30.750
其实是对二维数组的运算 对于每个点 会有对应的值 

214
00:16:30.750 --> 00:16:36.723
这个值可以表示特定位置、像素的亮度或者颜色 

215
00:16:36.723 --> 00:16:40.092
现在我们知道了图像 

216
00:16:40.092 --> 00:16:42.620
在计算机中是如何表示的 

217
00:16:42.620 --> 00:16:47.910
现在 我们发现如果我们想要很多像素 

218
00:16:47.910 --> 00:16:52.387
想有很多的灰度值 就需要占据很大的空间 

219
00:16:52.387 --> 00:16:57.678
因此 在下周的视频中 我们就来讨论压缩的问题 

220
00:16:57.678 --> 00:17:03.172
怎样才能在保持图像质量的前提下处理大量的数据 

221
00:17:03.172 --> 00:17:05.140
谢谢大家
//果壳教育无边界字幕组  showonder | 风过成伤 | 小白_远游