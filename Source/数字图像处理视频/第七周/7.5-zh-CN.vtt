WEBVTT

1
00:00:00.000 --> 00:00:04.952
【未完成版本】大家好 欢迎回来 让我们来看看图像恢复的另一个概念 

2
00:00:04.952 --> 00:00:09.043
我们这一节要学习的是智能剪切与粘贴 

3
00:00:09.043 --> 00:00:12.272
我们首先介绍这个概念 

4
00:00:12.272 --> 00:00:17.584
然后再来看看如何将其与之前视频中讲过的 

5
00:00:17.584 --> 00:00:23.397
变分法和公式法结合起来得到很好的结果 

6
00:00:23.397 --> 00:00:26.845
那么 我们为什么需要另一种形式的图像修复技术呢？ 

7
00:00:26.845 --> 00:00:29.869
其实有很多原因 

8
00:00:29.869 --> 00:00:35.520
其中一个原因 在之前视频里的例子中就有体现 

9
00:00:35.520 --> 00:00:41.128
我们知道 实际上偏微分方程和变分公式 

10
00:00:41.128 --> 00:00:44.740
用于光滑连续区域的修复是非常好的 

11
00:00:44.740 --> 00:00:49.274
但是我们这里可以看到 它们在纹理的修复上就不是很理想了 

12
00:00:49.274 --> 00:00:55.037
我们需要将这些区域中的纹理扩展到损坏了的区域上去 

13
00:00:55.037 --> 00:00:58.649
在这种情形下 这种类型的技术 

14
00:00:58.649 --> 00:01:04.720
就非常有用了 我们把这个区域放大了看看 

15
00:01:04.720 --> 00:01:09.007
便于我们解释这个技术 我们现在需要修复这里面的区域 

16
00:01:09.007 --> 00:01:12.719
这里的这些图案是我们想要扩展上去的 

17
00:01:12.719 --> 00:01:17.960
当然这里用偏微分方程来扩展这个流到这些区域也是可行的 

18
00:01:17.960 --> 00:01:22.619
但是对于这里的这种有多个方向的纹理 

19
00:01:22.619 --> 00:01:28.224
用偏微分方程的方法 就比较困难了 

20
00:01:28.224 --> 00:01:32.076
但是我们还有另一种技术 

21
00:01:32.076 --> 00:01:36.790
回忆一下我们讲过的非局部均值方法处理图像噪声 

22
00:01:36.790 --> 00:01:42.542
我们恰好可以利用同种类型的方法 不过这一次是用在图像修复上 

23
00:01:42.542 --> 00:01:47.715
我们来看看其基本思想 假设从这里取一小片图像出来 

24
00:01:49.095 --> 00:01:52.137
这个小片比较特别 

25
00:01:52.137 --> 00:01:57.403
它包含了一些已知信息区域和未知信息区域 

26
00:01:57.403 --> 00:02:03.573
现在使用跟非局部平均一样的办法 

27
00:02:03.573 --> 00:02:09.742
我们在周围寻找相似的小片 但是我们只对已知信息的区域做对比 

28
00:02:09.742 --> 00:02:14.103
例如 我们在这里取相同大小的一片 

29
00:02:14.103 --> 00:02:18.710
但是我们只关注这个区域 

30
00:02:18.710 --> 00:02:24.545
并且这部分区域跟这部分区域相似 然后继续 

31
00:02:24.545 --> 00:02:30.190
比如我们可能查看这里 然后我们还是只关注这部分区域 

32
00:02:30.190 --> 00:02:34.100
这样就至少把已知区域平移到了那个区域上 

33
00:02:34.100 --> 00:02:41.121
我们继续这个过程 最终我们在已知的区域里可能发现 

34
00:02:41.121 --> 00:02:46.454
一个或多个这样的小片 它们相同或者非常相似 

35
00:02:46.454 --> 00:02:51.520
假设我们已经找到了一个 比如在这里找到一个 

36
00:02:51.520 --> 00:02:57.920
我把这里涂一下 然后我们就说 好吧 这跟这里非常相似 

37
00:02:57.920 --> 00:03:02.480
那么我们如何填充这个区域呢？只要把这部分复制过来就可以了 

38
00:03:02.480 --> 00:03:09.360
未知的区域就变成了匹配部分的已知部分 

39
00:03:09.360 --> 00:03:14.548
可以复制整个区域 也可以只复制一些边界像素 

40
00:03:14.548 --> 00:03:20.701
还可以只从一个部分复制 或者 如果我们找到了多个小片 

41
00:03:20.701 --> 00:03:24.333
跟这部分像素相似 那也可以取它们的平均 或者应用其他任何形式的函数 然后复制到这里 

42
00:03:24.333 --> 00:03:28.632
不过其基本概念跟非局部平均的基本思想是一致的 

43
00:03:28.632 --> 00:03:34.043
找到相似的小片 但是现在相似只基于已知的区域 

44
00:03:34.043 --> 00:03:39.189
一旦我们找到了相似的区域 就可以复制已知区域到这里 

45
00:03:39.189 --> 00:03:42.326
只要做了这个 这部分就完成了 并且它变成了已知的 

46
00:03:42.326 --> 00:03:47.142
这样我们就可以继续传递下去 这部分现在变成了已知的 

47
00:03:47.142 --> 00:03:51.008
【未完成版本】因为它已经被填充了 然后就可以继续 

48
00:03:51.008 --> 00:03:56.918
不断地重复这个过程 所以其基本思想就是检查所有未知的像素 

49
00:03:56.918 --> 00:04:00.843
我们从周围有很多已知区域的像素开始 

50
00:04:00.843 --> 00:04:03.673
不断填充它们 

51
00:04:03.673 --> 00:04:09.117
然后对其他像素不断重复这个过程 直到填满所有的像素 

52
00:04:09.117 --> 00:04:14.415
我们回到前一张幻灯片 

53
00:04:14.415 --> 00:04:19.140
我们可以看到 这些纹理看起来要好很多 

54
00:04:19.140 --> 00:04:24.740
这里这些纹理也不错 实际上 

55
00:04:24.740 --> 00:04:30.580
整个图像上的纹理都得到了很好的修复 就是用了跟非局部平均相同的概念 

56
00:04:30.580 --> 00:04:34.349
现在我们可以将其与变分公式结合起来 

57
00:04:34.349 --> 00:04:39.316
我们刚才谈过 可以写出其变分公式 

58
00:04:39.316 --> 00:04:44.749
不过我们还要加上一些额外的限制 

59
00:04:44.749 --> 00:04:50.492
比如 我们可以说 好吧 如果这个小片在这里找到了一个朋友 

60
00:04:50.492 --> 00:04:56.624
也就是说一个跟它很相似的小片 我想确保跟它相邻的小片 

61
00:04:56.624 --> 00:05:00.660
不好意思 我换一下笔的颜色 我想要确保 

62
00:05:00.660 --> 00:05:08.848
跟它相邻的这个小片 找到一个与前一个相邻的相似部分 

63
00:05:08.848 --> 00:05:14.566
那这个就可以帮助我们 这会加快搜索的过程 

64
00:05:14.566 --> 00:05:20.385
并且还会强制这个区域平滑地复制到这里 

65
00:05:20.385 --> 00:05:24.980
这样就能通过例如寻找平移向量来得出变分公式 

66
00:05:24.980 --> 00:05:30.177
这部分从这里平移到这里 

67
00:05:30.177 --> 00:05:35.375
这部分平移到这里 我们有了两个平移向量 

68
00:05:35.375 --> 00:05:39.719
我们可以强制平移向量平滑变化 

69
00:05:39.719 --> 00:05:45.227
这就得到了变分公式 例如   

70
00:05:45.227 --> 00:05:51.122
我们可以对平移向量求对坐标方向的导数 

71
00:05:51.122 --> 00:05:56.708
如果导数太大就进行相应的惩罚 

72
00:05:56.708 --> 00:05:59.525
我们就只在周围得到一些新的小片 

73
00:05:59.525 --> 00:06:05.659
所有这些概念可以组合成一个变分公式 

74
00:06:05.659 --> 00:06:10.120
这样就相当富集了 我们可以合并偏微分方程 

75
00:06:10.120 --> 00:06:16.652
或者光滑连续变分公式 如前所见 

76
00:06:16.652 --> 00:06:20.236
我们可以合并智能剪切和粘贴到 

77
00:06:20.236 --> 00:06:24.140
一个大的变分公式里 

78
00:06:24.140 --> 00:06:31.044
就可以得到一个如这里这个一样好的结果 

79
00:06:31.044 --> 00:06:37.181
我们可以看到 这里有个物体被移除了 这是通过组合 

80
00:06:37.181 --> 00:06:43.543
变分公式和智能剪切粘贴得到的 这里是另一个例子 

81
00:06:43.543 --> 00:06:48.877
很快我还会在下一个视频中继续讲解这个例子 

82
00:06:48.877 --> 00:06:52.687
经过修复过的这张图片看起来非常好 

83
00:06:52.687 --> 00:06:59.163
我们把这个灯移除掉 

84
00:06:59.163 --> 00:07:02.440
得到了一个非常好的结果 

85
00:07:02.440 --> 00:07:07.815
这里这个例子 是移除了这些栅栏 

86
00:07:07.815 --> 00:07:13.532
我们通过组合剪切粘贴和变分公式 得到了一个很好的结果 

87
00:07:13.532 --> 00:07:19.547
我们已经见过两种 

88
00:07:19.547 --> 00:07:25.713
或者三种概念 偏微分方程和变分公式 

89
00:07:25.713 --> 00:07:31.204
这两个基本上是算同一种 因为标准变分公式得到的也是偏微分方程 

90
00:07:31.204 --> 00:07:36.434
然后是智能剪切与粘贴 我们也见过了如何将他们组合在一起 

91
00:07:36.434 --> 00:07:40.225
然后得到很好的图像修复结果 

92
00:07:40.225 --> 00:07:45.324
在我介绍视频修复的概念之前 我想演示一下 

93
00:07:45.324 --> 00:07:48.200
实时修复 我们将在下一个视频里讲解这个 

94
00:07:48.200 --> 00:07:51.273
希望能再次见到大家 

95
00:07:51.273 --> 00:07:51.927
谢谢大家