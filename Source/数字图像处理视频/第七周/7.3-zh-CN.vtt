WEBVTT

1
00:00:00.000 --> 00:00:03.974
【未完成版本】欢迎回来 我们来看第一个图像修复的例子 

2
00:00:03.974 --> 00:00:07.882
这个例子基于我们上周学过的 

3
00:00:07.882 --> 00:00:11.453
偏微分方程 

4
00:00:11.453 --> 00:00:16.236
和上周一样 这周的知识也是独立的 

5
00:00:16.236 --> 00:00:21.020
我们将会学习用哪一种偏微分方程 

6
00:00:21.020 --> 00:00:25.649
当谈到图像修复时 我们是指 

7
00:00:25.649 --> 00:00:29.940
有一幅图像 这里有一个区域 

8
00:00:29.940 --> 00:00:33.989
我们想要改变图像上这个区域的内容 

9
00:00:33.989 --> 00:00:36.717
在这幅图中 这是条绳子 

10
00:00:36.717 --> 00:00:41.180
这部分有时会提供给我们 

11
00:00:41.180 --> 00:00:46.760
图像修复要求有两幅这样的图像作为系统的输入 

12
00:00:46.760 --> 00:00:51.753
我们不会做图像检测 因为这是非常主观的 

13
00:00:51.753 --> 00:00:56.159
我们每个人想要修改的内容依主观而不同 

14
00:00:56.159 --> 00:01:01.614
有人可能想修改鞋子 此时 我们就要修改鞋子 

15
00:01:01.614 --> 00:01:05.712
那么如何检测想要修改的部分？ 我们要用到图像分割 

16
00:01:05.712 --> 00:01:10.530
因此得分割出对象 也就是缺少信息的区域 

17
00:01:10.530 --> 00:01:14.053
我们称之为待修复的原始图 

18
00:01:14.053 --> 00:01:17.360
利用这里的两幅图像 

19
00:01:17.360 --> 00:01:20.452
我们想让绳子消失 

20
00:01:20.452 --> 00:01:23.420
将在这个区域进行修复 

21
00:01:23.420 --> 00:01:28.806
接下来要讨论的第一个主题是 

22
00:01:28.806 --> 00:01:32.397
如何利用该区域周围的丰富信息来修复图像 

23
00:01:32.397 --> 00:01:36.456
我们不会使用距离此区域很远地方的信息 

24
00:01:36.456 --> 00:01:41.374
仅仅使用周围区域图像的信息 

25
00:01:41.374 --> 00:01:46.213
因此我们得到两幅图像 一幅原始图像 

26
00:01:46.213 --> 00:01:51.600
另一幅是待修复区域的二值掩膜图像 

27
00:01:51.600 --> 00:01:57.323
当我和我的团队开始研究图像修复时 

28
00:01:57.323 --> 00:02:03.691
我们拜访了明尼阿波利斯美术馆的专业馆长 他同时也是一个专业的餐馆老板 

29
00:02:03.691 --> 00:02:08.044
我们向他咨询如何修复和复原图像 

30
00:02:08.044 --> 00:02:13.283
他们的方法十分独特 

31
00:02:13.283 --> 00:02:18.926
类似于儿童的绘画 下面我来演示一下 

32
00:02:18.926 --> 00:02:23.360
这里有待修复的区域以及图像 

33
00:02:23.360 --> 00:02:27.943
首先它们延展出区域边缘 

34
00:02:27.943 --> 00:02:34.170
因此如果在待修复区域里有一个边缘 

35
00:02:34.170 --> 00:02:37.803
然后就延展出内部的边缘 

36
00:02:37.803 --> 00:02:44.290
小孩正是用同样的方法来描画物体的轮廓 

37
00:02:44.290 --> 00:02:49.207
接着完成颜色的修复 因此 首先他们延展出边缘 

38
00:02:49.207 --> 00:02:52.803
然后把颜色扩散到区域内 

39
00:02:52.803 --> 00:02:58.528
最后 他们通常会加入某种噪声以模仿绘图效果 

40
00:02:58.528 --> 00:03:04.473
至此便完成了一个专业的画作修复 为了看起来没有瑕疵 

41
00:03:04.473 --> 00:03:08.950
必须加入这种颗粒噪声 使图像看上去更自然 

42
00:03:08.950 --> 00:03:14.360
接下来我们就要研究这些内容 首先讨论这两步 

43
00:03:14.360 --> 00:03:20.615
然后再简单讨论下这步 它涉及到了许多技术 

44
00:03:20.615 --> 00:03:22.414
大概就是这些内容 

45
00:03:22.414 --> 00:03:27.809
记住 首先是边缘的几何延拓 

46
00:03:27.809 --> 00:03:31.406
接着是颜色填充 

47
00:03:31.406 --> 00:03:36.723
就好比这儿是水 我们让它流进这个区域 

48
00:03:36.723 --> 00:03:42.666
但是由于边界的限制 实际上 

49
00:03:42.666 --> 00:03:48.593
右边的水会流入右边的区域 现在要做的就是 

50
00:03:48.593 --> 00:03:52.840
设计一个偏微分方程来仿真这个过程 

51
00:03:52.840 --> 00:03:58.301
就像这样 在这个区域外有图像 

52
00:03:58.301 --> 00:04:02.762
但内部是缺损信息的区域 

53
00:04:02.762 --> 00:04:07.572
我们要把外部的信息扩散到内部 

54
00:04:07.572 --> 00:04:11.946
实现方法就是利用这个方程 

55
00:04:11.946 --> 00:04:18.418
这是偏微分方程处理图像的第一个步骤 

56
00:04:18.418 --> 00:04:21.480
这个方程具体含义是什么呢？ 

57
00:04:21.480 --> 00:04:25.303
L 代表我们需要要扩散的信息 

58
00:04:25.303 --> 00:04:31.420
我现在不告诉你信息指什么 

59
00:04:31.420 --> 00:04:37.274
 就把它看成我们要扩散的东西 向量N表示信息扩散的方向  

60
00:04:37.274 --> 00:04:43.908
所以我们就沿N方向做扩散操作 

61
00:04:43.908 --> 00:04:48.104
现在来看看这儿发生了什么 

62
00:04:48.104 --> 00:04:52.300
这里得到L的梯度 它表示L的变化 

63
00:04:52.300 --> 00:04:59.155
和向量N做内积得到0 这儿是L的变化 

64
00:04:59.155 --> 00:05:06.667
因为内积作用 它被投影到N方向 也就是扩散方向 

65
00:05:06.667 --> 00:05:11.362
我们想要这个投影等于零 这儿当然是一个向量 

66
00:05:11.362 --> 00:05:16.340
这是信息的梯度 因此我们得到一个向量 

67
00:05:16.340 --> 00:05:21.870
同时让这个向量垂直于扩散方向 

68
00:05:21.870 --> 00:05:27.961
所以这是L的梯度 

69
00:05:27.961 --> 00:05:32.370
这是扩散的方向 我们要它们互相垂直 

70
00:05:32.370 --> 00:05:37.580
也就是说 我们要用这个方法来扩散信息并且不改变它 

71
00:05:37.580 --> 00:05:43.792
也就是信息在传播方向上没有改变 

72
00:05:43.792 --> 00:05:49.150
这就是信息传播的具体内容 

73
00:05:49.150 --> 00:05:54.888
让信息沿着一个方向保持不变地扩散 

74
00:05:54.888 --> 00:05:59.303
这就是这个方程所揭示给我们的 

75
00:05:59.303 --> 00:06:06.013
信息L在扩散方向上保持不变 在这些方向上都维持恒定 

76
00:06:06.013 --> 00:06:11.399
那么如何引入偏微分方程来求解呢？ 

77
00:06:11.399 --> 00:06:15.813
假设这个图像用 I 表示 

78
00:06:15.813 --> 00:06:21.992
现在已知这个方程 我们想要变形和修改这幅图像 

79
00:06:21.992 --> 00:06:27.814
这些操作在数学上就对应一个偏微分方程 经过某种方式最后等于零 

80
00:06:27.814 --> 00:06:32.793
在我们讨论欧拉-拉格朗日方程时 已经知道如何做到这一点 

81
00:06:32.793 --> 00:06:38.691
如果令某个量等于零 

82
00:06:38.691 --> 00:06:43.211
那我对图像做什么操作才能达到这个目的呢？ 

83
00:06:43.211 --> 00:06:47.731
我们先想想该怎么做 回忆一下上周 

84
00:06:47.731 --> 00:06:51.700
当时我们是如何做的？ 非常简单 

85
00:06:51.700 --> 00:06:58.252
让我们花一点时间回忆一下 

86
00:06:58.252 --> 00:07:05.573
首先 令图像在时间上的变化 

87
00:07:05.573 --> 00:07:12.455
等于我们想要的这个式子 当图像不再改变时 

88
00:07:12.455 --> 00:07:17.129
也就是达到稳态时 这个式子等于零 

89
00:07:17.129 --> 00:07:21.893
这就是稳态的定义——不再变化 

90
00:07:21.893 --> 00:07:27.555
实际上 在计算机里 当变化很小时就可认为不再变化 

91
00:07:27.555 --> 00:07:31.870
当它达到理想状态的零时 就得到了我们想要的 

92
00:07:31.870 --> 00:07:36.011
L在扩散方向上保持恒定 

93
00:07:36.011 --> 00:07:43.549
这是个非常简单的技巧 当你想得到 

94
00:07:43.549 --> 00:07:52.500
A = 0 的形式时 A可能是图像的某些信息 可令 ∂I/∂t = A 

95
00:07:52.500 --> 00:07:59.442
接着令它达到稳态 这就是我们对欧拉-拉格朗日方程的处理 

96
00:07:59.442 --> 00:08:03.407
这就是基本的图像修复方程 

97
00:08:03.407 --> 00:08:06.897
但现在并没有结束 

98
00:08:06.897 --> 00:08:12.594
接下来要告诉你L和N代表什么 我们想要扩散的信息是什么 

99
00:08:12.594 --> 00:08:15.941
以及往哪个方向上扩散 

100
00:08:15.941 --> 00:08:18.790
这里涉及到许多巧妙的技巧 

101
00:08:18.790 --> 00:08:23.205
我会讲一些例子 给你们一些概念 

102
00:08:23.205 --> 00:08:27.051
这些例子经证明是非常有效的 

103
00:08:27.051 --> 00:08:35.840
你也可以举其他的例子 现在首先来看信息L 

104
00:08:35.840 --> 00:08:41.557
我们要求扩散是平滑的 不希望待修复区域出现巨大的反差 

105
00:08:41.557 --> 00:08:46.665
如果有巨大的反差 我们就会注意到那个区域 

106
00:08:46.665 --> 00:08:49.638
所以我们要求平滑   

107
00:08:49.638 --> 00:08:55.584
所以任何能反映图像平滑性的量都可以表示L 

108
00:08:55.584 --> 00:09:01.225
图像的拉普拉斯变换就是表征平滑度的一个量 

109
00:09:01.225 --> 00:09:05.495
图像的二阶导反映了平滑度 

110
00:09:05.495 --> 00:09:07.921
为什么不是一阶导呢？ 

111
00:09:07.921 --> 00:09:11.287
过一会你就会明白了 

112
00:09:11.287 --> 00:09:16.482
【未完成翻译】因为一阶导数依旧反映了平滑度 

113
00:09:16.482 --> 00:09:19.848
现在的问题是 应该往哪个方向上扩散呢？ 

114
00:09:19.848 --> 00:09:24.823
我们回顾一下从专业复原人员那学到的东西 

115
00:09:24.823 --> 00:09:30.005
他们会延展出边缘 我们知道 如果有一个边缘 

116
00:09:30.005 --> 00:09:34.373
那么图像的梯度是和这个边缘垂直的 

117
00:09:34.373 --> 00:09:40.711
我们上周学过 因此我们想沿着边缘扩散信息 

118
00:09:40.711 --> 00:09:47.306
也就是沿着梯度的垂直方向扩散 

119
00:09:47.306 --> 00:09:53.129
所以N垂直于梯度 像这里写的这样 

120
00:09:53.129 --> 00:09:59.101
也可以这样写 N等于梯度 然后这里加个垂直符号 

121
00:09:59.101 --> 00:10:04.929
这个非常重要 我们要延展出边缘 

122
00:10:04.929 --> 00:10:10.756
然后为了求边缘 我们必须求梯度的垂直方向 

123
00:10:10.756 --> 00:10:18.088
这也解释为什么我们不能只求L的一阶导 

124
00:10:18.088 --> 00:10:23.821
因为如果令L等于图像的一阶导 也就是梯度 

125
00:10:23.821 --> 00:10:27.234
那么这两个量的内积永远等于零 

126
00:10:27.234 --> 00:10:31.654
就不需要解任何方程了 因为梯度和它的垂直量做内积总是零 

127
00:10:31.654 --> 00:10:36.850
而我想要在这个方向得到一个常数 

128
00:10:36.850 --> 00:10:40.525
求一阶导是不够的 

129
00:10:40.525 --> 00:10:46.598
还有其他原因 当然 这两个量一直垂直是不太好 

130
00:10:46.598 --> 00:10:50.194
依然记住我们需要得到L的梯度 

131
00:10:50.194 --> 00:10:54.510
其他原因是 我们想要区域里的两个量平滑 

132
00:10:54.510 --> 00:11:00.100
让区域内的灰度值保持平滑 

133
00:11:00.100 --> 00:11:04.119
同时 区域内的边缘也要求保持平滑 

134
00:11:04.119 --> 00:11:09.607
所以我们需要高阶导数来实现它 

135
00:11:09.607 --> 00:11:15.393
并不仅仅因为这两者互相垂直才不用一阶导 还因为缺少足够的信息 

136
00:11:15.393 --> 00:11:21.475
即使我们求得了L的梯度 梯度的方向与图像修复扩散的方向一致 

137
00:11:21.475 --> 00:11:25.109
所以我们还要更高的阶数以便得到更多的平滑信息 

138
00:11:25.109 --> 00:11:29.782
正如我所说 拉普拉斯变换是衡量平滑度的最简单的方法 

139
00:11:29.782 --> 00:11:34.010
我们便得到了 

140
00:11:34.010 --> 00:11:39.540
在等照度线方向或者梯度的垂直方向 或等高线方向的平滑度 

141
00:11:39.540 --> 00:11:44.670
这样我们就得到了方程 

142
00:11:44.670 --> 00:11:54.850
所以这个表示L的变化 而这个是法线 

143
00:11:54.850 --> 00:11:59.868
它垂直于梯度方向 最终得到什么呢 【未完成版本】   

144
00:11:59.868 --> 00:12:05.756
当达到稳态时 这个式子等于零 

145
00:12:05.756 --> 00:12:09.379
这样图像的拉普拉斯变换沿着边缘方向就是一个常数 

146
00:12:09.379 --> 00:12:13.531
我们沿着边缘扩散拉普拉斯变换 

147
00:12:13.531 --> 00:12:19.796
这就是基本方程所做的 再次地你只要在计算机中将它离散化 

148
00:12:19.796 --> 00:12:24.552
接着运行它 你就实现了图像修复 

149
00:12:24.552 --> 00:12:29.874
你从外部向内部扩散 每个微分方程都必须有边界条件 

150
00:12:29.874 --> 00:12:33.651
如果这是我的图像 而这是我要修复的区域 

151
00:12:33.651 --> 00:12:36.712
我需要在这里做什么呢？ 

152
00:12:36.712 --> 00:12:41.661
对于这种有点奇怪的方程 

153
00:12:41.661 --> 00:12:46.480
它的边界条件有三个导数 两个来自拉普拉斯变换 

154
00:12:46.480 --> 00:12:48.630
还有一个来自梯度 回忆一下 

155
00:12:48.630 --> 00:12:52.712
我们以前讨论过这个 

156
00:12:52.712 --> 00:12:56.311
拉普拉斯变换是图像在一个方向上的二阶导 

157
00:12:56.311 --> 00:12:59.291
加上图像在另一个方向上的二阶导 

158
00:12:59.291 --> 00:13:04.165
然后再对它求梯度 这样就得到了第三个导数   

159
00:13:04.165 --> 00:13:09.993
同时考虑了边界内的灰度值和边缘 它们都光滑向内扩散 

160
00:13:09.993 --> 00:13:15.597
这是因为拉普拉斯变换的作用 

161
00:13:15.597 --> 00:13:22.247
这些法线N就是我们所说的图像的等高线 或者等照度线方向 

162
00:13:22.247 --> 00:13:26.730
或者说是边缘的方向 这些方程非常简单   

163
00:13:26.730 --> 00:13:30.640
但是非常有趣 让我们看一些例子 

164
00:13:30.640 --> 00:13:36.586
当你做图像处理时 一般从非常简单的例子入手检验发生了什么 

165
00:13:36.586 --> 00:13:40.475
这儿就有一个简单的例子 

166
00:13:40.475 --> 00:13:44.049
白色的为待修复的区域 我们来修复它 

167
00:13:44.049 --> 00:13:48.937
可以看到这儿有非常光滑的延续 

168
00:13:48.937 --> 00:13:52.170
非常非常美妙
光滑的延续 

169
00:13:52.170 --> 00:13:57.452
边界 

170
00:13:57.452 --> 00:14:01.709
更重要的是 它补全了这个圆 

171
00:14:01.709 --> 00:14:06.439
它并不知道这里有个圆 

172
00:14:06.439 --> 00:14:09.830
它只是简单地在法线方向上延拓 

173
00:14:09.830 --> 00:14:14.254
垂直于法线方向的是边缘方向 

174
00:14:14.254 --> 00:14:17.425
记住梯度在这个方向 

175
00:14:17.425 --> 00:14:21.480
垂直于梯度方向的是这个方向 

176
00:14:21.480 --> 00:14:25.315
所以它就向待修复的区域延拓并且填充 

177
00:14:25.315 --> 00:14:28.412
在那个方向想扩散信息 

178
00:14:28.412 --> 00:14:33.352
非常棒的结果
当然 如果这个只能作用在人造图像上 

179
00:14:33.352 --> 00:14:38.145
就不是那么棒了
但愿它也能在真实的图像上工作 

180
00:14:38.145 --> 00:14:39.915
这里举一个例子 

181
00:14:39.915 --> 00:14:42.570
要修复的是什么呢？ 

182
00:14:42.570 --> 00:14:47.903
是写在图像之上的字母覆盖的区域
这是一张新奥尔良的美景图像 

183
00:14:47.903 --> 00:14:53.641
我们简单粗暴地处理一下 很快地 字母消失了 

184
00:14:53.641 --> 00:14:59.782
所以要修复的区域是所有这些字母覆盖的区域 

185
00:14:59.782 --> 00:15:04.792
我们把外部的信息扩散到里面 

186
00:15:04.792 --> 00:15:08.914
在这里很难看清  而现在你得到一张非常漂亮的图像 

187
00:15:08.914 --> 00:15:14.813
在被字幕覆盖的区域我们创造了信息 

188
00:15:14.813 --> 00:15:18.845
根据字母周遭的信息 

189
00:15:18.845 --> 00:15:21.900
我认为这是非常漂亮的结果 

190
00:15:21.900 --> 00:15:27.311
这是另一个例子 这是一张恶化和退化的照片 

191
00:15:27.311 --> 00:15:31.114
红色的表示要修复的图像区域 

192
00:15:31.114 --> 00:15:35.721
有时 你标记的区域要比 

193
00:15:35.721 --> 00:15:39.158
实际上缺失信息的区域要大一点点 

194
00:15:39.158 --> 00:15:40.913
看这里
这条线很细 

195
00:15:40.913 --> 00:15:44.643
你可以把它标注地大些
就像给它一个冲激一样 

196
00:15:44.643 --> 00:15:49.542
这是从外部扩散到内部
从稍远的外部开始扩散 

197
00:15:49.542 --> 00:15:53.491
它移动地甚至比你需要的还要光滑 

198
00:15:53.491 --> 00:15:58.204
这就是结果
它看起来很棒 你可能会在这里看到一些小错误 

199
00:15:58.204 --> 00:16:03.974
因为这个女孩的眼睛被遮盖了太多了 

200
00:16:03.974 --> 00:16:09.311
所以当附近区域没有信息来暗示需要填入的内容时 

201
00:16:09.311 --> 00:16:14.215
创造信息是很难的 

202
00:16:14.215 --> 00:16:19.669
当然你已经做得很好了
至少初步的结果看起来几乎完美了 

203
00:16:19.669 --> 00:16:24.878
接着 如果需要的话 采用不同程序的专业修复 

204
00:16:24.878 --> 00:16:29.740
可以只对那个微小的区域进行修复 

205
00:16:29.740 --> 00:16:34.195
有时是没必要那么做的
这是原图 

206
00:16:34.195 --> 00:16:38.428
我们已经看过它了
一个人绑着绳子跳出去 

207
00:16:38.428 --> 00:16:42.512
现在绳子没了 你看到的是放大的区域 

208
00:16:42.512 --> 00:16:45.780
再看一次袜子多么棒地延展 

209
00:16:45.780 --> 00:16:52.396
在条纹边缘非常棒延展
因为这就是我们要的 

210
00:16:52.396 --> 00:16:59.013
连续的边缘 这是我们想要的
而这就是这类算法所起的作用 

211
00:16:59.013 --> 00:17:04.292
所以在我们的例子中 起到了特殊的效果 

212
00:17:04.292 --> 00:17:08.500
让我们看看这里发生了什么 

213
00:17:08.500 --> 00:17:13.830
他们都消失了
我将再展示一遍 

214
00:17:13.830 --> 00:17:17.692
在船上有人 然后他们都消失了 

215
00:17:17.692 --> 00:17:23.254
我们只是修复了这些被船上坐着的人遮盖的区域 

216
00:17:23.254 --> 00:17:27.193
然后这些人就消失了 

217
00:17:27.193 --> 00:17:32.292
再说一次 修复意味着某种形式上不可检测的图像修改 

218
00:17:32.292 --> 00:17:36.300
至少对于普通消费者是这样的 

219
00:17:36.300 --> 00:17:43.791
这是另外一个例子 图片上有一些划痕 现在划痕都消失了 

220
00:17:43.791 --> 00:17:48.424
我们移走了所有划痕 

221
00:17:48.424 --> 00:17:56.112
用附近区域的信息来修复图像 这看起来很棒 

222
00:17:56.112 --> 00:18:00.745
它看起来非常自然 就像没被抓损过一样 

223
00:18:00.745 --> 00:18:04.241
这里有一个例子 

224
00:18:04.241 --> 00:18:09.476
这是这次视频里我要展示的最后一个例子 

225
00:18:09.476 --> 00:18:13.746
在这个例子里 检测需要修复的区域实际上并不是太难 

226
00:18:13.746 --> 00:18:19.050
在之前的其他例子中 用户定义了要修复的区域 

227
00:18:19.050 --> 00:18:24.433
现在这是一个无线传输的图像的例子 

228
00:18:24.433 --> 00:18:28.740
记住 图像使用 JPEG 来传输、存储 

229
00:18:28.740 --> 00:18:32.740
JPEG按块工作
当你传输一个图像时 

230
00:18:32.740 --> 00:18:36.124
会发生信号丢失 

231
00:18:36.124 --> 00:18:40.662
比如说在移动电话的情形中 一半的块丢失了 

232
00:18:40.662 --> 00:18:45.200
现在 信号丢失并不是很难检测 

233
00:18:45.200 --> 00:18:48.583
你没收到信号 于是就检测到了 

234
00:18:48.583 --> 00:18:52.046
懂了吧？
所以当这里发生了丢失 你可以说: 嘿   

235
00:18:52.046 --> 00:18:56.610
我要用上面谈到的修复算法来恢复丢失的块 

236
00:18:56.610 --> 00:19:02.887
那就是我们在这里所模拟的东西
这是原始图像   

237
00:19:02.887 --> 00:19:09.219
在这看到的所有的块都是丢失的信号 是对丢失信号的模拟 

238
00:19:09.219 --> 00:19:13.084
你发现这里没有信号 就将它加入还原 

239
00:19:13.084 --> 00:19:18.182
很快 你就修复了这个图像 

240
00:19:18.182 --> 00:19:22.870
让我再展示一遍给你
你发现了信号丢失 

241
00:19:22.870 --> 00:19:27.381
然后你修复了
你可能有一个更好的移动电话 

242
00:19:27.381 --> 00:19:33.533
一个可以检测图像的信号丢失然后很快做完图像修复的移动电话 

243
00:19:33.533 --> 00:19:39.849
图像仍然是JPEG格式   

244
00:19:39.849 --> 00:19:44.310
传输给你这张图像的人不知道信号可能丢失 

245
00:19:44.310 --> 00:19:47.126
在接受终端 你发现了信号丢失 

246
00:19:47.126 --> 00:19:52.222
这实际上能够帮助压缩
你可以故意丢掉一些块 

247
00:19:52.222 --> 00:19:57.452
因为你知道如何用图像修复来还原他 

248
00:19:57.452 --> 00:20:00.670
这样就提高了压缩率 

249
00:20:00.670 --> 00:20:06.169
一些块很容易被恢复 事实上你并不需要发送或者存储它们 

250
00:20:06.169 --> 00:20:10.125
在计算开销上增加了一丁点 

251
00:20:10.125 --> 00:20:15.020
却可能使压缩率大幅升高 

252
00:20:15.020 --> 00:20:17.665
这是该视频的最后一个例子 

253
00:20:17.665 --> 00:20:22.654
但是还有一件事情我还没告诉你 我故意要让你多想想 

254
00:20:22.654 --> 00:20:25.240
我给了你们图像修复的等式 

255
00:20:25.240 --> 00:20:28.832
但是我们有三种颜色 

256
00:20:28.832 --> 00:20:34.280
我们该这么做？
我们该如何从我给你们的等式转换到多种颜色的情况？ 

257
00:20:34.280 --> 00:20:41.325
记住 等式为 

258
00:20:41.325 --> 00:20:47.410
It等于I做拉普拉斯变换之后的梯度与I的梯度的垂直向量的内积 

259
00:20:47.410 --> 00:20:54.070
所以 

260
00:20:54.070 --> 00:20:57.736
你可以在每一个通道运用该式 

261
00:20:57.736 --> 00:21:01.402
也就是说在红色、绿色、蓝色或者其它颜色空间 

262
00:21:01.402 --> 00:21:05.735
或者你可以想办法把它扩展到彩色图像 扩展到向量 

263
00:21:05.735 --> 00:21:11.201
我们知道彩色向量梯度的概念   

264
00:21:11.201 --> 00:21:15.467
我们也可以定义彩色向量得拉普拉斯变换
所以 存在两种可能的办法 

265
00:21:15.467 --> 00:21:21.067
你可以单独处理每一个颜色或者你可以尝试 

266
00:21:21.067 --> 00:21:26.000
使用矢量场的定义 将每一个部分 比如拉普拉斯变换和梯度 

267
00:21:26.000 --> 00:21:30.603
改变为矢量场的形式
所有我展示给你看的例子 

268
00:21:30.603 --> 00:21:35.211
都是分开处理每个颜色的
以上是一些由偏微分方程式进行图像处理的例子 

269
00:21:35.211 --> 00:21:39.704
在下个视频中 我将向你展示 

270
00:21:39.704 --> 00:21:44.396
一些使用上星期学过的变分公式来进行的图像修复 

271
00:21:44.396 --> 00:21:47.738
一些很简单的变分公式 

272
00:21:47.738 --> 00:21:52.688
将会带给我们一个非常棒的图像修复技术 它基于颜色和边界的相同扩散算法 

273
00:21:52.688 --> 00:21:57.702
很希望能在下一节视频中见到你 

274
00:21:57.702 --> 00:21:59.052
谢谢 【未完成版本】