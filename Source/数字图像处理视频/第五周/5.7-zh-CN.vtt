WEBVTT

1
00:00:00.000 --> 00:00:03.865
【未完成版本】
大家好 欢迎回来 图像和视频分割是图像处理中的热门研究方向 

2
00:00:03.865 --> 00:00:08.958
其原因之一是 因为它与许多应用领域 

3
00:00:08.958 --> 00:00:13.559
从电影业到医学影像 都有关联 

4
00:00:13.559 --> 00:00:16.075
在最后一周课程中我们会提到这些 

5
00:00:16.075 --> 00:00:20.799
在这个领域有如此丰富的研究 还归因于 

6
00:00:20.799 --> 00:00:24.420
图像和视频分割确实是个难题 

7
00:00:24.420 --> 00:00:29.685
这次视频课程中 我们将介绍 

8
00:00:29.685 --> 00:00:32.674
交互式图像分割的概念 

9
00:00:32.674 --> 00:00:37.157
我们会让用户参与图像分割 

10
00:00:37.157 --> 00:00:42.850
所以这次课程的主题就是 交互式图像分割 

11
00:00:42.850 --> 00:00:47.980
我先给出一些例子 用这些极端的例子说明图像分割的难度 

12
00:00:47.980 --> 00:00:51.451
这是一幅很棒的图像 

13
00:00:51.451 --> 00:00:56.259
如果你没有见过这幅图 也许它看起来没什么特别的 

14
00:00:56.259 --> 00:00:59.516
画的不过是森林 

15
00:00:59.516 --> 00:01:05.410
现在如果你仔细看 请你仔细看一下 

16
00:01:05.410 --> 00:01:09.055
你会看到图像里 有一些人脸隐藏其中 

17
00:01:09.055 --> 00:01:14.484
比如 这里有一张脸 希望你看出来了 他的眼睛 鼻子 和嘴巴 

18
00:01:14.484 --> 00:01:19.032
这里 也有一张脸 

19
00:01:19.032 --> 00:01:26.020
这里是眼睛 鼻子 和嘴巴 还有另一张脸隐藏在这里 

20
00:01:26.020 --> 00:01:31.437
这是眼睛 鼻子 嘴巴 这里有一张侧脸 

21
00:01:31.437 --> 00:01:35.686
这是眼睛 鼻子 和嘴巴 有许多这样的图像 

22
00:01:35.686 --> 00:01:41.500
如果你盯着它看上一会儿 你会发现 

23
00:01:41.500 --> 00:01:47.388
越来越多的脸突然就出现在图像中 

24
00:01:47.388 --> 00:01:50.817
把这些人脸分割出来是非常有挑战性的图像分割问题 

25
00:01:50.817 --> 00:01:56.109
如果我们或多或少知道一些人脸的位置信息 分割会简单一些 

26
00:01:56.109 --> 00:02:01.624
这样一来 算法可能在这些位置中找到眼睛 

27
00:02:01.624 --> 00:02:04.270
让我们来看另一个例子 

28
00:02:04.270 --> 00:02:09.212
如果你想发现更多的人脸 可以暂停视频 再观察一会图像 

29
00:02:09.212 --> 00:02:14.080
看下一个例子吧 

30
00:02:14.080 --> 00:02:19.220
这也是一幅很有意思的画 我们可以看到一棵树 

31
00:02:19.220 --> 00:02:22.320
看到背景的房屋 还有一位女士 

32
00:02:22.320 --> 00:02:27.533
如果你凝视这幅图 特别是稍微远离一点屏幕 

33
00:02:27.533 --> 00:02:31.227
或者眯着眼睛 图像看上去有点模糊的时候 

34
00:02:31.227 --> 00:02:36.960
你可能会发现这里有一张脸 

35
00:02:36.960 --> 00:02:43.275
而女士成了脸上的鼻子 这里的一部分建筑成了眼睛 

36
00:02:43.275 --> 00:02:47.417
那么这次 我们如何设计分割算法 

37
00:02:47.417 --> 00:02:51.541
来分割这幅复杂的图像呢？ 

38
00:02:51.541 --> 00:02:56.045
尤其是 如何告知算法 我们感兴趣的是树 还是人脸 

39
00:02:56.045 --> 00:03:00.930
或者是鼻子 还是女士？ 

40
00:03:00.930 --> 00:03:03.277
哪部分是前景？ 哪部分是背景？ 

41
00:03:03.277 --> 00:03:07.972
说明哪里是前景和背景 是非常困难的 

42
00:03:07.972 --> 00:03:11.207
我们来看一下这幅著名的图像 

43
00:03:11.207 --> 00:03:15.341
我们可以看到两张侧脸 这是第一张 这里第二张 

44
00:03:15.341 --> 00:03:23.170
如果你看向白色区域 希望你也能看到一个玻璃杯 

45
00:03:23.170 --> 00:03:29.018
那么哪部分是前景 侧脸 还是玻璃瓶？ 

46
00:03:29.018 --> 00:03:35.182
电脑算法很难理解 图像中哪部分是我们所感兴趣的 

47
00:03:35.182 --> 00:03:40.714
解决方法之一 就是让用户告诉我们 

48
00:03:40.714 --> 00:03:43.499
哪里是前景 哪里是背景 

49
00:03:43.499 --> 00:03:47.120
我们让用户 

50
00:03:47.120 --> 00:03:53.059
也就是对分割感兴趣的客户 

51
00:03:53.059 --> 00:03:57.694
让用户告诉我们关于图像的一些信息 

52
00:03:57.694 --> 00:04:01.641
我们需要做的是 

53
00:04:01.641 --> 00:04:04.986
请用户简单地涂抹 进行标记 

54
00:04:04.986 --> 00:04:07.428
用户只需要大致涂抹 

55
00:04:07.428 --> 00:04:12.013
这里是用直线 但是也可以用任意的标记 之后我们会见到 

56
00:04:12.013 --> 00:04:15.110
然后指定这是背景 

57
00:04:15.110 --> 00:04:18.614
而另一个人说 这是前景 

58
00:04:18.614 --> 00:04:22.526
现在进行分割 以上是现阶段我们需要从用户处得知的 

59
00:04:22.526 --> 00:04:25.780
稍后我们还需要询问更多信息 

60
00:04:25.780 --> 00:04:31.109
当然 一旦我们分割出前景和背景 还可以干点别的事 

61
00:04:31.109 --> 00:04:35.319
比如说在背景放入新的图像 从用户那儿得到帮助是很重要的 

62
00:04:35.319 --> 00:04:39.866
但是我们不能询问太多信息 

63
00:04:39.866 --> 00:04:45.307
我们不能让用户完整地标记出物体的边界 

64
00:04:45.307 --> 00:04:49.303
那样就没什么活儿给电脑干了 

65
00:04:49.303 --> 00:04:54.676
那会是很乏味的 有时候用户仍然愿意帮忙 

66
00:04:54.676 --> 00:04:59.635
但是那太繁琐乏味了 我们只需要少量的但是帮助巨大的交互 

67
00:04:59.635 --> 00:05:02.686
我们如何利用这些涂抹呢？ 

68
00:05:02.686 --> 00:05:06.322
我接下来会说明这个 我会告诉大家一个特定的流程来利用这些信息 

69
00:05:06.322 --> 00:05:10.315
这其中的基本思想 

70
00:05:10.315 --> 00:05:14.845
和文献中的许多图像分割技术都是相通的 

71
00:05:14.845 --> 00:05:20.185
用户提示我们哪部分是前景 

72
00:05:20.185 --> 00:05:24.820
也就是这里 还告诉我们哪部分是背景 

73
00:05:24.820 --> 00:05:29.903
我们考虑用户标记为前景的所有像素 

74
00:05:29.903 --> 00:05:32.411
画出其直方图 

75
00:05:32.411 --> 00:05:35.460
画出这些像素的分布 

76
00:05:35.460 --> 00:05:40.272
对背景部分也是这样处理 所以我们画出前景的分布 

77
00:05:40.272 --> 00:05:45.219
还有背景的分布 

78
00:05:45.219 --> 00:05:50.099
通常 背景的像素值分布比前景的变化性更大 

79
00:05:50.099 --> 00:05:54.731
现在 如果你告诉我一个像素值 我可以从用户标记的分布中 

80
00:05:54.731 --> 00:05:58.795
算出它属于前景的概率有多大 

81
00:05:58.795 --> 00:06:01.193
而它属于背景的概率又是多少 

82
00:06:01.193 --> 00:06:04.990
再重复一下 我们利用的是 

83
00:06:04.990 --> 00:06:07.655
用户标记为前景的像素 

84
00:06:07.655 --> 00:06:10.720
和用户标记为背景的像素 

85
00:06:10.720 --> 00:06:16.880
我们可以进行归一化 这里用c表示彩色空间中的向量 

86
00:06:16.880 --> 00:06:20.593
它可以是RGB向量 即红 绿 蓝 

87
00:06:20.593 --> 00:06:24.476
也可以是其他彩色空间向量 这不重要 

88
00:06:24.476 --> 00:06:31.143
它就是用户进行涂抹时 标记的颜色 

89
00:06:31.143 --> 00:06:37.179
然后 我们得到这些分布 可以预测一个像素 

90
00:06:37.179 --> 00:06:42.555
属于前景或者背景的概率 也就是属于前景的概率 

91
00:06:42.555 --> 00:06:46.870
然后我们除以前景或背景的概率之和 进行归一化 

92
00:06:46.870 --> 00:06:52.076
比如说 一个被用户标记为前景的像素 

93
00:06:52.076 --> 00:06:56.109
该像素值会对应一个非常大的概率值 

94
00:06:56.109 --> 00:07:00.728
再次说明 这是个具体的例子 

95
00:07:00.728 --> 00:07:06.081
基本的思路是 我们利用前景和背景的分布 

96
00:07:06.081 --> 00:07:09.894
告诉电脑 

97
00:07:09.894 --> 00:07:15.393
与用户标记为前景的颜色相似的像素 

98
00:07:15.393 --> 00:07:19.060
我们应该称它们为前景 

99
00:07:19.060 --> 00:07:24.181
而与用户标记为背景的颜色相似的像素 

100
00:07:24.181 --> 00:07:29.934
应该称之为背景 现在我们知道什么是前景 

101
00:07:29.934 --> 00:07:33.489
什么是背景 

102
00:07:33.489 --> 00:07:36.529
如果我们利用这个公式 

103
00:07:36.529 --> 00:07:39.238
画出一幅图像 我们会得到这个图像 

104
00:07:39.238 --> 00:07:42.642
这已经是很有意思的分割了 

105
00:07:42.642 --> 00:07:46.532
单是看这个操作 这一幅图 

106
00:07:46.532 --> 00:07:49.450
我们差不多可以找到感兴趣的物体 

107
00:07:49.450 --> 00:07:54.660
这里用户告诉我们 他所感兴趣的物体 就是这只猫 

108
00:07:54.660 --> 00:07:57.620
这里还应注意到一些有趣的事 

109
00:07:57.620 --> 00:08:03.847
基于用户给我们的信息 这里的像素值越高 就越有可能是前景 

110
00:08:03.847 --> 00:08:08.734
那这双暗色的眼睛如何标记呢 

111
00:08:08.734 --> 00:08:14.961
暗色意味着它很可能是背景 

112
00:08:14.961 --> 00:08:21.425
而属于前景的概率很小 因为它们颜色很暗 

113
00:08:21.425 --> 00:08:27.888
而且这里也有很暗的像素 所以如果我们只考虑用户标记的像素 

114
00:08:27.888 --> 00:08:32.094
这点信息对于我们是不够用的 

115
00:08:32.094 --> 00:08:38.541
因为一些看起来是背景的像素 可能在我们感兴趣的物体内部 

116
00:08:38.541 --> 00:08:41.646
所以我们还要进一步处理 

117
00:08:41.646 --> 00:08:45.400
我们要怎样做呢？ 接下来就会看到 

118
00:08:45.400 --> 00:08:50.420
我们需要做的是 试着找出图像中的所有像素 

119
00:08:50.420 --> 00:08:56.132
将它们作为前景的概率和作为背景的概率相比较 

120
00:08:56.132 --> 00:09:01.565
然后再做决定 

121
00:09:01.565 --> 00:09:06.860
我们如何比较？ 这要用到测地线 (geodesic) 

122
00:09:06.860 --> 00:09:10.564
这也是我们每天都会用到的 

123
00:09:10.564 --> 00:09:14.492
当我们去上班的时候 在家里从房间走到厨房的时候 

124
00:09:14.492 --> 00:09:19.678
我们都需要经过一段路程 

125
00:09:19.678 --> 00:09:24.939
而且我们总是会走最短的路线 

126
00:09:24.939 --> 00:09:30.497
所以 如果想要从房间走到厨房 

127
00:09:30.497 --> 00:09:35.610
想要尽可能快到达 我们就会走最短的路线 

128
00:09:35.610 --> 00:09:39.392
有时候这个路线中会有障碍物 

129
00:09:39.392 --> 00:09:43.848
比如说一道墙 我们不能穿墙而过 

130
00:09:43.848 --> 00:09:49.732
我们要绕过墙 如果画一幅办公室或家里的地图 

131
00:09:49.732 --> 00:09:54.611
有些区域是很容易通过的 

132
00:09:54.611 --> 00:09:58.170
而一些区域会比较难通过 

133
00:09:58.170 --> 00:10:03.753
【未完成版本】
所以 当我们想要从一点到达另一个点 可能没办法走直线 

134
00:10:03.753 --> 00:10:07.381
举例来说 如果前方有一道墙 你就必须绕开它 

135
00:10:07.381 --> 00:10:12.755
所以基本原理是这样的 每条路径上的不同区域都会有自己的权值 

136
00:10:12.755 --> 00:10:17.486
用W表示 

137
00:10:17.486 --> 00:10:20.273
我们接下来要做的是 

138
00:10:20.273 --> 00:10:25.090
遍历图像中的所有像素 计算到达前景涂抹 

139
00:10:25.090 --> 00:10:31.030
和到达背景涂抹的最短路径 

140
00:10:31.030 --> 00:10:36.754
一旦得到了这两条最短路径 我们就可以比较路径的长短来判断给定像素是前景还是背景 

141
00:10:36.754 --> 00:10:41.414
所以我必须告诉你 到底什么是W 

142
00:10:41.414 --> 00:10:45.772
在那之前 我先做一个标注 

143
00:10:45.772 --> 00:10:50.380
计算路径的效率非常高 实际上 时间复杂度是线性的 

144
00:10:50.380 --> 00:10:56.130
只要把每个像素遍历一遍 

145
00:10:56.130 --> 00:10:57.420
就可以计算出最短加权路径 

146
00:10:57.420 --> 00:11:01.939
就是利用这个距离公式 

147
00:11:01.939 --> 00:11:04.951
所以这不是非常困难的计算 

148
00:11:04.951 --> 00:11:10.761
该算法基于新近发展的Dijkstra算法 (Dijkstra technique) 

149
00:11:10.761 --> 00:11:14.920
那也是图论中的标准技术 

150
00:11:14.920 --> 00:11:20.658
下周讲到偏微分方程时 我们会继续深入讨论 

151
00:11:20.658 --> 00:11:24.890
现在 大家只需要知道 

152
00:11:24.890 --> 00:11:31.002
这个式子可以计算出某一点像素到任一涂抹区域的最短加权路径 

153
00:11:31.002 --> 00:11:37.940
接下来我会介绍这个权值的定义 

154
00:11:37.940 --> 00:11:41.492
计算最短路径是非常快速的 

155
00:11:41.492 --> 00:11:46.778
 基本能够实时完成  

156
00:11:46.778 --> 00:11:50.217
那什么是W呢？ 它根据用户涂抹区域的 

157
00:11:50.217 --> 00:11:55.571
颜色分布计算而来 

158
00:11:55.571 --> 00:12:00.820
因此我们将使用刚刚算出的概率来定义W 

159
00:12:00.820 --> 00:12:04.718
而我们要思考的是以下问题 

160
00:12:04.718 --> 00:12:11.389
如果 从当前像素到涂抹区域的路径上   

161
00:12:11.389 --> 00:12:18.060
前景的概率没有多大变化 这就意味着这个像素很可能是前景像素 

162
00:12:18.060 --> 00:12:22.173
如果我继续遍历到达前景涂抹区域的路径 

163
00:12:22.173 --> 00:12:27.770
而路径上的前景概率不变 那就意味着梯度不变 

164
00:12:27.770 --> 00:12:32.370
还记得梯度表示的是连续像素之间的区别么？ 

165
00:12:32.370 --> 00:12:36.993
在路径方向上 

166
00:12:36.993 --> 00:12:40.815
这表示路径曲线 我将遍历这条曲线 

167
00:12:40.815 --> 00:12:44.180
从图像中每一个像素到涂抹区域 

168
00:12:44.180 --> 00:12:48.545
我们找到一条路径 

169
00:12:48.545 --> 00:12:53.913
判断该路径上 前景的概率改变是否很大？ 

170
00:12:53.913 --> 00:12:56.919
如果改变了很多 那么我将付出很大的代价通过该路径 

171
00:12:56.919 --> 00:13:00.426
反之 我只会付出很小的代价 

172
00:13:00.426 --> 00:13:03.790
然后我也可以选另一条路径 

173
00:13:03.790 --> 00:13:10.517
根据相应权重 判断哪一条路径更短 

174
00:13:10.517 --> 00:13:16.980
并且对涂抹区域中的另外一点 我们也做同样的计算 

175
00:13:16.980 --> 00:13:24.062
实际上我们会对涂抹区域中所有的点 

176
00:13:24.062 --> 00:13:28.399
根据前景概率计算 哪一条路径最短 

177
00:13:28.399 --> 00:13:35.304
然后 对背景区域的涂抹 

178
00:13:35.304 --> 00:13:37.240
我们也做同样的计算 

179
00:13:37.240 --> 00:13:43.465
所以对于这个像素 我要知道它到背景区域的路径上的 

180
00:13:43.465 --> 00:13:47.440
概率和代价 接着我就会比较得出它是前景还是背景 

181
00:13:47.440 --> 00:13:53.478
所以当我们在图片中做这些计算 再次说明计算的效率非常高 

182
00:13:53.478 --> 00:13:56.578
我们知道了涂抹区域 

183
00:13:56.578 --> 00:14:00.950
这幅图像表示的是我们之前计算过的概率 

184
00:14:00.950 --> 00:14:06.383
而这幅图像中 蓝色表示属于前景的概率小 

185
00:14:06.383 --> 00:14:09.266
红色表示概率大 这里也一样 

186
00:14:09.266 --> 00:14:14.220
蓝色到红色的变化 表示概率由小变大 

187
00:14:14.220 --> 00:14:18.232
也就是说 这儿的每一个像素 

188
00:14:18.232 --> 00:14:24.652
到前景区域的距离很大 但是这儿的像素 

189
00:14:24.652 --> 00:14:29.226
到前景的距离很短 这幅图则相反 

190
00:14:29.226 --> 00:14:35.566
我想回顾一下 我们首先依据用户标记区域的颜色分布 

191
00:14:35.566 --> 00:14:40.060
计算出概率 

192
00:14:40.060 --> 00:14:46.706
接下来…我用一张图片来说明 

193
00:14:46.706 --> 00:14:52.180
我们从图像上的每一点开始 

194
00:14:52.180 --> 00:14:58.257
找出它到涂抹区域的曲线 

195
00:14:58.257 --> 00:15:02.816
然后让我们看看通过这条曲线 花费的代价 

196
00:15:02.816 --> 00:15:09.400
代价是由这个函数计算的 

197
00:15:09.400 --> 00:15:15.620
前景概率变化越小 代价越小 对于图中每一个像素到背景涂抹也做同样计算 

198
00:15:15.620 --> 00:15:19.736
接着我们判断 到达前景涂抹的代价 

199
00:15:19.736 --> 00:15:25.561
比到背景所需的代价更小吗？   

200
00:15:25.561 --> 00:15:28.978
如果是这样 我们称它为前景像素 

201
00:15:28.978 --> 00:15:33.560
如果相反 那么它就是背景像素 

202
00:15:33.560 --> 00:15:39.773
你可以发现 找到图像中的最小代价曲线只需要经过一次计算 

203
00:15:39.773 --> 00:15:45.054
一旦完成对每个像素的计算 

204
00:15:45.054 --> 00:15:51.650
基本上你就能画出前景和背景的概率边界 

205
00:15:51.650 --> 00:15:56.490
完成一次漂亮的图像分割 

206
00:15:56.490 --> 00:16:01.470
这是相当简单的算法 现在 我们可以做得更好 

207
00:16:01.470 --> 00:16:07.329
这个算法是以用户涂抹为基础的 

208
00:16:07.329 --> 00:16:12.938
所以这儿会有前景涂抹 周围有背景涂抹 

209
00:16:12.938 --> 00:16:17.039
但现在 在第一次估计 

210
00:16:17.039 --> 00:16:21.811
前景和背景的初步边界后 

211
00:16:21.811 --> 00:16:27.084
我们可以第二阶段 探究一个完全自动化的操作 

212
00:16:27.084 --> 00:16:32.580
并且它的原理非常简单 现在回顾一下 

213
00:16:32.580 --> 00:16:40.140
这是我们的初步边界 我们将边界向物体内移动一点 

214
00:16:40.140 --> 00:16:47.896
再把边界向外移动一点 这些操作是全自动化的 

215
00:16:47.896 --> 00:16:50.973
然后我们可以将这块区域称为前景涂抹 

216
00:16:50.973 --> 00:16:57.032
不是先前用户的涂抹 而是现在自动计算得出的区域 

217
00:16:57.032 --> 00:17:02.771
我们把它称为前景涂抹 再将这个称为背景涂抹   

218
00:17:02.771 --> 00:17:06.757
然后再次使用算法 

219
00:17:06.757 --> 00:17:11.780
但是现在我可以用这个十分接近边界的涂抹 

220
00:17:12.960 --> 00:17:18.814
再次估计前景概率 

221
00:17:18.814 --> 00:17:24.589
因而能得出更精确的边界位置 

222
00:17:24.589 --> 00:17:28.545
此外 我们可以只进行局部计算 

223
00:17:28.545 --> 00:17:34.399
如果我想让边界更精确 可以只考虑这里和这里的涂抹 

224
00:17:34.399 --> 00:17:41.113
计算概率 细化这里的边界 

225
00:17:41.113 --> 00:17:47.128
接着进入另一个区域继续细化 以此类推 

226
00:17:47.128 --> 00:17:52.474
所以我可以遍历初步边界 得到前景区域和背景区域的新的估计 

227
00:17:52.474 --> 00:17:58.488
然后就能得到非常精确的图像分割 

228
00:17:58.488 --> 00:18:02.127
所以 我们运行两次算法 

229
00:18:02.127 --> 00:18:05.840
第一次 让用户帮助我们找到这个分布 

230
00:18:05.840 --> 00:18:11.752
接着 我们通过第一次得知如何计算更精确的边界 

231
00:18:11.752 --> 00:18:16.778
于是 如你所见 

232
00:18:16.778 --> 00:18:20.030
 我们得到了非常精确的边界  

233
00:18:20.030 --> 00:18:26.175
甚至精确到猫的毛发 得到非常好的分割结果 

234
00:18:26.175 --> 00:18:30.021
让我列举一些例子 

235
00:18:30.021 --> 00:18:36.915
看这里 在每一行的例子中 

236
00:18:36.915 --> 00:18:40.380
我们可以看见这些涂抹 这些都是二值化分割 

237
00:18:40.380 --> 00:18:44.760
正如我们提到过的 我可以将它放置到另外的背景上 

238
00:18:44.760 --> 00:18:50.473
这里有不同的图像 而每一行中都是不同的例子 

239
00:18:50.473 --> 00:18:56.480
当你需要设计能适用于大量不同数据的图像处理算法时   

240
00:18:56.480 --> 00:19:02.487
验证多种数据是非常重要的 我们不会只为一种类型的数据设计算法 

241
00:19:02.487 --> 00:19:08.128
而是尽可能地让算法普适化 

242
00:19:08.128 --> 00:19:14.062
除非你的算法有特殊的应用 否则验证算法能适用于多种图像非常重要 

243
00:19:14.062 --> 00:19:19.500
现在你也许想知道 该算法会遇到什么情况 

244
00:19:19.500 --> 00:19:25.870
我们要求用户很专业吗？ 

245
00:19:25.870 --> 00:19:29.527
我们要求用户完全理解算法 

246
00:19:29.527 --> 00:19:34.905
然后精确地标记这些区域 好给我们提示信息？ 

247
00:19:34.905 --> 00:19:39.638
当然 如果需要的话 那这个算法就不实用了 

248
00:19:39.638 --> 00:19:45.374
我们想让用户非常轻松地与算法交互 

249
00:19:45.374 --> 00:19:48.435
这里有一个例子 说明这种算法的强大 

250
00:19:48.435 --> 00:19:53.381
我们有相同的图像 

251
00:19:53.381 --> 00:19:59.004
和非常不同的蓝色的前景涂抹 和绿色的背景涂抹 

252
00:19:59.004 --> 00:20:02.845
我们可以看到处理结果是相同的 

253
00:20:02.845 --> 00:20:06.330
所有图像中前景和背景的边界 

254
00:20:06.330 --> 00:20:10.739
基本上完全一致 

255
00:20:10.739 --> 00:20:16.145
我们想让用户融洽地操作图像 

256
00:20:16.145 --> 00:20:19.132
而不要让算法对用户的要求过高 

257
00:20:19.132 --> 00:20:24.039
实际上 这个算法的要求非常低 

258
00:20:24.039 --> 00:20:29.531
它只是请用户标记前景和背景 

259
00:20:29.531 --> 00:20:34.441
我用不同颜色的笔在图像中做标记 

260
00:20:34.441 --> 00:20:37.960
好让标记足够清晰 

261
00:20:37.960 --> 00:20:46.250
这就是一个用户参与的 交互式图像分割的例子 

262
00:20:46.250 --> 00:20:49.570
我们还会有另外一组视频 

263
00:20:49.570 --> 00:20:55.129
在一个视频中 我们将在Adobe Photoshop中 演示这种交互式算法 

264
00:20:55.129 --> 00:20:58.450
另外一个视频中  我们将在Adobe的另一款产品中 

265
00:20:58.450 --> 00:21:04.442
进行交互式视频分割 

266
00:21:04.442 --> 00:21:09.785
稍后我会告诉你们更多的细节 

267
00:21:09.785 --> 00:21:13.756
【未完成版本】
那么下一个视频再见 谢谢