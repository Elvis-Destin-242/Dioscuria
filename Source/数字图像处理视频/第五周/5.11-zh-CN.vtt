WEBVTT

1
00:00:00.000 --> 00:00:05.799
【未完成版本】欢迎回来 在这个视频里 我们将学习Roto Brush 

2
00:00:05.799 --> 00:00:09.967
Roto Brush是After Effects (以下简称AE) 内置的视频分割算法 

3
00:00:09.967 --> 00:00:16.047
AE 是Adobe公司开发的视频处理软件 

4
00:00:16.047 --> 00:00:20.871
产品 Roto Brush 随着当时新版本的AE 

5
00:00:20.871 --> 00:00:26.661
在2010年4月发布 

6
00:00:26.661 --> 00:00:31.808
是那一版AE的亮点之一 

7
00:00:31.808 --> 00:00:38.080
所以我觉得学习Roto Brush背后的基本概念挺酷的 

8
00:00:38.080 --> 00:00:42.455
那让我们直奔主题吧 当我们进行视频分割时 

9
00:00:42.455 --> 00:00:46.766
如果被分割的对象是将要面世的产品素材 

10
00:00:46.766 --> 00:00:51.755
如广告业或电影行业中的素材 我们的分割需要具备 

11
00:00:51.755 --> 00:00:58.110
一些基本特征 比如 非常高的像素精度 

12
00:00:58.110 --> 00:01:02.660
我们需要在像素甚至次像素级别上对素材进行分割 

13
00:01:02.660 --> 00:01:07.401
可想见 高精度分割这一难题所面临的挑战 所以用户必须参与到处理过程中来 

14
00:01:07.401 --> 00:01:10.750
而且我们要确保 用户是以非常舒适的方式 

15
00:01:10.750 --> 00:01:15.491
参与到整个过程中的 

16
00:01:15.491 --> 00:01:19.978
另外 用户与计算机的交互必须实时完成 

17
00:01:19.978 --> 00:01:24.971
你不能要求用户操作完后回家 几小时之后再回来看结果   

18
00:01:24.971 --> 00:01:29.080
你需要让用户与计算机实时交互 

19
00:01:29.080 --> 00:01:35.276
这些就是这类算法所需要具备的基本特征 

20
00:01:35.276 --> 00:01:39.670
当然 Roto Brush具备这些特征 

21
00:01:39.670 --> 00:01:45.986
我们需要高质量的分割 

22
00:01:45.986 --> 00:01:51.815
并且让分割出来的视频精度能达到次像素级 

23
00:01:51.815 --> 00:01:55.676
然后 这是我们之前看过的一个视频例子 （我们想把其中的两个运动员分割出来） 

24
00:01:55.676 --> 00:01:59.683
为什么分割视频如此具有挑战性？ 有许多原因   

25
00:01:59.683 --> 00:02:04.710
其中一些我们已经了解了 其中的一些我们稍后再提及 

26
00:02:04.710 --> 00:02:08.189
这就是我们面临的一些挑战 

27
00:02:08.189 --> 00:02:13.279
先前我们在处理图像时遇到过它们 现在处理视频也一样 

28
00:02:13.279 --> 00:02:17.403
这也是这儿我仍然使用照片来描述的原因 

29
00:02:17.403 --> 00:02:21.398
什么是叠加着色分布？这是什么意思？ 

30
00:02:21.398 --> 00:02:26.013
在上一张幻灯片中提到了我想把这两位运动员分割出来 

31
00:02:26.013 --> 00:02:27.700
但注意看 

32
00:02:27.700 --> 00:02:33.293
这位运动员穿的是白色上衣 观众中也有人穿的是白色上衣 

33
00:02:33.293 --> 00:02:38.187
另一位选手穿的是蓝色上衣 这也有蓝色 那也有 

34
00:02:38.187 --> 00:02:41.613
这有蓝色 总之图里有很多重复的颜色   

35
00:02:41.613 --> 00:02:45.808
我们之前讨论过 颜色相近的前景和背景将导致 

36
00:02:45.808 --> 00:02:51.541
不再有足够的的边缘信息帮助我们准确地分割 

37
00:02:51.541 --> 00:02:55.335
这是另外一个边缘信息不足够导致无法准确分割的例子 

38
00:02:55.335 --> 00:02:59.909
在这里 几乎没有边界 

39
00:02:59.909 --> 00:03:05.680
当我们根本看不到车的轮廓的时 将车分割出来便无从谈起 

40
00:03:05.680 --> 00:03:11.045
同时也出现了新的挑战 特别是在视频领域   

41
00:03:11.045 --> 00:03:16.411
存在所谓的拓扑变化 我们来看看是怎样变化的 

42
00:03:16.411 --> 00:03:20.327
这的手臂是不触碰身体的 而在之后的几帧中 手臂触碰到了身体   

43
00:03:20.327 --> 00:03:23.880
同时生成了这个洞 

44
00:03:23.880 --> 00:03:29.309
所以 我们所关注物体的实际形状 或者说总体形状是在变化着的 

45
00:03:29.309 --> 00:03:33.219
在这 又改变了一次 换了一个新宿主 

46
00:03:33.219 --> 00:03:37.562
因而视频的动态衔接带来了许多可变性 

47
00:03:37.562 --> 00:03:41.400
这也使得视频分割这个难题 变得特别具有挑战性 

48
00:03:41.400 --> 00:03:46.653
Roto Brush有哪些特征 

49
00:03:46.653 --> 00:03:53.506
以及Roto Brush分割视频的特征中 有哪些是我们需要具备的 

50
00:03:53.506 --> 00:03:57.483
尤其是其他同类视频分割方法 

51
00:03:57.483 --> 00:04:02.221
也要具备的特征 

52
00:04:02.221 --> 00:04:05.690
精确度 我们之前已经提过 

53
00:04:05.690 --> 00:04:09.322
健壮性 健壮性除了指算法需要处理 

54
00:04:09.322 --> 00:04:14.592
变化的图像 而且指算法需要处理多种类型的数据 

55
00:04:14.592 --> 00:04:18.795
我们希望这个算法能很好地处理所有类型的数据 

56
00:04:18.795 --> 00:04:23.923
这算法可能…可能处理一些数据特别有效率 

57
00:04:23.923 --> 00:04:27.484
这意味着有时只需要很少的用户参与度 

58
00:04:27.484 --> 00:04:30.831
而在处理一些数据时却需要更多的用户参与度 

59
00:04:30.831 --> 00:04:35.960
但是我们希望这算法能适用于所有类型的数据 

60
00:04:35.960 --> 00:04:41.132
因此算法必须实用 这就涉及到用户的介入 所以我们 

61
00:04:41.132 --> 00:04:46.580
想确保用户的介入只会改善算法整体的运行   

62
00:04:46.580 --> 00:04:51.200
而不是使它变得更糟 

63
00:04:51.200 --> 00:04:56.234
举例来说 当用户说 哦 一切都不错除了这有点问题 然后这用户 

64
00:04:56.234 --> 00:05:01.509
做了一些事 我们不希望这些事把他或她满意的部分毁个彻底 

65
00:05:01.509 --> 00:05:07.612
所以整个算法流程必须是自然流畅 非常简单的 

66
00:05:07.612 --> 00:05:13.251
而且正如我们所说的 算法需要非常高的计算效率 因为你知道 

67
00:05:13.251 --> 00:05:19.122
在美国NTSC制式中 一秒大约包含30帧 类似地 

68
00:05:19.122 --> 00:05:25.071
我们知道从PAL制式到NTSC制式 影像大致从每秒24帧到每秒30帧 

69
00:05:25.071 --> 00:05:31.019
我们不希望每一帧的处理都要花几个小时 我们希望每一帧都能在 

70
00:05:31.019 --> 00:05:36.358
舒适的交互时间内处理完 所以我将要讲到的算法 

71
00:05:36.358 --> 00:05:40.059
有四个主要步骤 已经写在这里了 

72
00:05:40.059 --> 00:05:45.580
首先 我们要依次在每帧中做分割 

73
00:05:45.580 --> 00:05:49.297
然后我们将分割向后传递多帧 

74
00:05:49.297 --> 00:05:54.607
接着 我将演示第三步——局部矫正 我也将简要地 

75
00:05:54.607 --> 00:06:00.675
提到第四步——后期处理 这个概念是关于视频分割的 

76
00:06:00.675 --> 00:06:05.378
而不只限于静态图像 我们将列举非常多 

77
00:06:05.378 --> 00:06:09.020
很酷的例子 让我们从局部分类来开始 

78
00:06:09.020 --> 00:06:12.661
先让我解释下我说的局部分类 

79
00:06:12.661 --> 00:06:17.197
指的是什么 我们假定从分割这一帧 

80
00:06:17.197 --> 00:06:23.331
给定的图像开始 这个工作量是微不足道的 

81
00:06:23.331 --> 00:06:29.624
记住我们现在要做的是分割整个视频   

82
00:06:29.624 --> 00:06:35.598
所以我们当然偶尔可以让用户进行手动分割 但我们知道   

83
00:06:35.598 --> 00:06:41.812
我们不用那么做 因为我们已经学了很多种 

84
00:06:41.812 --> 00:06:46.990
处理这种静物分割的方法 所以我们从一个分割开始 

85
00:06:46.990 --> 00:06:50.724
之后我们会把这个分割传递到下一个 

86
00:06:50.724 --> 00:06:53.410
这将是我们面临的第一个挑战 

87
00:06:53.410 --> 00:06:58.200
现在我们看到的是局部分类器 

88
00:06:58.200 --> 00:07:04.125
我们要把窗口的中心正对分割的部分 

89
00:07:04.125 --> 00:07:10.302
卡在刚刚计算出来的边界周围 所有的窗口将把图像围起来 

90
00:07:10.302 --> 00:07:14.475
所以每个部分都有一个窗口 

91
00:07:14.475 --> 00:07:19.733
每个像素都有一个窗口 或者我们让一条曲线上每几个重叠的像素有一个窗口 

92
00:07:19.733 --> 00:07:25.325
正如我们在这儿展示的这样 

93
00:07:25.325 --> 00:07:30.250
这儿的每一个窗口 都告诉我们非常重要的信息 

94
00:07:30.250 --> 00:07:33.490
再重复一次 这只是局部窗口 

95
00:07:33.490 --> 00:07:39.587
也就是在这儿的窗口 我们现在已经获取了某一帧的分割信息   

96
00:07:39.587 --> 00:07:45.764
令它为第T帧 我们有了边界信息 也就能分出对象内部 

97
00:07:45.764 --> 00:07:50.833
和对象外部 因此 在窗口中我们拥有了两个 

98
00:07:50.833 --> 00:07:57.365
非常重要的特征信息 我们知道了形状先验的信息 

99
00:07:57.365 --> 00:08:03.180
也就是说 我们认为下一帧图像的形状与上一帧相似 

100
00:08:03.180 --> 00:08:08.618
记得一帧的时间是非常短的 所以一般说来 

101
00:08:08.618 --> 00:08:12.771
物体在帧与帧之间不会改变太多所以 形状先验成立 

102
00:08:12.771 --> 00:08:18.511
我们还拥有颜色模型 在这个模型中 我们可以预测在前景和背景中 

103
00:08:18.511 --> 00:08:21.910
将看到什么颜色 

104
00:08:21.910 --> 00:08:28.980
这是这些小窗格要做的事 让我们来看看如何使用吧 

105
00:08:28.980 --> 00:08:35.163
我们现在在第T帧 想把第T+1帧分割完成 

106
00:08:35.163 --> 00:08:42.074
正如我所说 这是我们手动操作的一帧   

107
00:08:42.074 --> 00:08:48.712
或者是根据算法分割好的一帧 我会在下一张幻灯片中讲到 

108
00:08:48.712 --> 00:08:55.805
这些窗格围绕着物体 现在我想把这位运动员 

109
00:08:55.805 --> 00:08:59.889
分割出来 我们首先要做的是 

110
00:08:59.889 --> 00:09:05.907
把这些窗格移动到新的一帧上 我们的移动不用做任何改变 

111
00:09:05.907 --> 00:09:13.332
并且结果不会太坏 或者可以遵循运动估计（Motion Estimation）来移动 

112
00:09:13.332 --> 00:09:17.630
回忆一下 以前讲视频压缩的时候   

113
00:09:17.630 --> 00:09:22.085
我们在当前帧选择一个块 

114
00:09:22.085 --> 00:09:25.915
再到前一帧图像中去寻找最相似的块儿 

115
00:09:25.915 --> 00:09:28.260
这就是我们正在做的事 

116
00:09:28.260 --> 00:09:33.777
比如 我们可以锁定每个区域 然后往前或往后找 

117
00:09:33.777 --> 00:09:40.161
看看哪个块与它最相近 哪个局部窗格 

118
00:09:40.161 --> 00:09:44.023
与它最接近 例如我们可以从这个 

119
00:09:44.023 --> 00:09:50.486
局部窗格开始 在另一帧中它周围的区域中寻找 然后移动到我们认为与其最接近的窗格 

120
00:09:50.486 --> 00:09:54.663
我们可以计算均方误 绝对误差 来衡量接近的程度 

121
00:09:54.663 --> 00:09:59.331
与我们先前讲到视频压缩时 

122
00:09:59.331 --> 00:10:03.453
判断误差的方法相同 

123
00:10:03.453 --> 00:10:06.618
我们让每个窗格都有了一个新的位置 

124
00:10:06.618 --> 00:10:12.138
再重复一次 如果你认为图像几乎没有移动 

125
00:10:12.138 --> 00:10:17.585
那你可以直接在同一位置上复制 所以要么我们直接复制窗格 

126
00:10:17.585 --> 00:10:22.663
要么遵循运动估计来移动窗格 

127
00:10:22.663 --> 00:10:26.960
现在我们在要分割的新一帧中也建立了窗格 

128
00:10:26.960 --> 00:10:32.659
还记得第三步吗？ 我将选择两个窗格 一个在当前一帧中 

129
00:10:32.659 --> 00:10:38.439
一个在另一帧中 这儿是我们已经完成的分割 

130
00:10:38.439 --> 00:10:44.218
这是我们要分割的部分 现在我们正在把红色的曲线转换为蓝色的 

131
00:10:44.218 --> 00:10:49.757
因为物体(或说这个区域)已经移动了 

132
00:10:49.757 --> 00:10:55.216
但是还不能采信蓝色曲线
这里还需要调整 

133
00:10:55.216 --> 00:10:59.313
我们把这张图片叫做“训练图”(training) 

134
00:10:59.313 --> 00:11:02.589
因为它是已有的东西 

135
00:11:02.589 --> 00:11:06.982
还有一张形状先验以及颜色分布 

136
00:11:06.982 --> 00:11:12.567
我们可以认为它大概就是这里的曲线 

137
00:11:12.567 --> 00:11:15.726
还有颜色分布 

138
00:11:15.726 --> 00:11:18.520
前景的 后景的 

139
00:11:18.520 --> 00:11:23.469
我为什么在这儿写上“GMM”呢？
因为它代表高斯混合模型 (Gaussian mixture models) 

140
00:11:23.469 --> 00:11:28.199
是一种模拟前景与后景分布的方法 

141
00:11:28.199 --> 00:11:32.056
再想一下直方图分布 

142
00:11:32.056 --> 00:11:35.986
这次不是用直方图来模拟 

143
00:11:35.986 --> 00:11:40.352
而是用参数函数 

144
00:11:40.352 --> 00:11:45.227
这就是我们采用Roto Brush高斯混合模型的原因 

145
00:11:45.227 --> 00:11:49.774
但这不是关键 
只要记得 你得到了前景颜色的分布 

146
00:11:49.774 --> 00:11:53.919
和后景颜色的分布 

147
00:11:53.919 --> 00:11:56.703
简单来说 想想直方图就行了 

148
00:11:56.703 --> 00:11:59.681
我们要结合这些 

149
00:11:59.681 --> 00:12:05.035
来确定蓝色曲线的准确位置 

150
00:12:05.035 --> 00:12:08.885
重新说一次 红色曲线要变换成蓝色的 

151
00:12:08.885 --> 00:12:12.022
而蓝色的可以出现在红色的附近(而不完全一样) 

152
00:12:12.022 --> 00:12:16.800
这些告诉我们蓝色曲线大概应该在哪里 

153
00:12:16.800 --> 00:12:21.981
我不会让蓝色曲线完全改变
因为不期望逐帧得到的形状 

154
00:12:21.981 --> 00:12:28.139
完全改变
我同样不期待 

155
00:12:28.139 --> 00:12:32.296
颜色 像素值会完全改变 

156
00:12:32.296 --> 00:12:38.301
这些是很好的颜色分布的先验
对这里的每个像素 

157
00:12:38.301 --> 00:12:43.030
可以指出更可能是前景还是后景 

158
00:12:43.030 --> 00:12:47.470
由此可以得到这样一副图像 而我们希望把二者结合起来 

159
00:12:47.470 --> 00:12:55.228
融合这个形状分布先验和颜色分布先验
至于如何将它们融合 

160
00:12:55.228 --> 00:13:01.061
则是后面将要解释的
关键在于从已知的东西 

161
00:13:01.061 --> 00:13:07.095
我们能得到所有区块 

162
00:13:07.095 --> 00:13:13.916
形状和颜色上的概率分布 融合二者 

163
00:13:13.916 --> 00:13:19.599
就得到了每个像素为前景或后景的概率 

164
00:13:19.599 --> 00:13:26.158
这发生在由前一帧得来的每一个区块 

165
00:13:26.158 --> 00:13:32.225
现在我们把它放回去 

166
00:13:32.225 --> 00:13:39.921
就得到了整个图像的概率分布
利用诸如Graph-Cuts算法 

167
00:13:39.921 --> 00:13:46.701
就可以得到这一帧的分割
由此又可以得到下一帧的 

168
00:13:46.701 --> 00:13:52.106
那之前 需要解释下如何融合 

169
00:13:52.106 --> 00:13:57.603
讲到融合 要记住 

170
00:13:57.603 --> 00:14:02.001
我们已知的是颜色和形状的先验分布 

171
00:14:02.001 --> 00:14:07.040
对于每一个区块 如何融合颜色和形状呢？ 

172
00:14:07.040 --> 00:14:13.500
基本想法写在这里
如果颜色分离得很好了 

173
00:14:13.500 --> 00:14:17.503
就采信颜色
否则就采信形状 

174
00:14:17.503 --> 00:14:21.780
如果二者矛盾
那就一并采信并融合它们 

175
00:14:21.780 --> 00:14:26.904
这里是前一帧得来的颜色分布 

176
00:14:26.904 --> 00:14:31.421
从前一帧得到一些信息 一个可信的分割 

177
00:14:31.421 --> 00:14:34.143
由此得到了形状分布先验 颜色分布先验 

178
00:14:34.143 --> 00:14:38.846
如果前景和后景在颜色分布上很好地分离了
就会看到诸如每种颜色的直方图 

179
00:14:38.846 --> 00:14:43.362
或者所有颜色的一个分布 

180
00:14:43.362 --> 00:14:48.126
能看到它们很好地分开来
可以有许多方法来测量这种分离程度 

181
00:14:48.126 --> 00:14:52.974
如果分割开了 那就相信颜色 相信概率 

182
00:14:52.974 --> 00:14:59.648
只有限地运用形状先验
假设原来的形状在这里 

183
00:14:59.648 --> 00:15:05.053
譬如说是这条曲线 由形状先验图可知 

184
00:15:05.053 --> 00:15:11.198
新的分割曲线所在的范围可以很大 

185
00:15:11.198 --> 00:15:17.187
可以得到这个相对很大的区域中每一个像素 

186
00:15:17.187 --> 00:15:21.309
总的来说你有两种概率 

187
00:15:21.309 --> 00:15:26.365
把它们融合 就得到了可信的映射 所有的概率 

188
00:15:26.365 --> 00:15:29.943
也就是上一页中我们看到的那个概率分布 

189
00:15:29.943 --> 00:15:36.441
以上是对颜色分布有信心的情况
假如分布出现更多的重叠 

190
00:15:36.441 --> 00:15:44.209
而无法非常采信
那要做的就是 

191
00:15:44.209 --> 00:15:48.530
把表示形状先验的这个窄带变得窄一些 

192
00:15:48.530 --> 00:15:55.119
我不希望这一区块里的边界 

193
00:15:55.119 --> 00:16:00.905
偏离我的预测太多
多少要在预测附近 

194
00:16:00.905 --> 00:16:07.415
重叠造成对颜色的不信任越严重
条带设置得就越窄 

195
00:16:07.415 --> 00:16:11.309
这是视频中的三个例子 

196
00:16:11.309 --> 00:16:13.575
是真实的例子 

197
00:16:13.575 --> 00:16:18.639
这里是运动员的背部
颜色很好地分离开了 

198
00:16:18.639 --> 00:16:22.903
这是另一个区域
分离得不是太好 

199
00:16:22.903 --> 00:16:26.435
再看这里 连图像上都 

200
00:16:26.435 --> 00:16:29.833
分辨不太出前景与后景 

201
00:16:29.833 --> 00:16:35.030
这些不同情况 

202
00:16:35.030 --> 00:16:38.809
其区别在于
给定形状先验 

203
00:16:38.809 --> 00:16:43.967
这里像这样
这儿像这样 

204
00:16:43.967 --> 00:16:48.500
而这里像这样
该让形状先验 

205
00:16:48.500 --> 00:16:51.940
给新曲线的位置施加多大的影响呢？ 

206
00:16:51.940 --> 00:16:57.270
若对颜色采信地多 就扩展形状先验决定的边界 

207
00:16:57.270 --> 00:17:02.676
就是说 随你想在哪里
颜色会帮助你的 

208
00:17:02.676 --> 00:17:07.030
对颜色采信地越少
形状边界就越窄 

209
00:17:07.030 --> 00:17:12.961
颜色分布给不出什么信息时 

210
00:17:12.961 --> 00:17:18.367
就靠缩小形状边界来救场
就是说 它不能变动地太多 

211
00:17:18.367 --> 00:17:23.581
所以这会是非常窄的条带
这些颜色边界取决于概率 

212
00:17:23.581 --> 00:17:27.919
取决于前一帧的颜色分布 

213
00:17:27.919 --> 00:17:34.507
形状先验的实际采信度 取决于颜色先验的采信度 

214
00:17:34.507 --> 00:17:38.042
把二者相加 并正规化 

215
00:17:38.042 --> 00:17:42.300
就得到了之前例子里的解答 

216
00:17:42.300 --> 00:17:45.535
例如 在这里没法采信颜色 

217
00:17:45.535 --> 00:17:51.181
它们太相近了
不过由于前一帧被良好地分割了 

218
00:17:51.181 --> 00:17:56.550
形状先验就能帮助我们接着做这一帧的分割 

219
00:17:56.550 --> 00:17:59.648
在结合多种信息 

220
00:17:59.648 --> 00:18:04.950
以得到想要的分割时
这是个很重要的理念 

221
00:18:04.950 --> 00:18:08.505
接下来演示下这有多重要 

222
00:18:08.505 --> 00:18:11.320
这是分割了的一帧 

223
00:18:11.320 --> 00:18:17.250
这匹马被分割出来了
接下来要分割下一帧 

224
00:18:17.250 --> 00:18:23.533
首先 为何是局部的？
记住 这一帧里 

225
00:18:23.533 --> 00:18:27.624
围绕马有一些区块
我们都是在局部操作 

226
00:18:27.624 --> 00:18:33.268
区块之间会共享信息
但所有操作都是局部的 

227
00:18:33.268 --> 00:18:38.259
如果没有那样做
如果把整帧当作一个区块 

228
00:18:38.259 --> 00:18:42.676
颜色就会太多变 

229
00:18:42.676 --> 00:18:47.094
分布就没有什么意义了 

230
00:18:47.094 --> 00:18:50.530
也就无法把马分割出来 

231
00:18:50.530 --> 00:18:56.592
如果在局部基于颜色分割 结果是这样的 

232
00:18:56.592 --> 00:19:04.069
得到的东西就会好太多
因为我们只关心 

233
00:19:04.069 --> 00:19:08.830
边界上每个像素点附近的情况 

234
00:19:08.830 --> 00:19:13.775
还有一些问题
我们看到这里 

235
00:19:13.775 --> 00:19:17.698
马是白的
马车也是白的 

236
00:19:17.698 --> 00:19:21.621
显然颜色就起不到太大作用了 

237
00:19:21.621 --> 00:19:25.117
问题来了 对吗？ 

238
00:19:25.117 --> 00:19:31.854
这时要靠形状先验了
做下一帧时颜色和形状都会用到 

239
00:19:31.854 --> 00:19:36.544
而这里就是形状起作用了 

240
00:19:36.544 --> 00:19:43.395
这里显示了把局部性、形状和颜色结合后
得到的东西 

241
00:19:43.395 --> 00:19:46.946
这是很好的边界先验分布 

242
00:19:46.946 --> 00:19:51.879
运用类似于Graph-Cuts的算法
马上就能得到很好的分割 

243
00:19:51.879 --> 00:19:56.526
由此还能得到下一帧的分割 

244
00:19:56.526 --> 00:20:01.817
因此 要获得准确的分割
局部性 形状和颜色 都很重要 

245
00:20:01.817 --> 00:20:06.178
我们很快将看到 

246
00:20:06.178 --> 00:20:09.753
局部分割的重要性不仅于此 

247
00:20:09.753 --> 00:20:15.759
它也有助于在图像处理上建立更友好的用户交互 

248
00:20:15.759 --> 00:20:19.490
以上就是如何从上一帧的分割得到这一帧的 

249
00:20:19.490 --> 00:20:25.204
不过我们不止想做一帧 

250
00:20:25.204 --> 00:20:30.120
而是想做多帧
要怎么做呢？ 

251
00:20:30.120 --> 00:20:36.317
基本思想是 第一帧的分割 

252
00:20:36.317 --> 00:20:41.308
到其下一帧
再从这帧 

253
00:20:41.308 --> 00:20:46.539
到下一帧
这一帧的分割 到下一帧 

254
00:20:46.539 --> 00:20:50.886
如此就可一直做下去 

255
00:20:50.886 --> 00:20:54.749
然而这种做法有个根本问题 

256
00:20:54.749 --> 00:21:00.290
问题出现在误差积累上
我们采信这一帧 

257
00:21:00.290 --> 00:21:03.860
我们很信任它
也许因为是手动分割的 

258
00:21:03.860 --> 00:21:07.430
也许因为花费的工作够多 

259
00:21:07.430 --> 00:21:13.064
而这一帧是靠我讲过的算法
从这一帧得出的 

260
00:21:13.064 --> 00:21:18.063
它也许不太完美 如果我把这传递给下一帧 

261
00:21:18.063 --> 00:21:24.173
那么在这儿产生的误差 传递给了下一个 这意味着我的 

262
00:21:24.173 --> 00:21:28.300
形状先验误差传递了  我的颜色分布 

263
00:21:28.300 --> 00:21:33.450
以及对这一帧的估计 (如果有错误)  也传递了 

264
00:21:33.450 --> 00:21:39.820
解决办法之一就是  为了稳定系统 

265
00:21:39.820 --> 00:21:44.150
为什么我们不让色彩先验亦在此产生影响呢 

266
00:21:44.150 --> 00:21:49.174
为什么我们不让他们保持前进? 这也是 这也是 

267
00:21:49.174 --> 00:21:55.331
这是我们很相信的朋友 所以让它继续向前 

268
00:21:55.331 --> 00:22:01.246
记住我们正在以块工作 所以在局部上 我们让它向前移 

269
00:22:01.246 --> 00:22:07.890
用这种方法 每一帧都会得到原始帧的一些信息 

270
00:22:07.890 --> 00:22:12.670
也从我们非常信任的原始分割中 得到信息 

271
00:22:12.670 --> 00:22:17.349
用这种方法 结果是 

272
00:22:17.349 --> 00:22:22.530
我们做的分割不仅传递了一帧 

273
00:22:22.530 --> 00:22:26.621
而且传播到后面的许多帧  所以又一次地 

274
00:22:26.621 --> 00:22:32.608
因为我们的操作是局部性的 所以我们信任的信息不必影响全局 

275
00:22:32.608 --> 00:22:35.838
只要对局部的影响是可信的就可以了 

276
00:22:35.838 --> 00:22:38.897
这种可以传递到多个帧的信息 

277
00:22:38.897 --> 00:22:42.174
有助于稳定系统 

278
00:22:42.174 --> 00:22:47.562
我们可以重复这样做 将当前分割作为初始状态 

279
00:22:47.562 --> 00:22:51.932
或者作为后面分割的先验等等 

280
00:22:51.932 --> 00:22:55.136
这种帧可以选择这样操作 

281
00:22:55.136 --> 00:22:59.360
但是关键部分是使用我们信任的信息 

282
00:22:59.360 --> 00:23:06.004
尽可能多的利用上先前的帧 在我举例之前 

283
00:23:06.004 --> 00:23:09.923
我们有几件事要做 

284
00:23:09.923 --> 00:23:14.324
一件是 我们如何让用户修复错误？ 

285
00:23:14.324 --> 00:23:17.763
不管我们写的算法多么完美 

286
00:23:17.763 --> 00:23:21.063
视频分割是一个非常非常难的问题 

287
00:23:21.063 --> 00:23:24.983
尤其当我们想分割一个两个小时的电影时 

288
00:23:24.983 --> 00:23:28.810
所以 我们要让用户帮助改善算法的效果 

289
00:23:28.810 --> 00:23:34.159
记住 当我们相信一个朋友 我们是真的相信  所以我们最好确定 

290
00:23:34.159 --> 00:23:38.100
所有的朋友一直处于良好的状态中 

291
00:23:38.100 --> 00:23:42.726
这有个例子 这里有一系列连续帧  然后我们发现 

292
00:23:42.726 --> 00:23:47.823
这很好 这很好 但是这里有一个错误 

293
00:23:47.823 --> 00:23:51.980
所以我们如何让用户修复这个错误？ 

294
00:23:51.980 --> 00:23:57.293
又一次 在局部块上的操作起了很大作用 

295
00:23:57.293 --> 00:24:02.435
所以我们想要这样操作 我们想去修复它 

296
00:24:02.435 --> 00:24:07.149
有很多帮助我们修复的包 

297
00:24:07.149 --> 00:24:10.748
我想再展示一下刚才的操作 

298
00:24:10.748 --> 00:24:15.279
这里有错误 现在修复好了 

299
00:24:15.279 --> 00:24:20.922
我们可以用很多不同的包修复它  PS  AE 

300
00:24:20.922 --> 00:24:25.713
你只需点一下就可以改变曲线  当然 要记住 

301
00:24:25.713 --> 00:24:29.179
它们是传递过的  这些分割都是传递来的 

302
00:24:29.179 --> 00:24:34.089
这个早已存在的误差 传递 传递 传递 

303
00:24:34.089 --> 00:24:38.711
现在 我希望刚才所做的这个修正  也像这样传递下去 

304
00:24:38.711 --> 00:24:44.055
既然之前的分割都是正确的 我不想它向后传播 

305
00:24:44.055 --> 00:24:46.943
我不想这里的校正 

306
00:24:46.943 --> 00:24:51.060
影响这里 因为我对这里已经很满意了 

307
00:24:51.060 --> 00:24:56.328
至此 我们学会了局部块 局部修复的所有内容 

308
00:24:56.328 --> 00:25:02.244
这很好 我们看看每一个块 或者每一个修补 

309
00:25:02.244 --> 00:25:07.200
都被最近的修复所影响 

310
00:25:07.200 --> 00:25:13.638
因为我们已经做过运动估计 我们知道 

311
00:25:13.638 --> 00:25:20.015
这些块在后续帧中的去向 也知道将来它们的位置 

312
00:25:20.015 --> 00:25:25.992
接下来我们只在块中做修复 或许我们可以扩展 

313
00:25:25.992 --> 00:25:31.968
到几个边 让修复更加连续 但是确定的是我们一定 

314
00:25:31.968 --> 00:25:38.020
不会让那个修正传递得太远 

315
00:25:38.020 --> 00:25:41.500
这就是我们局部控制的方法 

316
00:25:41.500 --> 00:25:46.786
所以这些块帮助我们得到局部特征 

317
00:25:46.786 --> 00:25:51.867
也助于我们更快地交互 所以看下修复后会发生什么 

318
00:25:51.867 --> 00:25:55.399
我们操作了 这是结果 

319
00:25:55.399 --> 00:25:59.826
我们把它们修复了 让我再演示一遍 

320
00:25:59.826 --> 00:26:04.168
我们遇到一个错误 但是我们修复了这个错误 

321
00:26:04.168 --> 00:26:11.740
我们让这个修正传递到后续帧中的相关块 

322
00:26:11.740 --> 00:26:18.976
这样我们把所有的都修复了 接下来继续 从这一帧开始 

323
00:26:18.976 --> 00:26:24.628
分割前面帧 所以 这非常酷 这是第三步 

324
00:26:24.628 --> 00:26:28.515
局部修复 

325
00:26:28.515 --> 00:26:34.049
最后的事情是 目前为止 我们已经逐帧进行了分割 

326
00:26:34.049 --> 00:26:38.227
这是一部电影  我们希望这些分割是逐帧连续且一致的 

327
00:26:38.227 --> 00:26:43.151
达到这种效果的方法之一是使之平滑化 

328
00:26:43.151 --> 00:26:46.284
我们每帧都有分割 

329
00:26:46.284 --> 00:26:52.029
我们要让这些分割的过渡是平滑的 规范化它们以使来让它们看上去更好些 

330
00:26:52.029 --> 00:26:56.133
接下来让你看看发生了什么 

331
00:26:56.133 --> 00:27:01.742
所以你看这里 这的边缘有点粗糙 

332
00:27:01.742 --> 00:27:07.804
这儿就好多了 我们将多个帧的分割一起平滑一下 

333
00:27:07.804 --> 00:27:13.700
使之从粗糙到平滑 

334
00:27:13.700 --> 00:27:20.845
这样就可以把这个物体放到其他电影里 

335
00:27:20.845 --> 00:27:25.820
或者做出其他效果 

336
00:27:25.820 --> 00:27:30.600
所以现在 是时候来展示下 这个很酷技术的例子 

337
00:27:30.600 --> 00:27:34.845
这是一个我们看过很多遍的例子 

338
00:27:34.845 --> 00:27:39.023
所以 在这我们有好几个例子 但是我现在不准备演示 

339
00:27:39.023 --> 00:27:42.926
我们已经对这个人做了分割  效果看上去非常好 

340
00:27:42.926 --> 00:27:47.240
他经过了各种处理  修复 光滑 

341
00:27:47.240 --> 00:27:49.980
所有的 看上去真的真的很好 

342
00:27:51.100 --> 00:27:56.499
这是个我们看过多次的例子 我们在背景模糊后 

343
00:27:56.499 --> 00:27:59.738
在背景模糊的实例中我们见过这个 

344
00:27:59.738 --> 00:28:04.706
这是我们以前看过的一个特效 

345
00:28:04.706 --> 00:28:09.622
在之前的一个介绍视频中出现过 我们把运动员分割   

346
00:28:09.622 --> 00:28:14.552
并把他们放到一个模糊的背景中 来增强运动员 

347
00:28:14.552 --> 00:28:20.337
将观看者的注意力吸引至运动员上 这还有其他的好例子 

348
00:28:20.337 --> 00:28:24.660
特效的例子 这是原始视频 

349
00:28:24.660 --> 00:28:29.677
这是经过滤波的 你可以看到冲浪的女士已经被筛选出了 

350
00:28:29.677 --> 00:28:34.104
所以首先我们要分割出这个 

351
00:28:34.104 --> 00:28:40.006
难点在于飞溅的水滴 以及这里的拓扑改变 

352
00:28:40.006 --> 00:28:43.105
一旦我们把它分割出来 

353
00:28:43.105 --> 00:28:47.680
我们可以对它做非常漂亮的特效  像这儿一样 我们改变了人身上的光照 

354
00:28:47.680 --> 00:28:52.491
正如你看的那样 我们不必影响背景 

355
00:28:52.491 --> 00:28:55.629
因为我们已经把前景分割了出来 

356
00:28:55.629 --> 00:28:59.255
这是我们见过的合成 

357
00:28:59.255 --> 00:29:04.020
一切从这个糟糕的原图开始 

358
00:29:04.020 --> 00:29:08.701
我想再给你们举些例子 我觉得这真的很酷 

359
00:29:08.701 --> 00:29:14.363
这又有个例子 我们把运动员从背景中分割出来 

360
00:29:14.363 --> 00:29:17.836
看这个问题多么困难 

361
00:29:17.836 --> 00:29:22.914
背景全是蓝色或白色的 或者说蓝色和灰色 跟运动员一样 

362
00:29:22.914 --> 00:29:26.929
一切都混淆在一起 但是我们有形状 这帮了我们不少 

363
00:29:26.929 --> 00:29:32.398
一旦把运动员分离出来 我们就可以修改背景 

364
00:29:32.398 --> 00:29:37.244
比如 将之模糊化  这也基于 

365
00:29:37.244 --> 00:29:42.089
刚才向你们解释过的 把前景抠出来的概念 

366
00:29:42.089 --> 00:29:46.935
对于本例 不仅要对前景色建模 

367
00:29:46.935 --> 00:29:51.020
我们也可以将背景色建模 

368
00:29:51.020 --> 00:29:55.799
我之前一直再讲 让我们给前景的颜色和形状建模 

369
00:29:55.799 --> 00:29:59.782
为什么不对背景研究下呢？ 

370
00:29:59.782 --> 00:30:04.199
这样对结果会有改善 

371
00:30:04.199 --> 00:30:09.992
但是 概念非常相似 我再举个例子 

372
00:30:09.992 --> 00:30:15.351
所以 这是一个特殊效果 我们将演员分割出来 

373
00:30:15.351 --> 00:30:19.551
在多个位置上重复 

374
00:30:19.551 --> 00:30:23.172
同样 这里的最大挑战是把他分割出来 

375
00:30:23.172 --> 00:30:29.028
这里的对比非常强烈 

376
00:30:29.028 --> 00:30:33.661
尤其在衬衫和背景之间 所以颜色对于分割是非常重要的 

377
00:30:33.661 --> 00:30:39.544
但是同样演员的形状在移动 但是不是完全地变形 

378
00:30:39.544 --> 00:30:44.602
所以形状先验很有用  所以这告诉我们 

379
00:30:44.602 --> 00:30:50.560
这个最受欢迎的视频分割技术的原理 尤其是旋转笔刷 

380
00:30:50.560 --> 00:30:54.480
旋转笔刷功能被合并进了 Adobe 的 AE 中 

381
00:30:54.480 --> 00:30:58.714
我们看到这个技术的实现有很多方法 它利用形状 

382
00:30:58.714 --> 00:31:02.869
利用颜色 利用局部结构 局部学习 

383
00:31:02.869 --> 00:31:06.397
这些都能有助于更精准地预测 

384
00:31:06.397 --> 00:31:10.552
当用户需要做修正时 

385
00:31:10.552 --> 00:31:14.080
这些方法也方便了用户操作 

386
00:31:14.080 --> 00:31:20.242
这些概念加在一起就形成了这种精度高 

387
00:31:20.242 --> 00:31:23.560
而且对用户友好的视频分割 

388
00:31:23.560 --> 00:31:26.944
非常感谢 希望你享受学习   

389
00:31:26.944 --> 00:31:28.780
下节视频见 谢谢【未完成版本】