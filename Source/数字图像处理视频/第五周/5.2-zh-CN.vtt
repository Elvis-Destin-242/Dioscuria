WEBVTT

1
00:00:00.000 --> 00:00:04.656
大家好 欢迎回来 我们来考虑一下什么样的图像和信息 

2
00:00:04.656 --> 00:00:10.420
可以用来做图像和视频分割吧 下面就专门来讨论 

3
00:00:10.420 --> 00:00:15.298
边缘和区域 让我们来看这一幅美丽的花朵图像 

4
00:00:15.298 --> 00:00:18.846
假设我们需要把这朵花分割出来 

5
00:00:18.846 --> 00:00:23.576
我们希望把这朵花跟背景分离 

6
00:00:23.576 --> 00:00:27.050
有某些区域 比如这里 

7
00:00:27.050 --> 00:00:33.827
有着十分明显的边界 我们有这些边缘和梯度 

8
00:00:33.827 --> 00:00:39.502
回忆一下 我们把梯度表示成这种形式 

9
00:00:39.502 --> 00:00:44.069
其实就是图像中 导数的向量 

10
00:00:44.069 --> 00:00:49.990
图像在 x 方向上的导数 

11
00:00:49.990 --> 00:00:54.300
和图像在 y 方向上的导数 

12
00:00:54.300 --> 00:01:02.757
我们在几周以前已经讲过如何来实现它 

13
00:01:02.757 --> 00:01:08.683
例如 要求在 x 方向上的导数 可以用一个简单的 -1 +1 -1 滤波器来计算 

14
00:01:08.683 --> 00:01:12.333
现在 如果我们有了这两个导数 

15
00:01:12.333 --> 00:01:18.885
并且计算对应的向量的长度 因为在这个区域中 

16
00:01:18.885 --> 00:01:22.452
花的两边有着非常明显的差异 

17
00:01:22.452 --> 00:01:28.590
很明显 这将会帮助我们把花从背景中分离出来 

18
00:01:28.590 --> 00:01:34.811
我们将会频繁地见到 梯度作为图像分割算法的一部分而出现 

19
00:01:34.811 --> 00:01:39.290
另一方面 我们看这个区域 

20
00:01:39.290 --> 00:01:45.508
我们可能也会得到一些梯度值 但是我们不希望把这些梯度作为分割的依据 

21
00:01:45.508 --> 00:01:49.628
这些差异是在花朵内部的 

22
00:01:49.628 --> 00:01:54.996
所以我们不希望它们出现在算法中 显然我们希望使用这些边界 

23
00:01:54.996 --> 00:02:00.323
使用这些边缘 或者梯度值 而不是物体内部的值 

24
00:02:00.323 --> 00:02:06.432
这使得我们的任务变得复杂起来 但是也说明 

25
00:02:06.432 --> 00:02:10.662
我们并不是要寻找花朵内部像素值一致的区域 

26
00:02:10.662 --> 00:02:16.928
如果在算法中加入了这个约束 分割结果就不会与预期相差太远 

27
00:02:16.928 --> 00:02:20.845
因为在花的内部 其实有许多颜色变化 

28
00:02:20.845 --> 00:02:26.362
我们实际上是要寻找花跟背景之间的显著的差异 

29
00:02:26.362 --> 00:02:29.928
因此 边缘在分割这朵花的过程中相当重要 

30
00:02:29.928 --> 00:02:34.950
我们将会在以后的视频中学习到这一点 

31
00:02:34.950 --> 00:02:38.032
现在让我们看另一幅图像 

32
00:02:38.032 --> 00:02:42.670
请看这幅图像 

33
00:02:42.670 --> 00:02:50.250
我们可以清楚地看到这里是一个球 让我把画笔调出来 

34
00:02:50.250 --> 00:02:57.729
虽然在这个地方没有边缘 我们还是可以看到这个球 不过看不到任何边缘 

35
00:02:57.729 --> 00:03:05.514
但是能理解这个形状 在这里我们没法利用边缘信息 

36
00:03:05.514 --> 00:03:13.402
如果我们计算梯度的话 会发现这里根本没有边缘 

37
00:03:13.402 --> 00:03:21.299
对这里的任何一个像素 尝试求梯度的话 

38
00:03:21.299 --> 00:03:28.635
梯度将会是0 或者是非常小的值 这并不能帮助我们寻找边界或目标物体 

39
00:03:28.635 --> 00:03:33.129
换一种方法 我们可以利用形状 

40
00:03:33.129 --> 00:03:35.178
可以利用区域信息 

41
00:03:35.178 --> 00:03:41.556
所以我们得明白这是一个一致的区域 这里也是 

42
00:03:41.556 --> 00:03:45.861
实际上 我们将会利用这一点 

43
00:03:45.861 --> 00:03:49.210
来帮助我们进行分割 

44
00:03:49.210 --> 00:03:56.454
让我们来看这张图像的边缘 以此进一步说明 在这种情况下 

45
00:03:56.454 --> 00:04:01.080
边缘是没有多大帮助的 这里我们提取出刚才这幅彩色图像的绿色通道 

46
00:04:01.080 --> 00:04:07.277
使用MATLAB进行处理 

47
00:04:07.277 --> 00:04:11.380
计算出边缘后 可以看到一些假的边缘 

48
00:04:11.380 --> 00:04:16.852
这些不会有太大的影响 我们前面已经学过如何消除它们 

49
00:04:16.852 --> 00:04:20.196
比如 通过前置滤波 

50
00:04:20.196 --> 00:04:24.909
提前将这些噪声去掉 在这些地方我们得到了清晰的边缘 但是这里却没有 

51
00:04:24.909 --> 00:04:30.761
这是一个微小的边缘 因为这里可能有一个非常模糊的边界 

52
00:04:30.761 --> 00:04:34.680
但是这些地方没有边缘 所以我们需要其他形式的信息 

53
00:04:34.680 --> 00:04:40.852
以便我们将这个球从背景里分离出来 

54
00:04:40.852 --> 00:04:44.720
看起来很简单 但是我们没有足够的边缘信息 

55
00:04:44.720 --> 00:04:49.644
在下一个视频里我会讲解 如何合并多种信息 

56
00:04:49.644 --> 00:04:53.771
首先 我们在下一个视频里会演示 

57
00:04:53.771 --> 00:04:59.228
霍夫变换 (Hough transform) 它将会帮助我们整合已知的形状 

58
00:04:59.228 --> 00:05:04.153
如果我们需要寻找一条直线 那么可以将其放入分割或检测算法中 

59
00:05:04.153 --> 00:05:08.080
如果我们需要寻找圆形 比如这个例子 

60
00:05:08.080 --> 00:05:12.871
我们可以把它整合到算法中去 然后使用霍夫变换来完成分割 

61
00:05:12.871 --> 00:05:16.199
我将会在下一次视频里继续讲解 希望能再次见到大家 

62
00:05:16.199 --> 00:05:16.865
谢谢è°¢è°¢ã