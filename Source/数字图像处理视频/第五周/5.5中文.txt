【未完成版本】
大家好 欢迎回来
我们刚刚用几个视频的时间讨论了 边缘 和用边缘检测的方法来获取图像分割的重要性 在这个视频中 我们将学习到大津算法 (Otsu's method) 它关注图像的直方图分布 利用图像的像素值和它们的特性 以此来分割图像 我们需要用到统一的像素值 这个算法不关注图像的边缘 而是关注我们想要从图像中分割出来的区域 这些区域有我们想要分割出来的对象
一起来看看大津算法背后的思路 它们促使了这个算法的产生 然后 我们再来 解释算法的工作原理
我们来看看这个指纹的图像 画出它的直方图分布 这种直方图叫做双峰直方图 这里有很多的像素点 它表示了图像中的指纹 这里也有很多像素点 它表示了图像中的背景 非常清楚 直方图中有两种模式 所以 这是一种多模式的直方图
基本思路是这样的 如果在这设一个阈值 那么就能得到一种简单的分割 通过一个简单的阈值 分割了指纹痕迹和背景 这些都是因为直方图的双峰分布
大津算法将帮助我们 自动找到这个阈值 当然 不是所有图都有这么好的直方图分布 我们来看看一个简单的例子
这里有一幅二值图像 我们有一个双峰分布 但仅仅是两个delta函数 如果我们给图像加点噪声 这个噪声是高斯噪声 我们仍能得到双峰分布 而且大津算法也会无差错地将它分割开来 它会找到那个阈值 现在 如果我们加入更多的噪声 噪声的方差从这里到这里 变大了5倍 这样 直方图的分布更加分散了 我们看不到其中的多峰分布 大津算法也无法找到一个合适的阈值 虽然我还没有向大家介绍这个算法 但是如果我们对这个图像应用大津算法 由于这种分布 得到的结果是这样的 我们无法将图像分割开 但是 现在已经是第5周的课了 我们根本不用担心噪声的问题 我们可以对噪声图像进行去噪 如果完成这个去噪过程 或许能像这种情况一样 重新得到这个双峰分布 然后 大津算法得到的阈值就能将图像分割开来 因此 我们将看到这是一个非常强大的技术 这个简单的图像展示了大津算法的思路 那么算法是怎么工作的？ 算法将尝试寻找一个阈值 使图像的类内方差非常小 我们希望在这找到一个阈值 这样使 每组的类内方差尽可能地小 尽可能地紧凑 算法将从直方图着手 直方图中没有空间关系
所以算法不会考虑空间关系 图像中有这样的区域 像素值相似 但位置完全不同 在直方图中会合并到一起 而且 大津算法会把它作为整体 不去区分 之后我们会学到一些算法 这些算法 考虑了像素间的空间关系 而大津算法没有考虑 算法的基本思路很简单 我们需要最小化这个加权类内方差 假设像素分为两类 我们需要 最小化加权类内方差 这里定义了类内方差 t是阈值 我们就是要找到这个阈值 对于常规的图像而言 这个阈值是0到255中的某个值 我们想要最小化这个值
我来定义一下 式子中的每个变量 它们很简单 这是每个类的概率总和 P是从直方图中得到的
从直方图开始 我们要计算每个像素值的概率 所以 我们对直方图进行计算 并对它归一化 得到了概率P 这些在前几个星期有学到过
然后从1开始到t求和 t是我们设置的阈值
再从t+1到最大的像素值 也就是255 在这之间求和
这样就得到了类1的概率 类2的概率 然后 可以简单地计算出类1类2的均值 由此得到类1类2的方差 这样子 我们就能够计算出加权类内方差 这个是计算的式子 我们需要最小化这个方差
再提一下 这个计算方法 会给出直方分布紧凑的类
如果我们设置了一个不合适的阈值 其中一个类的方差将会变得很大 我们不想要这种结果 因此 我们要优化的就是这个 大津算法就是这样做的 那么 如何实现这个？
有个非常繁琐的方法 你不停地尝试阈值t
让t=0 然后计算这些 很简单 然后计算出这个值 再让t分别等于1到255 各自计算一遍 然后得出最小的一个 记录下那个阈值 这样就结束了
这个计算过程非常快 效率很高 非常快 如果做一些代数运算 你会发现一个很简单的代数式子 只要在之前的公式中加入一个式子 你可以得到 这个图像的总方差 它是 类内方差和类间方差的和 这个值是一个常数 它不取决于阈值 图像就是一个图像 它的方差是不会变的 我们想要最小化这个 而这个是个常数 这样就相当于 最大化这个 而这里的概率和均值 在我们改变阈值时 可以非常简单地递推得到 方法就是在改变阈值时 不停地对概率和均值加个值
这样的递推计算方法效率非常高 比如说 t从10到11 12 13
我们不停地递推计算这个式子 这个计算过程非常快
我们令t等于0到255 这样计算一遍 不同之处在于 计算这个类内方差 不能用到递推的方式 但是这个可以用递推的方式实现 t+1的状态取决于t 这可以通过简单的公式计算得到 仅仅是均值和概率 非常简单 你只要不停地加就能得到结果 这些都很简单 不管你是 直接计算类内方差 还是递推计算类间方差 你尝试 所有可能的阈值t
然后选择一个值 使类内方差最小 要不最大化类间方差 这样你就完成了 【未完成版本】
那么 在我向大家展示MATLAB中的例子之前 我想让你知道一些东西
如果一个图像的背景像这幅图像一样 是非均匀的 那么 大津算法将无法使用 你可能有一个二元分布 就像我在这画的一样 但是由于背景的影响 这不会是一个基本的双峰分布 我之前介绍的是 对整个图像应用大津算法 你也可以将图像分块 分别应用大津算法 这样就能摆脱非均匀背景的影响 然后在每块区域里计算出各自的阈值 当然 如果你愿意 你也可以 用移动窗口的方法来选择区域
你可以在这用一个窗口 我来画一下这个窗口 在这个窗口里计算阈值 然后在另一个窗口中计算阈值 接着又在其他的窗口中 计算一遍 这样的话 你可以对窗口间重叠的部分求平均来获得阈值 或者通过一个函数关系式来计算阈值 再提一下 我所讲的这些方法 它们背后的思路 都是将图像分块 然后最小化之前讲到的类内方差 这种思路你可以 用各种方法 应用到整个图像的各个分块上 还有重叠的分块和没有重叠的分块 这有很多技巧 而这些方法取决于不同的场合 比如 你对这里的图像做分割处理 如果对整个图像计算阈值
我先擦掉这些记号 这样图像更清晰 如果对整个图像应用大津算法 你得到的结果是这样的
这边很暗 这样就无法用分布图和优化方法 分辨出字母 这样一来 算法找到的阈值 会使背景和字母混在一起 我们就看不到这些字母了 但如果使用移动窗口的方法 你可以得到这个很好的结果
再提一下 这个方法非常简单 我们所要做的 就是移动一个窗口 计算窗口区域中的阈值 并以此来分割出字母 我们移动窗口 并用前面所将的式子计算出每个阈值 现在 我们来看看 MATLAB中这方面的例子
为了在MATLAB中演示大津算法 我们首先要做的 就是载入一幅图像 这里载入了一幅图像 用的是这条命令
I = imread('coins.png'); 下一条命令计算了最佳的阈值
level = graythresh(I); 用的是刚才讲到的大津算法 在MATLAB中用这条命令表示 它计算出level值 也就是最佳阈值 然后 我们用这个阈值对图像进行分割
BW = im2bw(I, level); 那么 一起来看看所有这些操作的结果 这里是所有的图像 我移动一下这些窗口 这样可以看得更仔细 这是原始图像 这是它的直方图 现在你已经很了解大津算法了 所以 当看到这个直方图时 你会想到这个很简单 如果计算出的最佳阈值 在这附近 你可以得到很好的结果 这是图像分割后的结果 它用到了那个最佳阈值 结果看起来很不错 请记住 这里没有用到空间信息 比如说 你在这看到的几个像素点 它们可能被划分为 背景的一部分 当然 如果对图像做平滑处理 那么就可以解决这个问题 而且能在这得到一个全白的区域
这里的情况有点不同 因为我们可以看到 这个硬币有一部分相对较暗 基本上和背景差不多暗 或者一样暗 这就是为什么 这里的像素点被划分成了背景的一部分 但是 如果在局部区域中应用大津算法 或者采用其他形式的大津算法 结果可能就会不一样
但这个思路对大多数图像而言 是很明确的 通过设定一个简单阈值 我们可以将图像分割得很好 而这个阈值不用我们手动设定 大津算法会自动计算出这个阈值 接下来 我们可以回到之前的幻灯片 结束这个视频 谢谢大家 在这个视频里 我们了解了另一种经典的 简单而非常强大的图像分割算法
可惜 并不是所有的图像都是这么简单 它们无法用大津算法或是霍夫变换来进行分割 我们会用到更加先进的技术来解决这些问题 这些内容是这周接下来几个视频的主题 我期待在接下来的视频中 和大家一起快乐地度过 谢谢大家
【未完成版本】