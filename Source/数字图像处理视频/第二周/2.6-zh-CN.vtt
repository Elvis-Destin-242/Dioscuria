WEBVTT

1
00:00:00.000 --> 00:00:04.729
我们讲过 JPEG (静止图像压缩标准) 是最重要的图像压缩算法 

2
00:00:04.729 --> 00:00:09.526
大概也是最重要的图像处理算法 

3
00:00:09.526 --> 00:00:14.656
总体上说 还有其他一些非常重要的图像和视频压缩技术 

4
00:00:14.656 --> 00:00:17.853
而我想阐述的是 

5
00:00:17.853 --> 00:00:20.718
在这两者背后隐含的基本概念 

6
00:00:20.718 --> 00:00:25.914
其中一个是JPEG-LS (无损图像压缩标准)
另外一个是MPEG (动态图像压缩标准) 

7
00:00:25.914 --> 00:00:31.470
JPEG-LS允许我们进行无损压缩
也就是说不会有任何信息损失 

8
00:00:31.470 --> 00:00:36.901
图像中的每一个像素值都会被保留
而MPEG则是我们用来压缩视频的标准 

9
00:00:36.901 --> 00:00:40.869
大家的手机中大概都有MPEG 

10
00:00:40.869 --> 00:00:44.768
并且大家在网络上都看过用MPEG压缩的视频 

11
00:00:44.768 --> 00:00:49.712
那么下面就来讲解   

12
00:00:49.712 --> 00:00:54.746
这两个非常重要的图像和视频压缩技术 

13
00:00:54.746 --> 00:00:59.286
背后的概念
我们先从JPEG-LS的概念开始讲起 

14
00:00:59.286 --> 00:01:03.080
在这一标准背后的思想叫做 

15
00:01:03.080 --> 00:01:09.495
无损预测压缩
为了对比 我在这里放了 

16
00:01:09.495 --> 00:01:14.580
我们已经多次见过的 JPEG-LS基本流程图 

17
00:01:14.580 --> 00:01:18.486
而这边的则是预测编码的基本流程图 

18
00:01:18.486 --> 00:01:22.908
预测编码的基本思想非常非常简单 

19
00:01:22.908 --> 00:01:28.730
甚至比JPEG的都要简单
让我来举个例子说明一下 

20
00:01:28.730 --> 00:01:33.103
把我画的当做一幅图像的一小部分 

21
00:01:33.103 --> 00:01:35.618
在预测编码中 

22
00:01:35.618 --> 00:01:37.983
我们首先需要确立顺序 

23
00:01:37.983 --> 00:01:40.752
我们将对像素逐个进行压缩 

24
00:01:40.752 --> 00:01:45.135
假设我们采用一种叫做光栅扫描顺序的方法 

25
00:01:45.135 --> 00:01:50.000
按照从左至右的顺序 先对第一行编码 然后是第二行 

26
00:01:50.000 --> 00:01:54.025
依次进行 假设我们已经完成之前所有的编码 

27
00:01:54.025 --> 00:01:57.474
然后现在要对这个像素编码 

28
00:01:57.474 --> 00:02:03.008
预测编码的思想就是根据以前的像素值来猜想和预测 

29
00:02:03.008 --> 00:02:07.607
后面的像素值
我们不能依据未来的像素值去预测 

30
00:02:07.607 --> 00:02:10.770
因为解码器并不知道未来的情况 

31
00:02:10.770 --> 00:02:15.350
而调用者所能接收到的只有这些像素 

32
00:02:15.350 --> 00:02:19.880
所以我们只能 比方说 好吧 我来猜测一下 

33
00:02:19.880 --> 00:02:24.410
这个像素的值可能与前一个像素相同 

34
00:02:24.410 --> 00:02:29.832
在预测之后 我们需要来计算 

35
00:02:29.832 --> 00:02:33.374
预测值和真实值之间的误差 

36
00:02:33.374 --> 00:02:38.580
然后我们只需要将误差进行编码 比如这里使用了霍夫曼编码 

37
00:02:38.580 --> 00:02:43.522
而解码器就将模拟编码器所做的 

38
00:02:43.522 --> 00:02:48.250
也就是说 好吧 那我也来做和你一样的预测 

39
00:02:48.250 --> 00:02:51.638
我也像你一样知道过去的情况 

40
00:02:51.638 --> 00:02:56.720
我会用这个值来预测这个像素 

41
00:02:56.720 --> 00:03:00.564
所以编码器和解码器互相交流 它们在使用完全相同的预测策略 

42
00:03:00.564 --> 00:03:04.473
那么 我预测这个 你给我误差 

43
00:03:04.473 --> 00:03:07.535
然后我直接在预测上加上误差 

44
00:03:07.535 --> 00:03:12.226
于是我得到了这个像素值 然后我继续到下一个像素 

45
00:03:12.226 --> 00:03:14.700
依旧采用完全相同的方法 

46
00:03:14.700 --> 00:03:19.823
基本思想就是如果你的预测精准 

47
00:03:19.823 --> 00:03:22.789
那么误差就总是会非常接近于零 

48
00:03:22.789 --> 00:03:25.757
这个误差并不会是随机的值 

49
00:03:25.757 --> 00:03:31.082
而会是近似于零的值
如果你还记得的话 

50
00:03:31.082 --> 00:03:36.100
这正是像霍夫曼编码器那样 给经常出现的值 

51
00:03:36.100 --> 00:03:41.118
赋予一个很短的编码 而时不时会有 

52
00:03:41.118 --> 00:03:44.102
一些值在预测中产生较大的错误 

53
00:03:44.102 --> 00:03:47.221
这时候别担心 因为后面将编码误差 

54
00:03:47.221 --> 00:03:50.827
通过将误差编码 

55
00:03:50.827 --> 00:03:54.800
我们会得到无损压缩 所以当偶尔产生了一个大错误 

56
00:03:54.800 --> 00:03:58.169
霍夫曼编码将对其赋予一个较长的编码 

57
00:03:58.169 --> 00:04:02.834
但是因为这只是偶尔发生 

58
00:04:02.834 --> 00:04:06.620
所以并不会成问题 而之后依旧能够进行压缩 

59
00:04:06.620 --> 00:04:11.928
所以 无损预测压缩的很多技术关键都在于预测器的设计 

60
00:04:11.928 --> 00:04:16.232
为了使得误差总是尽可能的小 

61
00:04:16.232 --> 00:04:18.886
甚至希望是零误差 

62
00:04:18.886 --> 00:04:22.903
如果你的预测精准 那误差几乎总是零 

63
00:04:22.903 --> 00:04:25.844
这样可以大量压缩 

64
00:04:25.844 --> 00:04:31.080
如果你的预测器足够智能 至少将非常非常接近于零 

65
00:04:31.080 --> 00:04:34.471
然后解码器将只是做一个非常非常简单的解码 

66
00:04:34.471 --> 00:04:39.195
这样总体上来说 这个无损预测压缩技术的结构 

67
00:04:39.195 --> 00:04:44.672
比JPEG的要稍简单一些 

68
00:04:44.672 --> 00:04:48.985
当然这并不能达到如此大量的压缩 

69
00:04:48.985 --> 00:04:52.409
但最重要的是原图像将是无损的 

70
00:04:52.409 --> 00:04:55.490
下面我来举例说明几个可行的预测器 

71
00:04:55.490 --> 00:04:59.720
这是我们的图像 

72
00:05:00.860 --> 00:05:06.067
下面 我们来画一下预测器 

73
00:05:06.067 --> 00:05:10.456
像以前一样 假设前面这些都已经被编码了 

74
00:05:10.456 --> 00:05:16.001
现在来考虑一下 我想对这个像素进行预测 

75
00:05:16.001 --> 00:05:20.820
那么我们可以基于过去进行预测 

76
00:05:20.820 --> 00:05:28.635
只是基于这个像素 也就是说 

77
00:05:28.635 --> 00:05:38.014
预测它为F(x-1,y) 然后编码器用实际值F(x,y) 

78
00:05:38.014 --> 00:05:42.964
减去预测值 所以对于这一像素的误差将会是 

79
00:05:42.964 --> 00:05:51.920
F(x-1,y) - F(x,y) 

80
00:05:51.920 --> 00:05:56.407
这就是我要通过霍夫曼编码保存的值 

81
00:05:56.407 --> 00:06:00.552
就像之前说的 此时解码器将模拟预测器   

82
00:06:00.552 --> 00:06:05.412
它会说 啊 你预测了这个 

83
00:06:05.412 --> 00:06:10.630
你给了我一个误差 那我将误差加到我的预测中 就可以得到这个像素的值 

84
00:06:10.630 --> 00:06:15.561
非常非常简单的运算过程 特别是对于解码器来说 

85
00:06:15.561 --> 00:06:21.008
这是一个相当简单的运算 所以可以用前一个像素作为一种可行的预测器 

86
00:06:21.008 --> 00:06:24.398
而另一种是通过前面两个像素来预测 

87
00:06:24.398 --> 00:06:28.465
比如说可以用前面两个像素的平均值 

88
00:06:28.465 --> 00:06:32.609
还有其他一些预测器 比如JPEG-LS 

89
00:06:32.609 --> 00:06:36.526
所考虑的范围就更广一些 

90
00:06:36.526 --> 00:06:41.547
需要更智能一些 或许会试图利用这个区域所有的值 

91
00:06:41.547 --> 00:06:42.742
可能大家会问 

92
00:06:42.742 --> 00:06:48.344
为什么只使用左边这些呢？ 或许我可以使用上面这个 

93
00:06:48.344 --> 00:06:53.797
还有对角上的这个 所有这些合理的组合都可以 

94
00:06:53.797 --> 00:06:57.009
像之前说过的 我们可以这样 

95
00:06:57.009 --> 00:07:00.221
如果想使用这两个 那我们可以直接平均一下 

96
00:07:00.221 --> 00:07:04.884
也可以平均这三个 事实上JPEG-LS采用了更复杂的方法 

97
00:07:04.884 --> 00:07:09.078
总之  JPEG-LS是无损图像压缩的一个标准 

98
00:07:09.078 --> 00:07:12.997
事实上它正是火星车上所采用的算法 

99
00:07:12.997 --> 00:07:16.779
在火星车上用于图像压缩的算法之一 

100
00:07:16.779 --> 00:07:21.248
就包括更智能一些的JPEG-LS 

101
00:07:21.248 --> 00:07:24.893
它会尝试找出图像的边缘 

102
00:07:24.893 --> 00:07:28.605
但它仍然是非常简单的 

103
00:07:28.605 --> 00:07:33.839
记住 压缩要成为标准就必须要简单易行 

104
00:07:33.839 --> 00:07:36.507
这样才能被所有人运用 并且快速地执行 

105
00:07:36.507 --> 00:07:39.874
我们已经在JPEG中了解过这一概念 

106
00:07:39.874 --> 00:07:44.130
它对于JPEG-LS也同样适用 而且也将在MPEG中再次出现 

107
00:07:44.130 --> 00:07:49.999
其实就像我说过的   

108
00:07:49.999 --> 00:07:53.942
大家可以使用所有过去的区域 也可以只使用这些像素 

109
00:07:53.942 --> 00:08:00.251
如果已经对这些进行过编码 

110
00:08:00.251 --> 00:08:07.240
假设这是一张非常大的图像中央 我就可以使用 

111
00:08:07.240 --> 00:08:11.094
所有过去的值 一直到这里 

112
00:08:11.094 --> 00:08:16.476
问题是 如果要这么做的话 就必须记住很多的像素值 

113
00:08:16.476 --> 00:08:21.494
而这将占用大量内存 如果你要使用过去的所有信息 

114
00:08:21.494 --> 00:08:26.294
那实在是太多了 所以JPEG-LS有着最现代化的 

115
00:08:26.294 --> 00:08:31.384
无损预测压缩技术 也就是说可能只使用前一行 

116
00:08:31.384 --> 00:08:35.021
或者至多前两行 但不会超过这些了 

117
00:08:35.021 --> 00:08:39.530
否则串行存储体系 (SSA) 将会非常复杂 并且占用大量内存 

118
00:08:39.530 --> 00:08:43.126
以上就是预测编码的基本思想 

119
00:08:43.126 --> 00:08:47.873
现在来看看对于一张很简单的图像它预测效果如何 

120
00:08:47.873 --> 00:08:52.053
这是一张不错的从外太空拍摄的地球图像 

121
00:08:52.053 --> 00:08:56.600
这是一个我们之前提到过的分布直方图 

122
00:08:56.600 --> 00:09:00.319
表达了像素值的分布 还记得吗？ 

123
00:09:00.319 --> 00:09:07.006
霍夫曼编码可能会喜欢这样 因为有一定量的 

124
00:09:07.006 --> 00:09:13.604
像素值都在150左右 但是它仍然有一个非常非常宽的分布 

125
00:09:13.604 --> 00:09:20.731
现在我们用之前讲过的预测器来做预测编码 

126
00:09:20.731 --> 00:09:27.417
我们像这样一行一行地扫描每个点 

127
00:09:27.417 --> 00:09:32.344
并根据它周边几个点的值来预测这个点的值 

128
00:09:32.344 --> 00:09:39.203
这样产生的误差分布如这张图所示
用先前讲到的方法计算误差 

129
00:09:39.203 --> 00:09:45.660
然后画出误差分布的直方图 

130
00:09:45.660 --> 00:09:51.633
这是一种好的预测器和一幅好的图像 所以得到很好的误差图 

131
00:09:51.633 --> 00:09:54.942
这样得到的误差会集中到零附近 

132
00:09:54.942 --> 00:10:01.075
大家可以看到这是预测误差图 

133
00:10:01.075 --> 00:10:04.950
就像预期那样 当图像中出现大的改变时 

134
00:10:04.950 --> 00:10:09.961
预测器并不会知道变化的发生 

135
00:10:09.961 --> 00:10:15.180
这就是大多数错误产生的区域
而在灰度值相对均匀的区域 

136
00:10:15.180 --> 00:10:20.052
预测器不会产生太多的错误
这就是分布图中有很多零的原因 

137
00:10:20.052 --> 00:10:25.620
由于图像中偶尔出现的大的改变 因此产生了预测误差 

138
00:10:25.620 --> 00:10:31.327
霍夫曼编码将用更多的比特来表示这个误差
但这种情况仅仅是偶尔出现 

139
00:10:31.327 --> 00:10:35.336
因此大多数预测误差都会很小 

140
00:10:35.336 --> 00:10:39.000
这样对编码极为有利 

141
00:10:39.000 --> 00:10:45.307
这些就是JPEG-LS背后的思想
任何一种预测无损编码器 

142
00:10:45.307 --> 00:10:51.361
无损压缩的思想也是如此
你也可以将量化加入到 

143
00:10:51.361 --> 00:10:58.000
预测编码或相应的图像压缩技术中 

144
00:10:58.000 --> 00:11:03.152
我们将用量化变换系数的方法 

145
00:11:03.152 --> 00:11:06.230
来量化误差 

146
00:11:06.230 --> 00:11:10.024
这样就能够实现更多的压缩 

147
00:11:10.024 --> 00:11:13.900
事实上 误差大小是可以被控制的 

148
00:11:13.900 --> 00:11:19.390
如果每个像素点的值在量化时都可以有正负一的误差 

149
00:11:19.390 --> 00:11:23.346
那么重建后的图像 

150
00:11:23.346 --> 00:11:27.619
它每个点的灰度值和原图就会仅仅相差正负一 

151
00:11:27.619 --> 00:11:31.127
这样就能很好地控制误差的范围 

152
00:11:31.127 --> 00:11:34.428
因为这不是对变换域进行量化 

153
00:11:34.428 --> 00:11:39.105
而是对图像域进行量化
JPEG-LS就用到了这种方法 

154
00:11:39.105 --> 00:11:42.200
来对误差进行量化 

155
00:11:42.200 --> 00:11:47.968
解码器得到的是量化后的误差值 

156
00:11:47.968 --> 00:11:52.767
重新生成的像素点与原来的相比 会有小小的变化 

157
00:11:52.767 --> 00:11:58.840
下面这一点很重要 大家一定要记住
如果引进量化 

158
00:11:58.840 --> 00:12:08.564
预测时使用的则是量化后的误差
我们来画一下之前那张图 

159
00:12:08.564 --> 00:12:15.980
如果我们要预测这个像素点 

160
00:12:15.980 --> 00:12:20.030
根据这个像素点
那么请记住 

161
00:12:20.030 --> 00:12:25.854
解码器在重建量化误差之后 只会有这个像素量化后的值 

162
00:12:25.854 --> 00:12:31.078
对于编码器而言 它必须要模仿解码器的行为 

163
00:12:31.078 --> 00:12:36.610
并按照量化后的像素值计算 

164
00:12:36.610 --> 00:12:40.032
如果是基于原图进行预测 

165
00:12:40.032 --> 00:12:45.565
则是在用解码器无法获取的信息做预测 

166
00:12:45.565 --> 00:12:49.059
因此 在流程图里 

167
00:12:49.059 --> 00:12:52.990
进入预测器中的是量化后的值 

168
00:12:52.990 --> 00:12:58.669
这些都是在设计无损预测和 

169
00:12:58.669 --> 00:13:04.221
无损图像压缩时需要记住的 

170
00:13:04.221 --> 00:13:09.974
如果想要做量化处理
那么请记住 在图像压缩时不能使用 

171
00:13:09.974 --> 00:13:13.975
解码器无法获得的信息 

172
00:13:13.975 --> 00:13:18.928
对于编码器而言 它只能利用解码器所能获得的信息 

173
00:13:18.928 --> 00:13:22.987
如果不这样做 这个系统就不对称 

174
00:13:22.987 --> 00:13:27.962
它也不会很好的运作
因此 这是大家唯一需要记住的地方 

175
00:13:27.962 --> 00:13:30.860
正如我所说的 JPEG-LS中包含量化 

176
00:13:30.860 --> 00:13:34.645
这就是无损预测编码或者 

177
00:13:34.645 --> 00:13:40.285
以及有一定误差的编码方法背后的思想 

178
00:13:40.285 --> 00:13:44.615
我们用来预测的方法并不只有这一种 

179
00:13:44.615 --> 00:13:49.109
还有MPEG 它是视频压缩的标准 

180
00:13:49.109 --> 00:13:53.194
也是基于预测来实现压缩的 

181
00:13:53.194 --> 00:13:59.648
不过 这里有很多的帧
想一下视频中 一秒钟有三十帧 

182
00:13:59.648 --> 00:14:04.060
为了完成预测
我们举个例子 

183
00:14:04.060 --> 00:14:10.790
对于这个帧
可以用前面几个帧来预测它 

184
00:14:10.790 --> 00:14:16.241
基本思想很简单
如果拍摄的场景是完全静止的 

185
00:14:16.241 --> 00:14:20.832
那么每一帧都会和之前的帧一模一样 

186
00:14:20.832 --> 00:14:23.988
MPEG会试图利用这个性质 

187
00:14:23.988 --> 00:14:28.579
它会试图关注图像中的一个区域 

188
00:14:28.579 --> 00:14:33.595
看看这块区域是不是恒定不变的
这可以用很多方法实现 

189
00:14:33.595 --> 00:14:37.461
我们不会详细讨论MPEG是如何实现这些的 

190
00:14:37.461 --> 00:14:41.541
不过 作为一个例子 

191
00:14:41.541 --> 00:14:46.895
大家可以看一下这块区域
观察它附近有没有相似的区域 

192
00:14:46.895 --> 00:14:51.815
并不一定是完全相同的位置 可以是在它的周围 

193
00:14:51.815 --> 00:14:57.498
MPEG可以在之前的几帧里寻找相似的区域 

194
00:14:57.498 --> 00:15:02.626
或许是一帧 或许是三帧
它会去寻找相似的区域 

195
00:15:02.626 --> 00:15:07.477
然后只编码那些误差 

196
00:15:07.477 --> 00:15:10.530
它会做时间上的预测 

197
00:15:10.530 --> 00:15:14.952
这种想法很简单 而且非常实用 

198
00:15:14.952 --> 00:15:17.900
我们知道MPEG能够压缩很多空间 

199
00:15:17.900 --> 00:15:23.655
因为有这样一个事实
举个很好的例子 在这个视频里 

200
00:15:23.655 --> 00:15:27.866
只有我一个人在动 而整个背景是一直保持不变的 

201
00:15:27.866 --> 00:15:33.270
如果你在背景中取一块区域
你可以在之前的几帧里 

202
00:15:33.270 --> 00:15:38.955
找到一样的区域 这样 预测误差就会变成零 

203
00:15:38.955 --> 00:15:43.873
这对编码器来说是件好事
我们再举个例子 

204
00:15:43.873 --> 00:15:49.980
这是之前看过的图像
不过这里有两帧这样的图像 

205
00:15:49.980 --> 00:15:56.164
图像一和图像二
我们做一个简单的预测 

206
00:15:56.164 --> 00:16:00.286
我们预测第二个图像和第一个图像相同 

207
00:16:00.286 --> 00:16:06.164
如果图像中没有太多的移动
那这会是一个非常好的预测 

208
00:16:06.164 --> 00:16:11.889
就像之前看到的空间上的预测器一样
多数情况下 预测误差会是零 

209
00:16:11.889 --> 00:16:17.221
这是一个时域预测器
我们预测每一个像素 

210
00:16:17.221 --> 00:16:22.786
都和前一幅图像中相同位置的像素点一样 

211
00:16:22.786 --> 00:16:27.015
我们可以更聪明一些
在那个点附近找相同的像素点 

212
00:16:27.015 --> 00:16:32.579
然后再同时编码像素值和偏移量 

213
00:16:32.579 --> 00:16:35.770
这样就知道是在左边 或其他某个地方找到了相同的像素点 

214
00:16:35.770 --> 00:16:39.732
但是这例子是最简单的 

215
00:16:39.732 --> 00:16:42.741
在一样的位置找到相同的像素点 

216
00:16:42.741 --> 00:16:46.263
这是上面两幅图像的差 

217
00:16:46.263 --> 00:16:50.960
这是误差的分布图
所以 如果知道了这一帧图像 

218
00:16:50.960 --> 00:16:57.219
那么就能通过复制前一帧 并加上相应的误差值 

219
00:16:57.219 --> 00:17:04.070
高效地产生这一帧图像 

220
00:17:04.070 --> 00:17:08.101
因为解码器已经有了前一帧图像
所以复制它不需要占用额外的空间 

221
00:17:08.101 --> 00:17:12.200
因为误差集中在零附近 

222
00:17:12.200 --> 00:17:17.223
用霍夫曼编码就可以高效地压缩它 

223
00:17:17.223 --> 00:17:20.858
把这两幅图像相加就能得到这幅图像 

224
00:17:20.858 --> 00:17:25.683
然后再计算下一帧图像
但如果图像中有很多移动 

225
00:17:25.683 --> 00:17:30.575
那么误差图就不会这么简单
但我们希望它能足够简单 

226
00:17:30.575 --> 00:17:34.660
这样霍夫曼编码就能够利用这一点 

227
00:17:34.660 --> 00:17:42.830
这是MPEG或者视频压缩技术的基本流程图 

228
00:17:42.830 --> 00:17:47.143
它和JPEG的流程图很相似 

229
00:17:47.143 --> 00:17:54.270
它用到了离散余弦变换、量化和像霍夫曼编码这种不等长编码方法 

230
00:17:54.270 --> 00:18:00.144
它只是额外添加了这个模块
用来编码时域的预测误差 

231
00:18:00.144 --> 00:18:04.686
这个模块负责对图像移动的预测 

232
00:18:04.686 --> 00:18:10.873
使用之前图像的一个区域作为预测 

233
00:18:10.873 --> 00:18:15.181
但是基本结构是一样的 

234
00:18:15.181 --> 00:18:19.019
加上这个模块来处理时域的预测 

235
00:18:19.019 --> 00:18:24.501
并不是只压缩一幅图像 而是压缩很多幅图像 

236
00:18:24.501 --> 00:18:27.619
而且很多是相似的 

237
00:18:27.619 --> 00:18:32.985
再次提一下预测编码
这里利用了 

238
00:18:32.985 --> 00:18:36.160
在JPEG中使用到的技术 

239
00:18:36.160 --> 00:18:40.619
和在预测编码中用到的技术 

240
00:18:40.619 --> 00:18:46.690
两者相结合产生了MPEG
我们已经总结了 

241
00:18:46.690 --> 00:18:51.200
图像和视频压缩背后的概念 

242
00:18:51.200 --> 00:18:56.672
我们讨论了JPEG 讨论了JPEG-LS和MPEG 

243
00:18:56.672 --> 00:18:59.630
我们利用了一些变换 做了预测编码 

244
00:18:59.630 --> 00:19:03.993
我们用到了量化和霍夫曼编码 

245
00:19:03.993 --> 00:19:09.983
我们讨论了压缩的每一个模块
在图像和视频处理中每天都会用到这些 

246
00:19:09.983 --> 00:19:14.690
下一个视频是附加视频 

247
00:19:14.690 --> 00:19:18.457
如果你有时间 我建议你看一下这个视频 

248
00:19:18.457 --> 00:19:23.348
我会大致介绍一下游程编码
这样你会有一个全面的了解 

249
00:19:23.348 --> 00:19:27.380
但是如果你没有时间 你可以跳过这个视频 

250
00:19:27.380 --> 00:19:30.818
下一周我们将进入下一个单元 

251
00:19:30.818 --> 00:19:32.140
非常感谢