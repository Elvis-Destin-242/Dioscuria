WEBVTT

1
00:00:00.000 --> 00:00:03.441
大家好 欢迎回到我们的图像与视频处理课程上来 

2
00:00:03.441 --> 00:00:07.648
这是课程的第二周 我们将要讨论图像和视频的压缩 

3
00:00:07.648 --> 00:00:11.964
这或许是图像和视频处理中最成功的领域之一了 

4
00:00:11.964 --> 00:00:16.116
压缩技术是一种使能技术 它的应用非常广泛 

5
00:00:16.116 --> 00:00:19.503
正如我们将要见到的那样 如果你有一些 

6
00:00:19.503 --> 00:00:23.983
信息论或者信号处理的基础知识 

7
00:00:23.983 --> 00:00:28.570
这一单元中的一些话题对你而言会很简单 但是如果你没有相应的基础 

8
00:00:28.570 --> 00:00:32.749
也不必担心 因为这一单元相对独立 我也会 

9
00:00:32.749 --> 00:00:38.052
教你所需要的这些领域的相关概念 

10
00:00:38.052 --> 00:00:42.730
包括信息论和信号处理 这样我们就可以理解 

11
00:00:42.730 --> 00:00:45.725
图像压缩 静态图像压缩(JPEG) 动态图像压缩(MPEG) 等技术是如何工作的 

12
00:00:45.725 --> 00:00:50.716
作为开始 让我们看看为什么我们需要图像压缩 

13
00:00:50.716 --> 00:00:53.336
这解释起来并不困难 让我们算几个数字 

14
00:00:53.336 --> 00:00:57.966
假设我们有一张分辨率为1000 x 1000的图片 

15
00:00:57.966 --> 00:01:02.896
我们知道 以现在的标准 这是一张 

16
00:01:02.896 --> 00:01:06.512
低分辨率的图像 但是我们就用它吧 

17
00:01:06.512 --> 00:01:10.588
计算上方便些 假设我们需要8比特 

18
00:01:10.588 --> 00:01:14.861
正如一般标准规定的那样 用8比特来表示每一种颜色 

19
00:01:14.861 --> 00:01:18.082
也就意味着我们每个像素需要24个比特 

20
00:01:18.082 --> 00:01:21.238
所以我们得到了一个数组 大小为1000 x 1000 

21
00:01:21.238 --> 00:01:24.327
再乘以用来表示三种颜色的24比特 

22
00:01:24.327 --> 00:01:28.337
这是针对一张图像的计算 如果我们是计算视频的话 

23
00:01:28.337 --> 00:01:33.111
这只是一帧而已 我们实际上需要30张这样的图像来得到 

24
00:01:33.111 --> 00:01:39.543
一秒钟的视频 然后我们把60个这样的视频加起来得到一分钟的视频 

25
00:01:39.543 --> 00:01:48.077
然后我们再将它乘以120得到一部两个小时的 

26
00:01:48.077 --> 00:01:51.200
电影 所以这个式子的结果是多少？ 

27
00:01:51.200 --> 00:01:58.590
结果是一个非常大的数字 非常非常大 

28
00:01:58.590 --> 00:02:04.806
你可以自己算一下 但是你会同意这个结论的 

29
00:02:04.806 --> 00:02:10.678
一张低分辨率的图像就会产生很大的结果 

30
00:02:10.678 --> 00:02:16.550
所以哪怕我们只有一张照片 我们仍然有一个很大的结果 

31
00:02:16.550 --> 00:02:22.194
如果没有压缩的话 我们不可能把一大堆这样的照片 

32
00:02:22.194 --> 00:02:25.526
存入我们的手机或者电脑中 

33
00:02:25.526 --> 00:02:30.490
所以当我们开始讨论图像和视频的时候 我们马上 

34
00:02:30.490 --> 00:02:34.910
就遇到了很大很大的数字 这就是我们需要图像压缩的原因 

35
00:02:34.910 --> 00:02:40.030
我们需要储存这些图像和视频 

36
00:02:40.030 --> 00:02:44.126
而不必在我们的手机或电脑中占据大量的空间 

37
00:02:44.126 --> 00:02:48.563
这就是我们需要图像和视频压缩的一个原因 

38
00:02:48.563 --> 00:02:52.523
问题是 为什么我们可以压缩图像和视频？ 

39
00:02:52.523 --> 00:02:57.028
这有许多原因 我们将会讨论它们 

40
00:02:57.028 --> 00:03:00.388
其中一个原因通常被称为冗余 

41
00:03:00.388 --> 00:03:05.994
这是我们首要的关注点之一 

42
00:03:05.994 --> 00:03:11.816
不是每个像素值都是相等的 有的像素值出现的多些 有的则 

43
00:03:11.816 --> 00:03:15.985
出现的少些 正如我们在这张图中见到的 

44
00:03:15.985 --> 00:03:21.608
许多像素值被用来表示这个星星 一小部分用来表示 

45
00:03:21.608 --> 00:03:26.404
这些白线 而表示某些特定颜色的像素值几乎没有 

46
00:03:26.404 --> 00:03:31.790
所以我们可以看到这张图里有一、二、三、四 四种颜色 

47
00:03:31.790 --> 00:03:38.100
如果用8比特来表示 也就是用256种可能性来表示4种颜色 

48
00:03:38.100 --> 00:03:43.570
这是一种浪费 所以我们将要利用这一点 

49
00:03:43.570 --> 00:03:49.039
还有一个原因使得我们可以进行压缩 还是关于大量的冗余 

50
00:03:49.039 --> 00:03:52.520
这点在这张图上表现的很直观 

51
00:03:52.520 --> 00:03:57.871
让我们假设其中一条线的灰度值为常数 

52
00:03:57.871 --> 00:04:01.571
举个例子 就等于128好了 

53
00:04:01.571 --> 00:04:05.584
想象一下这条线非常的长 

54
00:04:05.584 --> 00:04:11.163
比如说10000个像素那么长 所以至少有两种 

55
00:04:11.163 --> 00:04:18.816
极端的方法来表示这条线 一种是把128重复10000次 

56
00:04:20.030 --> 00:04:25.350
这会花掉10000字节也就是10000乘以8比特 

57
00:04:25.350 --> 00:04:30.576
我们要128 128 128 128 这样重复10000次 

58
00:04:30.576 --> 00:04:37.548
看起来非常浪费 或者换一种办法 我从这开始 

59
00:04:37.548 --> 00:04:43.808
有10000个128 也就是说我给出了一个数字 用来说明 

60
00:04:43.808 --> 00:04:49.675
我要重复128次 这样用来存储的记忆空间就会小得多了 

61
00:04:49.675 --> 00:04:53.430
我只要存储像素值128 

62
00:04:53.430 --> 00:04:59.307
以及其出现的次数10000 

63
00:04:59.307 --> 00:05:03.633
相比保存128这个值10000次   

64
00:05:03.633 --> 00:05:07.470
只保存这两个数字无疑节省了非常多的空间 

65
00:05:07.470 --> 00:05:11.822
这是一个极端的例子 但是非常重要 

66
00:05:11.822 --> 00:05:16.850
它在有均匀区域或者几何一致性的图像中经常出现 

67
00:05:16.850 --> 00:05:19.731
我们可以利用这一点来进行压缩 

68
00:05:19.731 --> 00:05:24.574
这就是我们能进行压缩的第二个原因 顺便说一句 

69
00:05:24.574 --> 00:05:29.295
这对视频压缩一样适用 我们能进行压缩的第三个原因就在这儿 

70
00:05:29.295 --> 00:05:32.571
这是一张纯色图像 灰度值为常数 

71
00:05:32.571 --> 00:05:37.197
这张图里有非常多的无关信息 

72
00:05:37.197 --> 00:05:42.763
这里有大量的我们并不关心的信息会被存储 

73
00:05:42.763 --> 00:05:46.015
或者说我们并不介意这些信息被存储时会有些许的不同 

74
00:05:46.015 --> 00:05:51.002
比如说 如果这个值是128 我并不介意它被说成是127 

75
00:05:51.002 --> 00:05:54.204
有可能我对这个值一点都不关心 

76
00:05:54.204 --> 00:05:58.793
我可能不关心它的精确值是多少 可能不太关心 

77
00:05:58.793 --> 00:06:02.265
这些信息 所以这里有大量的无用信息 

78
00:06:02.265 --> 00:06:04.994
无关信息 

79
00:06:04.994 --> 00:06:08.156
以上就是我们能进行压缩的三个原因 

80
00:06:08.156 --> 00:06:10.761
我们将利用所有这些原因 

81
00:06:10.761 --> 00:06:14.420
然后我们就能实现很大程度的压缩 

82
00:06:16.160 --> 00:06:21.741
教材上有许多压缩的方法 其中一部分 

83
00:06:21.741 --> 00:06:24.931
成功的图像压缩方法最终成为了标准 

84
00:06:24.931 --> 00:06:29.981
这非常重要 因为当我在我的数码相机中保存了一张图像时 

85
00:06:29.981 --> 00:06:32.772
我希望所有的电脑都能读取它 

86
00:06:32.772 --> 00:06:37.955
我想通过电子邮件把这张图片分享给我的朋友和同事 希望他们能够读取它 

87
00:06:37.955 --> 00:06:40.946
所以我存储照片的方式必须 

88
00:06:40.946 --> 00:06:43.870
与其他人读取它的方式兼容 

89
00:06:43.870 --> 00:06:48.210
这就是有如此多的压缩标准的原因 

90
00:06:48.210 --> 00:06:53.351
对于静态图像 这是最普遍的三种标准 当然 你应该对JPEG 

91
00:06:53.351 --> 00:06:56.690
有所了解 JPEG被大多数相机所采用 

92
00:06:56.690 --> 00:07:01.498
而且我们将会在接下来的视频里 

93
00:07:01.498 --> 00:07:06.439
讨论很多与图像处理和图像压缩有关的知识 

94
00:07:06.439 --> 00:07:08.807
这有一个标准称为JPEG-LS 

95
00:07:08.807 --> 00:07:13.804
是一种无损压缩 所以你所见的都会被压缩 

96
00:07:13.804 --> 00:07:18.018
在这种情况下 没有不相关的信息 所有的信息都会被压缩 

97
00:07:18.018 --> 00:07:21.088
这儿还有个新标准JPEG-2000 

98
00:07:21.088 --> 00:07:24.460
我们将重点讨论JPEG和JPEG-LS 

99
00:07:24.460 --> 00:07:29.122
对于视频而言也有相应的标准 再说一次 当我拍摄了一段视频 

100
00:07:29.122 --> 00:07:33.980
保存到我手机里然后发送给朋友 我希望他们能够读取它 

101
00:07:33.980 --> 00:07:37.998
为了能读取 他们需要知道我是如何进行压缩的 

102
00:07:37.998 --> 00:07:42.730
当然了 最常见的压缩标准就是MPEG家族 

103
00:07:42.730 --> 00:07:46.375
虽然这里还列出了其它的压缩技术 

104
00:07:46.375 --> 00:07:48.612
这两个标准有些相辅相成的味道 

105
00:07:48.612 --> 00:07:53.832
它们在图像和视频压缩上是如此成功 以至于被制定成了标准 

106
00:07:53.832 --> 00:07:59.118
这使得所有人都在用着同样的技术 而所有人用着 

107
00:07:59.118 --> 00:08:03.163
同样的技术这件事反过来也使得它非常的成功和普及 

108
00:08:03.163 --> 00:08:08.057
如今数码相机制造商可以充满信心地 

109
00:08:08.057 --> 00:08:12.363
使用JPEG 因为他们知道所有人都能够读取这种格式 

110
00:08:12.363 --> 00:08:16.080
这就是为什么他们能如此安心地使用JPEG 

111
00:08:16.080 --> 00:08:22.151
一般的图像压缩技术都会利用到 

112
00:08:22.151 --> 00:08:26.401
我在前几页幻灯片中提及的图像的各种性质 它们的原理是这样的 

113
00:08:26.401 --> 00:08:31.826
从一张图像开始 经过一个映射器 (mapper) 也就是我们 

114
00:08:31.826 --> 00:08:36.928
把上周讲到的数组 比如说它有1000乘1000个点 

115
00:08:36.928 --> 00:08:40.787
进行了变换使得其更容易被压缩 

116
00:08:40.787 --> 00:08:45.366
我们来讨论下这些映射变换 有些映射变换 

117
00:08:45.366 --> 00:08:49.879
与傅里叶变换相关 实际上也就是是一个余弦变换 

118
00:08:49.879 --> 00:08:54.327
一些映射变换是发生在空间域上 

119
00:08:54.327 --> 00:08:58.710
依据相邻的像素进行变换 我们将会对此进行讨论 

120
00:08:58.710 --> 00:09:04.423
在映射变换之后 图像在空间上变得易于压缩 

121
00:09:04.423 --> 00:09:06.841
然后下一步就是量化 

122
00:09:06.841 --> 00:09:09.859
我们已经说过了量化 

123
00:09:09.859 --> 00:09:13.596
量化是引入错误的主要原因 

124
00:09:13.596 --> 00:09:19.201
它引进了一些易于压缩的东西 但是也限制了 

125
00:09:19.201 --> 00:09:24.591
对图像的精确重构 比如说 可能有一个像素 

126
00:09:24.591 --> 00:09:30.862
它的值为17 而量化技术或许会 

127
00:09:30.862 --> 00:09:35.974
将这个值除以2 然后再取整 

128
00:09:35.974 --> 00:09:41.700
得到最接近的不大于该值的整数之后再乘2 这是我们上回讲到的 

129
00:09:41.700 --> 00:09:48.006
所以我们这里会以重构结束 我们重构得到的值为16而不是17 

130
00:09:48.006 --> 00:09:51.123
所以量化会引入误差 

131
00:09:51.123 --> 00:09:56.849
我们将描述一些最好的量化技术 

132
00:09:56.849 --> 00:10:02.502
实际上JPEG所用的量化技术就是我写在这的这种 

133
00:10:02.502 --> 00:10:07.863
最后一个步骤是利用符号编码器编码 

134
00:10:07.863 --> 00:10:10.639
现在我已经完成了映射变换 

135
00:10:10.639 --> 00:10:14.833
也完成了量化 现在我们已经有了一些数值  我需要的是把它们 

136
00:10:14.833 --> 00:10:18.164
传输出去 我希望另一边的接收器 

137
00:10:18.164 --> 00:10:22.357
能够得到准确的值 这儿信息论 

138
00:10:22.357 --> 00:10:27.081
就起到了作用 因为信息论告诉我们如何使这一切 

139
00:10:27.081 --> 00:10:31.471
在计算时间和压缩效率上都变得更有效率 

140
00:10:31.471 --> 00:10:36.727
从使用更频繁的某些像素值的角度出发 信息论能够 

141
00:10:36.727 --> 00:10:41.850
利用存在于图像中的冗余 

142
00:10:41.850 --> 00:10:44.240
我们将从这一点开始 

143
00:10:44.240 --> 00:10:49.273
现在我需要对图像做的处理都已经完成了 

144
00:10:49.273 --> 00:10:52.490
我希望你存储或者传输这些像素 

145
00:10:52.490 --> 00:10:57.741
然后一旦你压缩了图像 你就得到了一个压缩过的文件 

146
00:10:57.741 --> 00:11:02.345
这就是编码器 它获取图像然后 

147
00:11:02.345 --> 00:11:06.086
压缩它 而解码器会将其解码 

148
00:11:06.086 --> 00:11:09.108
解码器并不会进行量化 

149
00:11:09.108 --> 00:11:12.512
因为量化和编码都已经做过了 

150
00:11:12.512 --> 00:11:16.323
解码器可能只是进行逆运算 比如说 重新乘上2 

151
00:11:16.323 --> 00:11:21.633
然后进行逆映射变换 就可以得到图像 

152
00:11:21.633 --> 00:11:27.010
如果是没有误差的无损压缩的话 那么图像是完好无损的 

153
00:11:27.010 --> 00:11:32.115
或者说只是一个原图的近似品 一般而言这个近似品 

154
00:11:32.115 --> 00:11:36.131
我们裸眼无法分辨出与原图的不同之处 

155
00:11:36.131 --> 00:11:40.400
那样的话这就是一个好的近似 像JPEG和MEPG一样 

156
00:11:40.400 --> 00:11:45.713
这就是全部的步骤了 这也解释了为什么我们需要标准 

157
00:11:45.713 --> 00:11:49.604
如果我用了某种映射变换 解码器需要 

158
00:11:49.604 --> 00:11:55.666
知道这个映射变换 然后才能进行逆运算 我还需要告诉 

159
00:11:55.666 --> 00:12:01.204
解码器我所用的符号编码方法 这样解码器才能 

160
00:12:01.204 --> 00:12:06.879
逆运算得到符号编码 JPEG就是这样一个例子 

161
00:12:06.879 --> 00:12:12.481
正如我所说 我们将介绍JPEG的工作原理 

162
00:12:12.481 --> 00:12:16.982
JPEG首先得到一张图片 然后把它分割成小图片 

163
00:12:16.982 --> 00:12:22.860
也就是说 它把一张完整的图像分割成一块一块 

164
00:12:22.860 --> 00:12:27.937
这种块是8乘8像素的 我们将会知道为什么这样 

165
00:12:27.937 --> 00:12:30.143
然后就是进行变换 

166
00:12:30.143 --> 00:12:34.620
这就是我们刚说过的映射变换 在这儿 这个变换是 

167
00:12:34.620 --> 00:12:39.821
离散余弦变换 (Discrete Cosine Transform) 我们会详细地讨论它 

168
00:12:39.821 --> 00:12:43.860
给出相关的公式 并解释为什么使用它 

169
00:12:43.860 --> 00:12:47.259
JPEG采用的量化方式也是我刚才提到的那种 

170
00:12:47.259 --> 00:12:51.226
JPEG会将值除以某个数然后取整 

171
00:12:51.226 --> 00:12:55.415
不同的除数会产生不同的版本 

172
00:12:55.415 --> 00:12:59.867
我们也将对此作出解释 完成这些之后 

173
00:12:59.867 --> 00:13:04.424
就要进行符号编码 也就是霍夫曼编码 我们会解释它的 

174
00:13:04.424 --> 00:13:07.749
这就是JPEG的全部流程 

175
00:13:07.749 --> 00:13:12.430
在这个单元结束后 我会给你一个可选的作业 

176
00:13:12.430 --> 00:13:16.125
就是在你自己的电脑上实现JPEG 

177
00:13:16.125 --> 00:13:18.711
你会发现这并不那么困难 

178
00:13:18.711 --> 00:13:22.530
这种算法的成功一部分也得益于此 

179
00:13:22.530 --> 00:13:27.531
解码器会对其进行解码 运用离散余弦变换的逆变换 

180
00:13:27.531 --> 00:13:31.032
它把这些块一个挨着一个摆放 

181
00:13:31.032 --> 00:13:34.247
然后显示图像 

182
00:13:34.247 --> 00:13:37.319
到这儿我们只完成了一种颜色的处理 

183
00:13:37.319 --> 00:13:40.534
我们还将讨论 

184
00:13:40.534 --> 00:13:45.178
不同颜色 例如是如何处理RGB的 

185
00:13:45.178 --> 00:13:50.720
通过利用不同颜色间的冗余 我们实际上 

186
00:13:50.720 --> 00:13:54.990
可以进一步地压缩 JPEG只是 

187
00:13:54.990 --> 00:13:59.610
这种压缩技术原型的一个实例 

188
00:13:59.610 --> 00:14:04.377
这个原型包括映射变换这个部分 量化 以及符号编码器 

189
00:14:04.377 --> 00:14:08.880
所以JPEG是这种技术一个非常成功的实例 

190
00:14:08.880 --> 00:14:15.792
我想是时候前进了 让我们来讨论这每一个步骤吧 

191
00:14:15.792 --> 00:14:16.816
谢谢
// 教育无边界字幕组 | 风过成伤 | luoyetx | zeadoit 谢谢
// 果壳教育无边界字幕组 | 风过成伤 | luoyetx | zeadoit