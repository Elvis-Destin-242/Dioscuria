我们现在要讲解建立图像压缩算法的每一个环节 而且会特别详细讲解静态图像压缩标准 (JPEG) 之前也提到过 我们将从符号编码器讲起 我们会对图像数据做变换和量化 这些环节在后续课程会详细讲解 在完成所有变换和量化之后 我们希望进一步压缩图像 量化会提供一定程度的压缩 但我们仍希望进一步压缩 我们需要存储量化后的数据 我们需要保证精确无误地存储 但是也需要思考如何进行压缩 那么 为什么能做到这些呢? 其基本思想很简单 当然 如果不至少先给大家看一次这张叫 Lena 的非常著名的图片 那就不算是教过图像处理 在图像处理中 经常用到这张图片 但现如今 由于我们拥有丰富的图像资源 也会使用许多其它图像 不过我还是想在这九周中至少给大家展示一次这张图片 而且在以后的课程中我们可能还会多次见到它 基本思路是这样的 图像中的一些像素 一些灰度值出现的次数多于其它灰度值 我们来看看这个现象 在右边 有一幅直方图 直方图记录每一特定的灰度值在图像中出现的次数 比如说 某一像素的灰度值 假设灰度值大约是47 它出现了这么多次 我们遍历整幅图像 计算有多少灰度值为47的像素点 这就是它出现的次数 我们继续看下一个灰度值 比如说200 我们看到 灰度值200在这幅图中大约出现了700次 我们可以看到有些像素值出现了许多次 而另一些像素值 比如 0或1 根本就没有出现过 因此 我们要采用的方法的基本思路是 给出现次数很多的像素值一个非常简短的编码 而给出现次数较少的像素值很长的 或者说相对较长的编码 下面来看看具体如何编码 下面来看一个应用上述方法的例子 这里是一个图像 这正是大家在前面视频中见过的那个几何图像 这是比较特殊的图像 它只有四个不同的灰度值 而灰度值为87的像素占了整个图像的四分之一 即 25% 或者说 灰度值47 出现的概率是 0.25 同时灰度值为128的像素几乎占了图像的一半 这里是灰度值186 而 255 出现的次数极少 其它的灰度值并没有出现 所以表示这个图像的标准方式是 用到了数组 对于每一个像素 使用八位二进制码表示其像素值 所以 我们用87的二进制码来表示灰度值87 用128的二进制码来表示灰度值128 以此类推 所以在最后 如果我们不进行压缩 那每个像素要占 8比特 但是现在来假设一下 如果我想办法构造了如图所示的编码 其中 87是用二进制码01来表示的 128 用二进制码1 来表示 186用二进制码000表示 而255用二进制码001 这就意味着 比如说 如果想要存储或发送 87、87、255、128 这几个像素值 并不是用这些二进制码 然后是这个 而是用这个表示255 这些来表示128 这种表示方式需要 4乘以8 也就是32比特位 不如我们用以下这种方式来表示 我会假设 87用01来表示 87还用01来表示 255用001来表示 128用1来表示 所以这里需要2 4 7 一共8比特 而不是32比特 来表示同一组灰度值 现在 解码器会根据这个表格解码 所以解码器看到01时 会在这个像素的位置输出 87 看到01 再次输出 87 然后发现 001 这里要输出255 等等 如此就完成了压缩 现在来看看这到底压缩了多少 我们来做一个非常简单的计算 我们来看一看 抱歉
在 5 分 10 秒处开始记录5:10
我们有0.25的概率 需要用到长度为2的二进制码01 有0.47的概率 使用长度是1的二进制码 这里加上0.47乘以1 有0.25的概率 也就是四分之一的图像中 我们要用到长度为3的二进制码 最后是很小的概率 同样用到长度为3的二进制码 结果等于1.81 好了 所以现在整个图像中平均每个像素只占1.81比特 而不是之前的8比特 这里省了很多像素 从8减到了1.81 也就是说 压缩了四倍以上 这就是我们刚刚做的 刚刚我们利用了一些像素值的出现次数远比另一些多的现象 然后用更短的编码来表示这些像素值 这里用了更短的编码 那么 怎么才能做到这一点呢 这里我们用到了霍夫曼编码 接下来我会解释怎么运用这种编码 再看看这个例子 解释霍夫曼编码最好的办法是举个例子 接下来我要用这个例子说明 现在假设我们用五个不同的符号 抱歉 是六个不同的符号 第一步 按概率大小排列这些符号 概率从高到低 如果有些概率相同 那么无所谓谁先谁后 比如说 a2可能代表像素值100 符号 a6 可能代表像素值77 等等 现在我会做一些加法 先把符号列在这里 把概率列在这里 然后从下往上 取最底下的两个数 把它们的概率相加 用0.04加上0.06 得到了0.1的概率 然后将这一列概率重新排列一遍 这些都没有变 唯一改变了的是最后一个 看看这里的变化 0.4的概率对应于a2 0.3的概率指向a6 0.1的概率指向a1 0.1的概率指向 符号 a4 而最后一个概率0.1对应a3或a5 我们要用一些办法来区分 a3和a5 下一张幻灯片会解释如何区分它们 现在 重复一下刚才的步骤 将最低的两个值相加 现在 这个值是0.2 记住每次都要重新排序 让我再解释一下 概率0.4对应a2 0.3对应a6 而现在 0.2对应这两个概率值 也就是 a4、a3还有a5 我们现在还不能确定是哪个符号 但是0.2的概率对应着其中一个 然后这里是0.1 重复刚才的步骤 再重复一次 实际上 还需要重复两次 我们得到这两个最小值 算出这个值 再把它和最小的值相加 然后得到这个值 继续重复 每一次我们都将最小的两个值相加得到下一列概率值 并且重新排序 直到只剩下两个数 然后来看看为什么在这里停下 下面我们来进行编码 这是依据前一幻灯片中图表的一个重绘 这是第一列 这是第二列 第三列 第四列 和第五列 现在 从后往前 依次赋值编码 给0.6赋上0 给0.4赋上1 在继续往回推进之前 我来解释一下这里是怎么回事 当解码器看到0 它会明白这是从 0.6对应的这一组来的 当它看到一个 1 就会知道是 0.4对应的这一组 然后要添加更多的比特位来区分每组中的各个数值 这就是为什么要从后往前走 把这个 0 抄送到这里来 这个0.6是由 0.3加0.3 得来的 所以要在后面分别加上0和1 当然我们要把 0.4抄送到这里 给它赋上从上一列得来的码值 这里不用加任何数字 所以它会一直不加任何比特位被抄送到前面 现在 要找到与这组对应的所有符号 而这里 我们会看到 其实只有一个符号对应于这个组 现在有了这个编码和所有指向这个概率的符号 这里的编码是从 01 开始的 现在继续往前抄送 将 1 抄送到这里 为1 00 抄送为00 而01需要被分开因为这个0.3的概率 是由这两个相加得到的 接着就变成了010和011 然后继续 把1抄送过来 0抄送过来 这个011的编码抄送到这里 而这个要分开 每次之所以要把它分开 是因为之前在算它的时候是相加得到的 然后回到这里 这里要分开 每次分开的时候 都要加上0和1 所以一直继续 就得到了这个结果 也就是第一个符号的编码是1 符号a6的编码是00 以此类推 所以这就是它们的编码 这些是变长编码 用来表示各个符号的编码长度并不完全一样 各个编码是有不同长度的 而这个长度取决于概率 概率越大 编码越短 这很容易看出 因为低概率值在不断被相加 当往回推导的时候 就要不断分开 记住 每次分开的时候都要加一个符号 因此要为这个符号加一个比特位 所以 编码变得越来越长 这里也可以算出编码的平均长度 回顾一下之前的步骤 按照概率排列符号的顺序 这是这一步做的 然后开始把低概率相加 将这两个相加 就得到了这个 重新排列然后继续 这是一个递归的过程 所以如果知道了怎么从一列进行到下一列 就知道了怎么完成它 然后回来看这个 这里有几件非常重要的事情要注意 用这种方法得到的编码叫做无前缀编码 这是非常 非常重要的 来看这一列 当这里有一个1 解码器看到一个1 它就知道要到这里找到a2 当这里有一个0 这就是在说 好吧 我要等着看下一个符号是什么 但是没有任何一段码字完全是其它编码的前缀 这是非常重要的 不然解码器是无法重建图像的 看看下面这个例子 这里的码字会是前缀 比如 符号a1是用 码字1表示的 符号 a2 是用 码字0 表示的 符号a3 是用 码字01 表示的 当解码器看到01 会出现两种可能 一种可能是a3 假设它对应的像素值是100 另一种可能是 a2后面跟着a1 假设像素是0和255 因此重建过程就出现了很大的歧义 无法分辨到底是哪一个 因为这个编码并不是无前缀编码 这个是这个的子集 而在这里就不会发生这种情况 现在把这些注释都清除 这里没有任何一个编码有所重复 比如说00 因此 当解码器看到了一个1 就知道怎么办 它会找到a2的像素值 当它看到一个0 它需要继续分辨 因为这里很多码字都是以 0 开头的 如果它看到有一个0 之后跟着一个0 它会完成这段码字的解码 并得到a6 如果解码器收到了一个0 然后跟着一个1 它还需要继续分辨 因为有很多码字都是以01开头的 但是之后 如果又接收到了一个1 它就完成了这段解码 不需要继续分辨了 因为这里什么都没有 没有歧义 这是非常重要的 霍夫曼码在构建时 我们这样一次又一次地进行分裂 它的构建过程 就决定了它是无前缀编码 那么 如何得知它是最优编码方法呢？ 如何得知利用这组概率 以及我刚刚解释的那个过程 就能达到最短的编码平均长度呢？ 这个定理有待证明 在这节课上我们不会涉及到这个证明 但是有一个定理 能够证明霍夫曼编码可以达到最短的长度 现在 你可能会好奇霍夫曼编码 或者其它类似的编码器 能达到的长度是多少 所以基本的思想是 当面对一组概率时 能够在多大程度上对其进行压缩？ 在构建霍夫曼码之前 我们想要知道 这值不值得我们花费精力去构建这种编码？ 可以压缩很多吗？ 而这就要通过计算熵来得到答案 熵使用符号 H 来表示 H 就是指熵 熵是 所有符号的概率乘以该概率以2为底的对数 对所有乘积求和 再取负数 关于这个负号 我等一下会解释 所以在这里就是 0.4 乘以 0.4以2为底的对数 加上0.3乘以 0.3以2为底的对数 依次类推 所以实际上最终得到的是一个正数 因为所有概率都是小于1的 所以概率的对数是负数 加上这个负号 就会得到正数 香农第一定理就是在说 我们可以渐渐逼近这个平均编码长度 也就是像霍夫曼编码这类编码方式所能达到的 (最短长度) 可以来算算这个数 从而得到编码的平均长度 也就是理想的平均码长 实际上这个公式并不难理解 之前的例子用过类似的计算 这个概率就是符号出现的概率 而这是这个符号对应的编码长度 这就是说 理想的编码长度就是这个概率的对数 之所以是理想值是因为 编码长度不能是3.2 而只能发送完整的比特数 或者发送 3比特 或者发送 4比特 这就是为什么 它是平均期望值 也即是编码长度的理想值 但是这能帮助你理解霍夫曼编码的编码能力 现在大家已经知道如何用比特进行编码 我们要开始进入图像压缩的下一个模块了 //果壳教育无边界字幕组 | 冰之冷 | 某音某莹 | 林小七Lynn | 小白_远游