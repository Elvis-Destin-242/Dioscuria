WEBVTT

1
00:00:00.000 --> 00:00:04.776
我们现在要讲解建立图像压缩算法的每一个环节 

2
00:00:04.776 --> 00:00:07.810
而且会特别详细讲解静态图像压缩标准 (JPEG) 

3
00:00:07.810 --> 00:00:11.554
之前也提到过 我们将从符号编码器讲起 

4
00:00:11.554 --> 00:00:16.266
我们会对图像数据做变换和量化 这些环节在后续课程会详细讲解 

5
00:00:16.266 --> 00:00:21.108
在完成所有变换和量化之后 我们希望进一步压缩图像 

6
00:00:21.108 --> 00:00:25.626
量化会提供一定程度的压缩 但我们仍希望进一步压缩 

7
00:00:25.626 --> 00:00:28.596
我们需要存储量化后的数据 

8
00:00:28.596 --> 00:00:31.590
我们需要保证精确无误地存储 

9
00:00:31.590 --> 00:00:34.797
但是也需要思考如何进行压缩 

10
00:00:34.797 --> 00:00:38.770
那么 为什么能做到这些呢?  其基本思想很简单 

11
00:00:38.770 --> 00:00:44.080
当然 如果不至少先给大家看一次这张叫 Lena 的非常著名的图片 

12
00:00:44.080 --> 00:00:47.609
那就不算是教过图像处理 

13
00:00:47.609 --> 00:00:51.279
在图像处理中 经常用到这张图片 

14
00:00:51.279 --> 00:00:56.417
但现如今 由于我们拥有丰富的图像资源 也会使用许多其它图像 

15
00:00:56.417 --> 00:01:00.821
不过我还是想在这九周中至少给大家展示一次这张图片 

16
00:01:00.821 --> 00:01:04.858
而且在以后的课程中我们可能还会多次见到它 

17
00:01:04.858 --> 00:01:10.804
基本思路是这样的 图像中的一些像素 一些灰度值出现的次数多于其它灰度值 

18
00:01:10.804 --> 00:01:13.080
我们来看看这个现象 

19
00:01:13.080 --> 00:01:16.640
在右边 有一幅直方图   

20
00:01:16.640 --> 00:01:22.272
直方图记录每一特定的灰度值在图像中出现的次数 

21
00:01:22.272 --> 00:01:25.609
比如说 某一像素的灰度值 

22
00:01:25.609 --> 00:01:30.198
假设灰度值大约是47 它出现了这么多次 

23
00:01:30.198 --> 00:01:35.692
我们遍历整幅图像 计算有多少灰度值为47的像素点 

24
00:01:35.692 --> 00:01:39.933
这就是它出现的次数 我们继续看下一个灰度值 比如说200 

25
00:01:39.933 --> 00:01:44.940
我们看到 灰度值200在这幅图中大约出现了700次 

26
00:01:44.940 --> 00:01:49.978
我们可以看到有些像素值出现了许多次 

27
00:01:49.978 --> 00:01:52.726
而另一些像素值 比如 0或1 根本就没有出现过 

28
00:01:52.726 --> 00:01:57.568
因此 我们要采用的方法的基本思路是 

29
00:01:57.568 --> 00:02:02.410
给出现次数很多的像素值一个非常简短的编码 

30
00:02:02.410 --> 00:02:07.579
而给出现次数较少的像素值很长的 或者说相对较长的编码 

31
00:02:07.579 --> 00:02:10.480
下面来看看具体如何编码 

32
00:02:10.480 --> 00:02:16.003
下面来看一个应用上述方法的例子 这里是一个图像 

33
00:02:16.003 --> 00:02:20.429
这正是大家在前面视频中见过的那个几何图像 

34
00:02:20.429 --> 00:02:25.352
这是比较特殊的图像 它只有四个不同的灰度值 

35
00:02:25.352 --> 00:02:32.043
而灰度值为87的像素占了整个图像的四分之一 

36
00:02:32.043 --> 00:02:37.518
即 25% 或者说 灰度值47 出现的概率是 0.25 

37
00:02:37.518 --> 00:02:44.035
同时灰度值为128的像素几乎占了图像的一半 

38
00:02:44.035 --> 00:02:50.813
这里是灰度值186 而 255 出现的次数极少 

39
00:02:50.813 --> 00:02:55.910
其它的灰度值并没有出现 所以表示这个图像的标准方式是 

40
00:02:55.910 --> 00:03:01.629
用到了数组 对于每一个像素 使用八位二进制码表示其像素值 

41
00:03:01.629 --> 00:03:04.815
所以 我们用87的二进制码来表示灰度值87 

42
00:03:04.815 --> 00:03:10.172
用128的二进制码来表示灰度值128 

43
00:03:10.172 --> 00:03:15.963
以此类推 所以在最后 如果我们不进行压缩 

44
00:03:15.963 --> 00:03:19.717
那每个像素要占 8比特 

45
00:03:19.717 --> 00:03:27.063
但是现在来假设一下 如果我想办法构造了如图所示的编码 

46
00:03:27.063 --> 00:03:31.738
其中 87是用二进制码01来表示的 

47
00:03:31.738 --> 00:03:37.373
128 用二进制码1 来表示 

48
00:03:37.373 --> 00:03:42.462
186用二进制码000表示 而255用二进制码001 

49
00:03:42.462 --> 00:03:47.330
这就意味着 比如说 

50
00:03:47.330 --> 00:03:52.640
如果想要存储或发送 87、87、255、128 

51
00:03:52.640 --> 00:03:55.101
这几个像素值 

52
00:03:55.101 --> 00:04:02.608
并不是用这些二进制码 然后是这个 而是用这个表示255 这些来表示128 

53
00:04:02.608 --> 00:04:10.320
这种表示方式需要 4乘以8 也就是32比特位 不如我们用以下这种方式来表示 

54
00:04:10.320 --> 00:04:13.714
我会假设 

55
00:04:13.714 --> 00:04:18.260
87用01来表示 87还用01来表示 

56
00:04:18.260 --> 00:04:21.346
255用001来表示 

57
00:04:21.346 --> 00:04:27.607
128用1来表示 所以这里需要2 4 7 

58
00:04:27.607 --> 00:04:35.310
一共8比特 而不是32比特 来表示同一组灰度值 

59
00:04:35.310 --> 00:04:42.313
现在 解码器会根据这个表格解码 所以解码器看到01时 

60
00:04:42.313 --> 00:04:48.201
会在这个像素的位置输出 87 看到01 再次输出 87 

61
00:04:48.201 --> 00:04:53.159
然后发现 001 这里要输出255 等等 

62
00:04:53.159 --> 00:04:59.435
如此就完成了压缩 现在来看看这到底压缩了多少 

63
00:04:59.435 --> 00:05:02.921
我们来做一个非常简单的计算 

64
00:05:02.921 --> 00:05:06.485
我们来看一看 

65
00:05:06.485 --> 00:05:08.460
抱歉 

66
00:05:10.120 --> 00:05:22.080
我们有0.25的概率 

67
00:05:22.080 --> 00:05:27.625
需要用到长度为2的二进制码01 

68
00:05:27.625 --> 00:05:36.189
有0.47的概率 使用长度是1的二进制码 这里加上0.47乘以1 

69
00:05:36.189 --> 00:05:45.301
有0.25的概率 也就是四分之一的图像中 我们要用到长度为3的二进制码 

70
00:05:45.301 --> 00:05:55.326
最后是很小的概率 

71
00:05:55.326 --> 00:06:04.217
同样用到长度为3的二进制码 结果等于1.81 

72
00:06:04.217 --> 00:06:10.240
好了 

73
00:06:10.240 --> 00:06:18.187
所以现在整个图像中平均每个像素只占1.81比特 而不是之前的8比特 

74
00:06:18.187 --> 00:06:26.443
这里省了很多像素 从8减到了1.81 

75
00:06:26.443 --> 00:06:29.526
也就是说 压缩了四倍以上 

76
00:06:29.526 --> 00:06:32.648
这就是我们刚刚做的 

77
00:06:32.648 --> 00:06:37.850
刚刚我们利用了一些像素值的出现次数远比另一些多的现象 

78
00:06:37.850 --> 00:06:43.053
然后用更短的编码来表示这些像素值 

79
00:06:43.053 --> 00:06:47.214
这里用了更短的编码 那么 怎么才能做到这一点呢 

80
00:06:47.214 --> 00:06:51.931
这里我们用到了霍夫曼编码 接下来我会解释怎么运用这种编码 

81
00:06:51.931 --> 00:06:55.778
再看看这个例子 

82
00:06:55.778 --> 00:07:01.335
解释霍夫曼编码最好的办法是举个例子 

83
00:07:01.335 --> 00:07:06.380
接下来我要用这个例子说明 现在假设我们用五个不同的符号 

84
00:07:06.380 --> 00:07:09.743
抱歉 是六个不同的符号 

85
00:07:09.743 --> 00:07:15.455
第一步 按概率大小排列这些符号 

86
00:07:15.455 --> 00:07:19.654
概率从高到低 

87
00:07:19.654 --> 00:07:24.737
如果有些概率相同 

88
00:07:24.737 --> 00:07:30.410
那么无所谓谁先谁后 比如说 a2可能代表像素值100 

89
00:07:30.410 --> 00:07:34.830
符号 a6 可能代表像素值77 等等 

90
00:07:34.830 --> 00:07:37.040
现在我会做一些加法 

91
00:07:37.040 --> 00:07:42.860
先把符号列在这里 把概率列在这里 

92
00:07:42.860 --> 00:07:47.060
然后从下往上 取最底下的两个数 

93
00:07:47.060 --> 00:07:53.943
把它们的概率相加 用0.04加上0.06 

94
00:07:53.943 --> 00:07:58.213
得到了0.1的概率 然后将这一列概率重新排列一遍 

95
00:07:58.213 --> 00:08:04.400
这些都没有变 唯一改变了的是最后一个 

96
00:08:04.400 --> 00:08:09.280
看看这里的变化 0.4的概率对应于a2 

97
00:08:09.280 --> 00:08:16.600
0.3的概率指向a6 0.1的概率指向a1 

98
00:08:16.600 --> 00:08:20.603
0.1的概率指向 符号 a4 

99
00:08:20.603 --> 00:08:25.229
而最后一个概率0.1对应a3或a5 

100
00:08:25.229 --> 00:08:31.013
我们要用一些办法来区分 a3和a5 

101
00:08:31.013 --> 00:08:36.440
下一张幻灯片会解释如何区分它们 

102
00:08:36.440 --> 00:08:38.834
现在 重复一下刚才的步骤 

103
00:08:38.834 --> 00:08:42.343
将最低的两个值相加 

104
00:08:42.343 --> 00:08:47.840
现在 这个值是0.2 记住每次都要重新排序 

105
00:08:47.840 --> 00:08:52.951
让我再解释一下 概率0.4对应a2 

106
00:08:52.951 --> 00:08:58.155
0.3对应a6 而现在 0.2对应这两个概率值 

107
00:08:58.155 --> 00:09:00.984
也就是 a4、a3还有a5 

108
00:09:00.984 --> 00:09:07.192
我们现在还不能确定是哪个符号 但是0.2的概率对应着其中一个 

109
00:09:07.192 --> 00:09:12.304
然后这里是0.1 重复刚才的步骤 再重复一次 

110
00:09:12.304 --> 00:09:16.594
实际上 还需要重复两次 我们得到这两个最小值 

111
00:09:16.594 --> 00:09:21.410
算出这个值 再把它和最小的值相加 然后得到这个值 

112
00:09:21.410 --> 00:09:26.393
继续重复 每一次我们都将最小的两个值相加得到下一列概率值 

113
00:09:26.393 --> 00:09:32.020
并且重新排序 直到只剩下两个数 

114
00:09:32.020 --> 00:09:37.826
然后来看看为什么在这里停下 下面我们来进行编码 

115
00:09:37.826 --> 00:09:46.657
这是依据前一幻灯片中图表的一个重绘 

116
00:09:46.657 --> 00:09:51.478
这是第一列 

117
00:09:51.478 --> 00:09:57.544
这是第二列 第三列 第四列 和第五列 

118
00:09:57.544 --> 00:10:01.199
现在 从后往前 依次赋值编码 

119
00:10:01.199 --> 00:10:05.895
给0.6赋上0 给0.4赋上1 

120
00:10:05.895 --> 00:10:10.125
在继续往回推进之前 我来解释一下这里是怎么回事 

121
00:10:10.125 --> 00:10:15.562
当解码器看到0 它会明白这是从 0.6对应的这一组来的 

122
00:10:15.562 --> 00:10:20.622
当它看到一个 1 

123
00:10:20.622 --> 00:10:24.851
就会知道是 0.4对应的这一组 

124
00:10:24.851 --> 00:10:30.440
然后要添加更多的比特位来区分每组中的各个数值 

125
00:10:30.440 --> 00:10:36.760
这就是为什么要从后往前走 把这个 0 抄送到这里来 

126
00:10:36.760 --> 00:10:42.417
这个0.6是由 0.3加0.3 得来的 

127
00:10:42.417 --> 00:10:49.958
所以要在后面分别加上0和1 当然我们要把 0.4抄送到这里 

128
00:10:49.958 --> 00:10:56.132
给它赋上从上一列得来的码值 这里不用加任何数字 

129
00:10:56.132 --> 00:11:00.107
所以它会一直不加任何比特位被抄送到前面 

130
00:11:00.107 --> 00:11:04.420
现在 要找到与这组对应的所有符号 

131
00:11:04.420 --> 00:11:09.580
而这里 我们会看到 其实只有一个符号对应于这个组 

132
00:11:09.580 --> 00:11:16.843
现在有了这个编码和所有指向这个概率的符号 

133
00:11:16.843 --> 00:11:22.732
这里的编码是从 01 开始的 

134
00:11:22.732 --> 00:11:29.211
现在继续往前抄送 将 1 抄送到这里 为1 

135
00:11:29.211 --> 00:11:33.824
00 抄送为00 而01需要被分开因为这个0.3的概率 

136
00:11:33.824 --> 00:11:38.536
是由这两个相加得到的 

137
00:11:38.536 --> 00:11:43.126
接着就变成了010和011 然后继续 

138
00:11:43.126 --> 00:11:50.789
把1抄送过来 0抄送过来 这个011的编码抄送到这里 

139
00:11:50.789 --> 00:11:56.293
而这个要分开 

140
00:11:56.293 --> 00:12:02.135
每次之所以要把它分开 是因为之前在算它的时候是相加得到的 

141
00:12:02.135 --> 00:12:05.776
然后回到这里 这里要分开 

142
00:12:05.776 --> 00:12:10.518
每次分开的时候 都要加上0和1 

143
00:12:10.518 --> 00:12:17.037
所以一直继续 就得到了这个结果 

144
00:12:17.037 --> 00:12:23.426
也就是第一个符号的编码是1 符号a6的编码是00 以此类推 

145
00:12:23.426 --> 00:12:25.684
所以这就是它们的编码 

146
00:12:25.684 --> 00:12:30.803
这些是变长编码 用来表示各个符号的编码长度并不完全一样 

147
00:12:30.803 --> 00:12:35.169
各个编码是有不同长度的 

148
00:12:35.169 --> 00:12:40.965
而这个长度取决于概率 概率越大 编码越短 

149
00:12:40.965 --> 00:12:44.653
这很容易看出 

150
00:12:44.653 --> 00:12:50.148
因为低概率值在不断被相加 

151
00:12:50.148 --> 00:12:53.160
当往回推导的时候 就要不断分开 

152
00:12:53.160 --> 00:12:58.769
记住 每次分开的时候都要加一个符号 因此要为这个符号加一个比特位 

153
00:12:58.769 --> 00:13:03.493
所以 编码变得越来越长 

154
00:13:03.493 --> 00:13:07.115
这里也可以算出编码的平均长度 

155
00:13:07.115 --> 00:13:12.704
回顾一下之前的步骤 

156
00:13:12.704 --> 00:13:16.352
按照概率排列符号的顺序 

157
00:13:16.352 --> 00:13:20.855
这是这一步做的 然后开始把低概率相加 

158
00:13:20.855 --> 00:13:25.590
将这两个相加 就得到了这个 重新排列然后继续 

159
00:13:25.590 --> 00:13:31.645
这是一个递归的过程 所以如果知道了怎么从一列进行到下一列 

160
00:13:31.645 --> 00:13:36.040
就知道了怎么完成它 然后回来看这个 

161
00:13:36.040 --> 00:13:41.763
这里有几件非常重要的事情要注意 

162
00:13:41.763 --> 00:13:47.067
用这种方法得到的编码叫做无前缀编码 

163
00:13:47.067 --> 00:13:51.360
这是非常 非常重要的 来看这一列 

164
00:13:51.360 --> 00:13:59.148
当这里有一个1 解码器看到一个1 它就知道要到这里找到a2 

165
00:13:59.148 --> 00:14:03.247
当这里有一个0 这就是在说 

166
00:14:03.247 --> 00:14:10.170
好吧 我要等着看下一个符号是什么 

167
00:14:10.170 --> 00:14:16.299
但是没有任何一段码字完全是其它编码的前缀 这是非常重要的 

168
00:14:16.299 --> 00:14:22.851
不然解码器是无法重建图像的 看看下面这个例子 

169
00:14:22.851 --> 00:14:27.302
这里的码字会是前缀 比如 符号a1是用 码字1表示的 

170
00:14:27.302 --> 00:14:33.854
符号 a2 是用 码字0 表示的 

171
00:14:33.854 --> 00:14:37.550
符号a3 是用 码字01 表示的 

172
00:14:37.550 --> 00:14:44.000
当解码器看到01 

173
00:14:44.000 --> 00:14:49.060
会出现两种可能 一种可能是a3 

174
00:14:49.060 --> 00:14:57.955
假设它对应的像素值是100 另一种可能是 a2后面跟着a1 

175
00:14:57.955 --> 00:15:04.891
假设像素是0和255 因此重建过程就出现了很大的歧义 

176
00:15:04.891 --> 00:15:09.167
无法分辨到底是哪一个 

177
00:15:09.167 --> 00:15:15.533
因为这个编码并不是无前缀编码 

178
00:15:15.533 --> 00:15:21.044
这个是这个的子集 而在这里就不会发生这种情况 

179
00:15:21.044 --> 00:15:27.847
现在把这些注释都清除 

180
00:15:27.847 --> 00:15:33.052
这里没有任何一个编码有所重复 比如说00 

181
00:15:33.052 --> 00:15:38.059
因此 当解码器看到了一个1 就知道怎么办 

182
00:15:38.059 --> 00:15:43.000
它会找到a2的像素值 当它看到一个0 

183
00:15:43.000 --> 00:15:49.364
它需要继续分辨 因为这里很多码字都是以 0 开头的 

184
00:15:49.364 --> 00:15:53.374
如果它看到有一个0 之后跟着一个0 

185
00:15:53.374 --> 00:16:00.697
它会完成这段码字的解码 并得到a6 

186
00:16:00.697 --> 00:16:07.410
如果解码器收到了一个0 然后跟着一个1 它还需要继续分辨 

187
00:16:07.410 --> 00:16:11.391
因为有很多码字都是以01开头的 但是之后 如果又接收到了一个1 

188
00:16:11.391 --> 00:16:14.795
它就完成了这段解码 不需要继续分辨了 

189
00:16:14.795 --> 00:16:18.799
因为这里什么都没有 没有歧义 

190
00:16:18.799 --> 00:16:22.603
这是非常重要的 霍夫曼码在构建时 

191
00:16:22.603 --> 00:16:25.806
我们这样一次又一次地进行分裂 

192
00:16:25.806 --> 00:16:29.010
它的构建过程 就决定了它是无前缀编码 

193
00:16:29.010 --> 00:16:33.189
那么 如何得知它是最优编码方法呢？ 

194
00:16:33.189 --> 00:16:37.630
如何得知利用这组概率 

195
00:16:37.630 --> 00:16:43.450
以及我刚刚解释的那个过程 

196
00:16:43.450 --> 00:16:48.746
就能达到最短的编码平均长度呢？ 

197
00:16:48.746 --> 00:16:52.011
这个定理有待证明 

198
00:16:52.011 --> 00:16:57.670
在这节课上我们不会涉及到这个证明 但是有一个定理 

199
00:16:57.670 --> 00:17:02.314
能够证明霍夫曼编码可以达到最短的长度 

200
00:17:02.314 --> 00:17:07.973
现在 你可能会好奇霍夫曼编码 或者其它类似的编码器 

201
00:17:07.973 --> 00:17:12.616
能达到的长度是多少 所以基本的思想是 

202
00:17:12.616 --> 00:17:15.570
 当面对一组概率时 能够在多大程度上对其进行压缩？  

203
00:17:15.570 --> 00:17:21.234
在构建霍夫曼码之前 我们想要知道 

204
00:17:21.234 --> 00:17:25.393
这值不值得我们花费精力去构建这种编码？ 可以压缩很多吗？ 

205
00:17:25.393 --> 00:17:30.699
而这就要通过计算熵来得到答案 

206
00:17:30.699 --> 00:17:33.080
熵使用符号 H 来表示 

207
00:17:33.080 --> 00:17:36.597
H 就是指熵 

208
00:17:36.597 --> 00:17:55.713
熵是 所有符号的概率乘以该概率以2为底的对数 对所有乘积求和 再取负数 

209
00:17:55.713 --> 00:18:05.254
关于这个负号 我等一下会解释 

210
00:18:05.254 --> 00:18:12.061
所以在这里就是 0.4 乘以 0.4以2为底的对数 

211
00:18:12.061 --> 00:18:18.763
加上0.3乘以 0.3以2为底的对数 依次类推 

212
00:18:18.763 --> 00:18:24.409
所以实际上最终得到的是一个正数 

213
00:18:24.409 --> 00:18:30.886
因为所有概率都是小于1的 所以概率的对数是负数 

214
00:18:30.886 --> 00:18:34.788
加上这个负号 就会得到正数 

215
00:18:34.788 --> 00:18:40.850
香农第一定理就是在说 

216
00:18:40.850 --> 00:18:45.350
我们可以渐渐逼近这个平均编码长度 

217
00:18:45.350 --> 00:18:51.439
也就是像霍夫曼编码这类编码方式所能达到的 (最短长度) 

218
00:18:51.439 --> 00:18:56.452
可以来算算这个数 

219
00:18:56.452 --> 00:19:00.310
从而得到编码的平均长度 

220
00:19:00.310 --> 00:19:05.556
也就是理想的平均码长 

221
00:19:05.556 --> 00:19:10.952
实际上这个公式并不难理解 

222
00:19:10.952 --> 00:19:14.662
之前的例子用过类似的计算 

223
00:19:14.662 --> 00:19:19.892
这个概率就是符号出现的概率 

224
00:19:19.892 --> 00:19:23.840
而这是这个符号对应的编码长度 

225
00:19:23.840 --> 00:19:30.937
这就是说 理想的编码长度就是这个概率的对数 

226
00:19:30.937 --> 00:19:36.530
之所以是理想值是因为 

227
00:19:36.530 --> 00:19:42.461
编码长度不能是3.2 而只能发送完整的比特数 

228
00:19:42.461 --> 00:19:46.614
或者发送 3比特 或者发送 4比特 

229
00:19:46.614 --> 00:19:51.189
这就是为什么 它是平均期望值 

230
00:19:51.189 --> 00:19:57.911
也即是编码长度的理想值 

231
00:19:57.911 --> 00:20:01.850
 但是这能帮助你理解霍夫曼编码的编码能力  

232
00:20:01.850 --> 00:20:07.665
现在大家已经知道如何用比特进行编码 

233
00:20:07.665 --> 00:20:11.245
我们要开始进入图像压缩的下一个模块了
//果壳教育无边界字幕组 | 冰之冷 | 某音某莹 | 林小七Lynn | 小白_远游