WEBVTT

1
00:00:00.000 --> 00:00:06.566
通过一个例子 我们现在已经完成了基于霍夫曼编码的简单编码 

2
00:00:06.566 --> 00:00:12.895
 这是图像压缩的后端步骤 接下来让我们看看图像压缩的前端  

3
00:00:12.895 --> 00:00:17.958
在这个视频中我们将要讲述的是这一部分 

4
00:00:17.958 --> 00:00:23.022
那么让我们从这个部分开始 

5
00:00:23.022 --> 00:00:30.240
现在我们有一张图片 一个粗略的想法是 JPEG   

6
00:00:30.240 --> 00:00:38.140
或者有损变换编解码压缩 做的是把图片分成一些小块 

7
00:00:38.140 --> 00:00:45.360
每一个小块有 n x n 个像素点 我们要讲的是 

8
00:00:45.360 --> 00:00:50.661
用一个例子来讲解 n 值是什么 但我们先了解一点 

9
00:00:50.661 --> 00:00:55.105
就是 JPEG 使用的是 8 x 8 的小块 

10
00:00:55.105 --> 00:00:59.609
所以 JPEG几乎是将一幅图像中的每个 8 x 8 小块独立编码 

11
00:00:59.609 --> 00:01:06.032
小块都是不重叠的 所以这是8个像素 接着8个 接着8个 

12
00:01:06.032 --> 00:01:06.950
接着8个 好 

13
00:01:06.950 --> 00:01:11.239
然后全部都是这样 并且也有方法来处理 

14
00:01:11.239 --> 00:01:15.037
如果图片的宽度或者长度不是8的倍数的情况 

15
00:01:15.037 --> 00:01:17.920
所以现在不用担心这个 

16
00:01:17.920 --> 00:01:22.914
这些只是技术细节 我们取其中一个 n x n 的小块 

17
00:01:22.914 --> 00:01:27.344
接下来我们将要对每一个这样的 n x n  8 x 8 的小块编码 

18
00:01:27.344 --> 00:01:30.931
并且我之前讲过 编码的时候它们几乎是独立的 

19
00:01:30.931 --> 00:01:36.557
这就是要对一张图片做的事 但是这只是针对黑白图片 

20
00:01:36.557 --> 00:01:41.249
如果是一张RGB图片怎么办呢 

21
00:01:41.249 --> 00:01:47.657
JPEG 其实是个色盲 JPEG 不知道如何处理色彩 

22
00:01:47.657 --> 00:01:53.080
它本身不理解颜色标准 但是我们可以想一下怎么来处理这个问题 

23
00:01:53.080 --> 00:01:56.977
最原始的一个想法是 首先把红色通道取出来 

24
00:01:56.977 --> 00:02:01.163
因为每一个通道都是一个二维像素阵列 

25
00:02:01.163 --> 00:02:05.781
于是红色通道看起来是这样的 我们将红色通道分成 8 x 8 的小块 

26
00:02:05.781 --> 00:02:10.039
之后对红色通道编码 然后对绿色通道做同样的处理 

27
00:02:10.039 --> 00:02:14.514
最后对蓝色通道做同样的处理 看起来这个方法非常合理 

28
00:02:14.514 --> 00:02:19.411
但是实际情况是 通道之间有很多相关性 

29
00:02:19.411 --> 00:02:23.919
所以 JPEG 做的是 

30
00:02:23.919 --> 00:02:28.920
它不对RGB编码 而是处理一种叫YCbCr的色彩空间 

31
00:02:28.920 --> 00:02:32.277
接下来我就来告诉大家怎么做这个 

32
00:02:32.277 --> 00:02:35.940
但是在这里 

33
00:02:35.940 --> 00:02:39.756
我们有Y、Cb和Cr三个通道 而不是RGB三个通道 

34
00:02:39.756 --> 00:02:45.784
这个是亮度通道 (luminance channel) 这就是大家 

35
00:02:45.784 --> 00:02:49.447
在黑白电视机和黑白显示器上见到的通道 

36
00:02:49.447 --> 00:02:55.476
我们有一张彩色图片 但是只能看到黑白的部分 

37
00:02:55.476 --> 00:03:00.700
也就是它的亮度部分 这些是色彩通道 

38
00:03:00.700 --> 00:03:04.153
好 这是一个简单的转换 

39
00:03:04.153 --> 00:03:08.280
实际上是通过乘以一个 3 x 3 的矩阵来实现的 

40
00:03:09.340 --> 00:03:14.000
我们把Y Cb Cr列成一列 

41
00:03:14.000 --> 00:03:25.326
这里是一个 3 x 3 的矩阵 

42
00:03:25.326 --> 00:03:31.935
这是 R G B的值 

43
00:03:31.935 --> 00:03:38.760
所以Y是R G B的一个线性组合 Cbr也是一个线性组合 

44
00:03:38.760 --> 00:03:45.754
Cb是一个线性组合 Cr是另一个线性组合 这个矩阵是可逆的 

45
00:03:45.754 --> 00:03:53.202
所以在对YCbCr解码时 将它们乘以这个矩阵的逆矩阵 

46
00:03:53.202 --> 00:03:57.925
就能回到R G B值了 JPEG最开始会做的事 

47
00:03:57.925 --> 00:04:05.010
是将彩色图片的每一个像素乘上一个矩阵 

48
00:04:05.010 --> 00:04:09.672
比如 100、150、200 乘上这里的这些系数 

49
00:04:09.672 --> 00:04:14.271
这是一个常数矩阵 这个矩阵非常有名 

50
00:04:14.271 --> 00:04:20.584
它在很多地方都有出现 如果用 谷歌 (Google) 搜索 YCbCr 

51
00:04:20.584 --> 00:04:25.219
就能够知道这个矩阵的确切数值 这样对图像的每一个像素点都进行处理 

52
00:04:25.219 --> 00:04:31.297
把红绿蓝 (RGB) 阵列转换成 YCbCr 阵列 

53
00:04:31.297 --> 00:04:38.168
我再重复一次 这仍然是所有像素点的一个二维阵列 不过已经从RGB 

54
00:04:38.168 --> 00:04:42.308
转换成了YCbCr的二维矩阵 有了这些 接下来就是 

55
00:04:42.308 --> 00:04:46.360
对其中的每一个阵列分别进行编码 

56
00:04:46.360 --> 00:04:50.020
让我们来看看Y通道 先处理Y通道 

57
00:04:50.020 --> 00:04:54.780
将其分成 8 x 8 的小块 

58
00:04:54.780 --> 00:04:59.932
好 我们要做的就是这些 接下来把每一个 8 x 8 小块取出来 

59
00:04:59.932 --> 00:05:03.814
将它们分别编码 

60
00:05:03.814 --> 00:05:08.613
如前所述 几乎独立地编码 但是为了更好地讲解它 

61
00:05:08.613 --> 00:05:11.436
我们将其认为是独立的 

62
00:05:11.436 --> 00:05:15.530
接着要将很多 8 x 8 的小图片编码 

63
00:05:15.530 --> 00:05:19.835
接下来它将怎么做呢 接下来要做的是一个离散余弦变换 (DCT) 

64
00:05:19.835 --> 00:05:23.932
一个变换 然后是量化 

65
00:05:23.932 --> 00:05:27.752
然后是符号编码 就像我们已经见过很多次的那个 JPEG 流程图表示的那样 

66
00:05:27.752 --> 00:05:31.572
现在我们有了这个 8 x 8 的小块 

67
00:05:31.572 --> 00:05:37.058
现在我们需要关注的是我们有的这些 8 x 8 的图像 

68
00:05:37.058 --> 00:05:37.475
//果壳教育无边界字幕组 | ctzsm |  leafsherry | 小白_远游