我们现在可以开始描述会引起误差的主要步骤 那就是量化 我要指出 这也是进行很大压缩的一步 没有量化 我们不可能做到很大压缩 我们可以做压缩 但是不会像在数码相机里看到的那么多 基本上我们采用了之前见过的正变换 这个之前已经见过了 但是现在我们将要描述量化 让我们先说这个 实际上我们之前就已经见过 量化 就在本课刚开始几个星期的时候 那么我们要在 JPEG 压缩的过程中 详细讲解量化 所以请记住 我们是从一个 8 x 8 图像开始的 而且我们已经将它进行变换了 我将要在这里展示变换系数 在之前的视频中 我们实际上已经见过变换系数了 我们用二重求和得到变换系数 通过沿X轴求和 再沿Y轴求和 即沿图像的坐标轴进行求和 我们将图片“加”起来 这个是图片 接着我们有余弦基函数 这就是如何得到展示在这里的这些系数的 我们由一个 8 x 8 的图像得到了一个 8 x 8 的系数矩阵 所以我们在不同的域 在余弦域得到了一幅图像 我们现在可以对这些系数做不同的事情 接着我们就要对系数做一定的工作了 举个例子 我们只需要 取这里的系数 忽略其他的系数 非常非常地简单 我们可以到左上角 然后只使用这些系数 忽略掉其他的 我将马上写出这代表着什么 我们也可以这样做 以这样的方式 取用系数 这些带阴影或者说值为1的系数是 将要传输的系数 那些值为0或者说没有阴影的系数 是不准备传输或存储下来的 我们还可以做一些其它处理 我们会想 我并不想计入或者丢弃系数 我们要做的是把系数取到这里来并且用8位比特数表示它 这样它的量化级数就为 256 另一方面 这里的这个系数 也就是系数 T(0,7) 我想只用 1个比特位来表示它 所以我们将只能用两个不同级别来表示这个系数 接下来我们要说的就是这个 假如我们现在开始量化 会发生什么？ 请记住 f(x,y) 接着将要被重建 就像我们在之前的视频中看到的那样 f(x,y)是T(u,v)求和得到的 T(u,v) 就是变换系数 我们可以在这里使用 r 因为我们知道正变换和反变换是一样的 我们就是这样重构图像的 现在假如我们要量化T 而不是重构f 因为我们会有 一个 T(u,v) 的近似值 接着我们需要重构出 f(x,y) 的近似值 请记住这里会发生变化 我们所得到的的 f(x,y) 是系数的一个线性组合 这个系数要么是原始系数 要么是量化后的系数 也就是乘了基函数的线性组合 这些就是所谓的基函数 我在这里把它们弄成了 4 x 4 的图像块 但是我们知道所讨论的是 8 x 8 的图像 所以这个顶部的系数主要是用来说明 我们接着要使用多少这些基函数 可以这样说 或许我们的视觉感知是 假如本来我要使用 7.7乘以这些基函数 或许我最后只乘以了7.5 却不会有很大影响 而且我的视觉系统 不会察觉到有什么不同 这就是量化的思想 量化主要思想是数值修约 或者说 如果让这个分量里的值稍稍变化一点 无论T(u,v)这部分代表的是什么 在重构时都不会产生太大影响 一会儿我们就会看到 现在大家还记得我们为什么要做量化吗？ 我们要做量化是因为之后要进行霍夫曼编码 请记住一点 在霍夫曼编码里 我们需要非均匀分布 一些系数会出现很多次 所以我们将对其进行短编码 而一些系数出现次数并不多 那我们就给它们进行长编码 举个例子 如果我们量化得很多 我们也许发现7、8、9、10都会变成0 然后我们就能压缩很多 在接下来的幻灯片中可以看到一些更多的例子 这个式子就是量化的基本思想 正如我所说 我们准备开始量化了 我们需要改变一些系数 希望能够不被注意到 现在我要提醒大家注意的是 有些可以在JPEG里巧妙地得到的东西 如果只是去做量化 我们仍然需要 传输一个量化后的8x8变换值矩阵 这意味着 我们需要传输64个数 现在我们有一个 每像素8比特 256个灰度级的图片 接着我们需要传输这里的每一个值 即使像这样只用一个比特 所以我们从8比特开始 然后只使用1比特 以8比1压缩 我们只要传输那个值就可以了 JPEG很巧妙地表示了一些东西 接下来我们要看到的是 顶部区域将使用这里的代替值 比特数越多 量化效果就越好 在这里的底角部分 JPEG将会表示出… 我将要做一些非常非常剧烈的量化 实在是太剧烈了 导致T(u,v)中的很多系数 都会变成0 所以JPEG并不用来编码 它不是先存这个T(u,v) 再存这个 接着这个 它实际上是按照锯齿形的方式来进行的 这意味着 好吧 首先我们做个约定 在这里看到的第一个系数是T(0,0) 第二个系数是T(0,1) 第三个系数是T(1,0) 对吧？ 所以你要做的是编码量化后的(0,0) 再编码量化后的(0,1) 再编码量化后的(1,0) 然后就这样按照锯齿形的方式往下进行 为什么这么做很重要？ 正如我之前说的 这里的很多值都会变成0 在我们做了很强的量化以后 它们的值都会变成0 所以当JPEG进行到某一个系数的时候 发现后续其他所有系数 都变成了0 我们只需用一个信号来表明结束 假如这第n个数在这里 就代表着这里的所有数都是0 那我们就能省下很多比特 它还是按照每个比特来传输 比方说 用0、0、0来表示 本质上是在表示结束 这意味着这一块结束了 这个8x8传输系数矩阵结束了 所有系数都变成了0 这确实很巧妙 通过这个可以让我们达到超过8比1的压缩比 甚至是非常非常高的压缩比 而且这个区域量化的越多 这个结束符号出现的越早 所以这就是量化的基本思想 让我们来看一下如何做到的 量化的一个非常简单的方式是 像这样的均匀量化 这也是JPEG主要所做的工作 这就是说 取了系数以后 需要做均匀量化 在某种意义上来说 举个例子 这个区间
在 9 分 8 秒处开始记录9:08
所有落在这里面的数 每个值落在这一点和这一点之间的系数 都可以用它来表示 这就很重要了 现在我们要开始哈夫曼编码 无论是多少 都得用一个数来代替 我们主要做的是增大那个数出现的概率 我们会把有很多出现次数很少的数 替换为一个出现很多次的数 就像我们知道的那样 这对于压缩最后的哈夫曼编码或者其他任何编码器来说都很重要 举个例子 现在所有 落在从这儿到这儿的区间里的系数 都会被表示为这个值 而且JPEG和许多编码器所做的意味着 我准备给出一些数让大家按照数的比例 (划分) 准备好了吗？接下来要说的是T(0,0) T(0,0)要被16除 我们在之前最开始的一个视频中见到过 先要将其取整 然后再次乘以16 乘了以后的值就成为新的T(0,0) 这种方法很简单 却很有效 或许并不很理想 也并不是最好的方式 但是JPEG被提倡不仅因为其高性能 同样因为简便性 而且我们能够看到这使得量化如何操作的 所以就像我们看到的那样 如果T(0,0)是 一个0和15之间的任意数
在 11 分 1 秒处开始记录11:01
通过这种方法都会变成0 如果我们用7除以16 将结果向下取整的时候就会变成0 再乘以16以后 它依旧为0 所以 所有在这个区间的数 都会变成0 然后所有 在16至31之间的数 都会变成1 这样就实现了量化。 我们所做的这些会帮助霍夫曼编码传输更少的数 这些数也更多的浓缩了 而且这个比例越大 举个例子 假如我们按照100的比例 在0到99之间的所有数都会变为0 所以这种量化决策更加显著 所以它虽然不是很好 但还是不错的 如果做得正确 那么就不会察觉到太大的变化 这就是JPEG量化的基本思想 接下来要给大家展示的是 这个JPEG里面基础的 默认表格 记住我在以前的幻灯片中说过的那些东西 因为我们马上就要开始量化很多数 这里面很多都会变成0 然后 块结束信号将能够压缩很多 很多个符号以及很多个系数 很多个T(u,v) 很多只有一个符号的变换系数 压缩的效果都极强 举个例子来说 这实际上是用之前的矩阵 和基本思想形成的 这也是JPEG如何压缩的 接下来 我会用这个矩阵 然后就像我说的那样用JPEG的方式讲解这个矩阵 好了，让我们现在来试一下。 我们除以16、11、12、12这样子 或者说用两倍的这个矩阵来除 就是除以32、22、24、24这样 接着让我们看一下效果 我们逐步所除的矩阵是同一个矩阵 只是按比例扩大了而已 我们能看到质量是如何变低的 当然我们并不想让图像变成这样 这个图像效果出现的原因可能是 当我们在将矩阵乘了32次Z以后 大部分的系数也遭到了破坏 但是假如我们不把矩阵乘那么多次 而是按比例缩小 除以16 除以11 先乘再除然后得到 质量非常非常好的图像 我们除得越多 就压缩的越多 所以就像在之前的幻灯片里看到的那样 如果我们用2去除的话 我们只是在取整 但是如果我们用100去除 就会使这些块中的数变得全都一样 或者就像看到这张图 这个越大 量化的就越多
在 14 分 23 秒处开始记录14:23
这个就是JPEG准备使用的默认表 也可以说是默认表的一个可能性 我想给大家看这个表的原因在于 我想再一次给大家看这些数是如何增加的 它们减少了 虽然对这些做了大量的处理 但是压缩依然是均匀的 接着对矩阵又一次做乘法 所以这张图就是我们将会得到的 一倍矩阵得到的图像 更大地扩大矩阵倍数 会得到这样的结果 我希望你能看出它的质量 这是误差 从图里很难看出来 让我们关注一下某些区域 我们来看这里 很不错的样子 很可能是我们没有将量化矩阵划分得很大 再看这里就是划分得很大了 看起来不是很好 把这片区域放大以后再来看一下 看起来确实不好 还有这里 如果我们把它放大的话 就能够看到 图像上出现了一些问题 但在这种比例的图上却看不见 因此我们具有一个量化矩阵 它用来表示所有变换系数T(u,v) 我们到底想做的是什么？ 是想除了以后再取整 然后再除以5？ 还是再除以100？ 我们除以的数越大 产生的误差也就越大 不过我们压缩得也越多 所以这很有意思 在一些软件包里 当保存一张图像时 它会询问我们想保存的JPEG图像质量 它所询问的其实就是要乘以量化矩阵的倍数大小 所以量化矩阵… 在软件包里 是一个固定矩阵 所以我们如何压缩更多或者更少呢？ 答案就是通过按比例扩大或者缩小量化矩阵 所以当表示为我们需要高质量时 并不是需要很大的比例 当表示我们需要高压缩或者低质量时 才是需要很大的比例 这就是JPEG如何实现压缩的 它使用一种非常简单的 均匀量化 通过按比例划分再乘回原来的比例 当然 乘的过程是在解码器中完成的 在0至100之间的每一个数 假如我们将它按100的比例缩减 在0和99之间的 抱歉 假如我们将它按照100的比例来 这些数都会被编码为0 接着解码器乘以100以后会重新得到这些数 所以这就是JPEG在量化上所做的 通过这些我们可以得到压缩 现在我想提到的一点是 有技术和理论能够随着信号的类型尝试调整量化 JPEG采用均匀量化 是因为它很简单 我们不需要做均匀量化 我们可以构造图中的这些区间 他们的宽度不同 一些区域会比其他的区域划分得更大 这在JPEG里是不会出现的 JPEG里是均匀的 无论什么T(u,v)的值
在 17 分 56 秒处开始记录17:56
我们总是都要除它 在一个给定的系数位置 我们总要用相同的数去除 看这里 就是根据我们输入的不同 根据我们准备除以的值 JPEG并不这样做 这一点很重要 再一次说明部分原因是简便性 我把相关的这一章放在量化里 我想给大家解释一下 如果愿意在算法里使用更多的复杂性 那么实际上效果会更好 有一种非常好的关于如何做得更好的理论 叫做Max-Lloyd最优量化器 其主要思想相对简单 尽管并不总是直接的计算 已经显示的是 请记住 如果要测量一个给定的像素和其输出像素之间的方差作为误差 我们要讲的就是这个均方 看大家怎么决定 要在考虑这个误差的情况下 做出最好的量化器 还要考虑到比特数的确切的分配 当然如果不考虑使用比特的多少 那就根本不用量化了 自然就会变成零误差了 但是如果我们只能用256级 那就只能使用8个比特位 只能拥有256个区间 因为每个区间都需要用一个位串去表示 所以我们事先定义好想要使用的级的个数 即区间的个数 然后预先定义这个作为误差 这样就能显示出我们需要去做的 非常的直观 好了 那什么才是我们在每个区间产生的误差呢？ 在这里的每一个区间 都要从s_(i-1)到s_(i+1)进行积分 就是这个积分 大家可以看到假如这就是我们关心的误差 那么在这里就需要放上s_i 减去 事实上只有s 因为接下来要进行积分 s减去t_i 所以这就是误差了 我们用t代替s 这个就是 (代替产生的) 误差 接着需要把它和概率相乘 那个值出现的概率 如果那个值在输入数据中不出现的话 就不需要再关注它了 因为这个值永远不会产生误差 接着才对它在s上进行积分 这个方程式显示作为未知值的 我们寻找的区间边界 积分部分以及这里的代替值 这只是一个方程 我们还可以得到第二个方程 它可以表示为 s_i减去t_i和t_(i+1)的平均值 因为我们要计算均方误差 这个就会产生平均值 因而从这个就可以得到第二个方程 我们现在在每一个连续区间上 就有了两个方程 接着我们要解方程 这并不容易 大部分的概率分布中闭合解并不存在 但是如果我们假定概率分布是均匀的 那么闭合解确实存在 这就是JPEG使用的方程 这就像在说 概率分布是均匀的 我们只要做数值取整 像我之前说过那样 但是这个方程表示了一个很好的理论 前提是如果我们知道概率分布 就可以获得比均匀量化更好的效果 再说一次 JPEG使用的是均匀量化 为了简单起见 同样也是所谓的普遍性 不需要知道概率分布 就可以进行JPEG的工作 几乎对所有图像的处理效果都很好 或许在一些分布上我们的效果会更好 但是它能在所有分布上使用 我需要告诉大家的是 大家可以修改JPEG 在大家自己的量化表里 它仍然是标准的一部分 它或许会遵循一个你知道的分布 所以如果大家要压缩一类非常特殊的图像 可以优化出自己的JPEG来进行处理 就这些来总结一下 JPEG的基本概念是 从一个离散余弦变换开始 采用霍夫曼编码的均匀量化进行量化 非常非常的简单 如果大家想实际创建一个JPEG作为一个可选编程的练习 也不会花费大家太多的时间 如果大家使用像MATLAB这样的软件 如果要做离散余弦变换的话 只是一个很简单的命令 如果要做量化 记住不外乎是除了以后再取整 然后如果准备用解码器 就相当于用相同的数乘回来 这些做完了就可以进行霍夫曼编码了 但是即使没有霍夫曼编码 我们仍旧能够看到 当除以较大的数时 将会得到更多的压缩 当然 质量会变低 谢谢大家