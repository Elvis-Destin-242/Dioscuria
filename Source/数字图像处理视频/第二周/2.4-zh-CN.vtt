WEBVTT

1
00:00:00.000 --> 00:00:06.521
现在对应 YCbCr 的每个域 我们都有 n x n 的方块 

2
00:00:06.521 --> 00:00:13.125
现在我们进入正变换这一节 首先 

3
00:00:13.125 --> 00:00:17.580
我们需要了解为什么我们要做正变换 

4
00:00:17.580 --> 00:00:24.441
首先解释一下 在有损压缩时 

5
00:00:24.441 --> 00:00:31.024
我们是如何量度压缩图像所产生的误差 

6
00:00:31.024 --> 00:00:37.700
基本想法是 误差是由均方误差 (mean square error)   

7
00:00:37.700 --> 00:00:46.848
简称MSE 来量度的 均方误差是这样计算的 

8
00:00:46.848 --> 00:00:49.186
均方误差如下 

9
00:00:49.186 --> 00:01:00.465
MSE=1/像素数目 这只是归一化 

10
00:01:00.465 --> 00:01:10.026
我们计算出每个像素上的误差的平方 并将所有的这些值相加 

11
00:01:10.026 --> 00:01:13.622
我们得到了重建的图像 

12
00:01:13.622 --> 00:01:19.788
将其记为ḟ 用它减去原图像 再将差平方 

13
00:01:19.788 --> 00:01:24.178
我们对每个像素计算 

14
00:01:24.178 --> 00:01:29.027
现在我们计算 假定原来的 f是100 

15
00:01:29.027 --> 00:01:35.186
重建后是98 差值是2 平方后 我们得到4 

16
00:01:35.186 --> 00:01:40.959
我们对每个像素做此操作 全部加起来 然后用像素总数做归一化处理 

17
00:01:40.959 --> 00:01:46.600
大部分时候 因为我们用了平方 

18
00:01:46.600 --> 00:01:52.172
我们会取平方根 所以它被称为均方根误差 

19
00:01:52.172 --> 00:01:57.745
这就是我们测量误差的方式 那么 为什么我们需要做变换呢 

20
00:01:57.745 --> 00:02:02.990
想象一下 我们取 n x n 的方块 

21
00:02:02.990 --> 00:02:06.596
通常 我们取 8 x 8 

22
00:02:06.596 --> 00:02:10.693
但现在我们讲 n x n 的普遍情况 我们有 n x n 的方块 

23
00:02:10.693 --> 00:02:15.774
因为我们将对每个方块独立操作 

24
00:02:15.774 --> 00:02:19.543
尽管有 n x n (n=8时 是64) 个像素 

25
00:02:19.543 --> 00:02:23.954
我只对其中一个进行传输 我允许你只传输其中一个 

26
00:02:23.954 --> 00:02:28.578
那么 如果我们取一幅普通的图像 

27
00:02:28.578 --> 00:02:32.775
但只传输其中一个像素 误差将会非常大 

28
00:02:32.775 --> 00:02:39.204
但是 我们或许可以做一个变换 将其转为一个不同的 8 x 8 的方块 

29
00:02:39.204 --> 00:02:42.494
这个变换需要是可逆的 必须可以恢复原状 

30
00:02:42.494 --> 00:02:47.757
我们做了这个变换 得到一个新的 8 x 8 的方块 或许在变换域 

31
00:02:48.927 --> 00:02:53.386
我们可以只取第一个元素 并且取得不太差的效果 

32
00:02:53.386 --> 00:02:58.868
事实上 存在一个变换能有这效果 

33
00:02:58.868 --> 00:03:10.022
它是卡洛南-洛伊变换 (Karhunen-Loeve Transform) 即 K-L变换 

34
00:03:10.022 --> 00:03:13.982
这个变换有一些很特别的地方 看这个变换域 

35
00:03:13.982 --> 00:03:18.348
我会马上写出来 变换是什么意思 

36
00:03:18.348 --> 00:03:22.788
但是想想看 其实就是乘以一个矩阵 

37
00:03:22.788 --> 00:03:26.562
就是那样的操作 我有一个 8 x 8 模块 

38
00:03:26.562 --> 00:03:31.742
做了一些操作 我得到一个新的 8 x 8 模块 也就是 8 x 8 的图像   

39
00:03:31.742 --> 00:03:34.258
那么假如我刚才做的是 K-L变换 

40
00:03:34.258 --> 00:03:39.512
有时它也被写成 KLT 即卡洛南-洛伊变换 

41
00:03:39.512 --> 00:03:41.880
假如在变换域中 

42
00:03:41.880 --> 00:03:47.485
我取64个元素中的第一个 

43
00:03:47.485 --> 00:03:52.943
然后计算均方误差 记住我刚才只用了一个元素去做重建 

44
00:03:52.943 --> 00:03:56.483
我拿一幅图像 做 K-L变换 

45
00:03:56.483 --> 00:04:02.384
我去掉了其中的63个系数 然后反变换 并且计算均方误差 

46
00:04:02.384 --> 00:04:08.505
我取得了在只用一个系数的情况下 可能的最小均方误差 

47
00:04:08.505 --> 00:04:12.120
只传输一个元素 

48
00:04:12.120 --> 00:04:15.924
如果我想要3个元素 我可以做完全一样的事 

49
00:04:15.924 --> 00:04:21.403
而 K-L变换 有趣的地方在于 

50
00:04:21.403 --> 00:04:26.653
你不仅仅得到了在只用一个元素情况下最小的误差 而且那个元素是第一个 

51
00:04:26.653 --> 00:04:32.436
所以可以想象 有64个元素 你会得到新的64个元素 取第一个 

52
00:04:32.436 --> 00:04:37.458
那是你只能用一个元素的情况下 你能得到的最小误差 

53
00:04:37.458 --> 00:04:41.720
如果你可以用三个系数 那么就取前三个即可 

54
00:04:41.720 --> 00:04:46.630
所以这个变换很好 但是它有一个大问题 

55
00:04:46.630 --> 00:04:50.209
这个变换是依赖于图像的 

56
00:04:50.209 --> 00:04:54.032
我一开始并不知道怎么操作 正如我刚才所说 这是一个矩阵乘法 

57
00:04:54.032 --> 00:04:57.430
但是在我看到图像之前 我不知道要乘的矩阵的系数 

58
00:04:57.430 --> 00:05:02.101
你先给我图像 或者关于图像的信息 

59
00:05:02.101 --> 00:05:05.924
然后我才可以计算这个矩阵的系数 

60
00:05:05.924 --> 00:05:09.443
这样实用性不强 

61
00:05:09.443 --> 00:05:12.719
这样很慢 而且 我不能一拿到图像就马上操作 

62
00:05:12.719 --> 00:05:16.382
为了替代 我们采用一种 

63
00:05:16.382 --> 00:05:20.773
离散余弦变换 (discrete cosine transform) 这种变换是真正在 JPEG 中使用的 

64
00:05:20.773 --> 00:05:26.147
我们现在就写下离散余弦变换的公式 

65
00:05:26.147 --> 00:05:29.948
我们接下来进一步解释下这个变换 

66
00:05:29.948 --> 00:05:34.798
但是要记住 我们其实是想要做 K-L变换 

67
00:05:34.798 --> 00:05:39.517
K-L变换所做的事情是 消除图像元素之间的相关性 

68
00:05:39.517 --> 00:05:42.860
它把很多信息都放进了第一个系数 

69
00:05:42.860 --> 00:05:47.953
然后更多一点的信息放进了第二个系数 两个系数间是相互独立的 

70
00:05:47.953 --> 00:05:52.916
之后的系数以此类推 而且我们计算得到的均方误差是最优的 

71
00:05:52.916 --> 00:05:56.442
但是用离散余弦变换 我们将会得到次优的结果 

72
00:05:56.442 --> 00:06:01.013
但这个变换有一个固定的矩阵 

73
00:06:01.013 --> 00:06:05.975
有固定的系数 所以是通用的 我们可以对任意图片使用 

74
00:06:05.975 --> 00:06:10.671
而不需要做额外计算 那么究竟什么是变换 

75
00:06:10.671 --> 00:06:17.296
想法很简单 我们有一张图像 

76
00:06:17.296 --> 00:06:21.891
 记之为 f(x,y) 来写下这个变换  

77
00:06:21.891 --> 00:06:26.700
我们会进入一个新的变换域 T(u,v) 

78
00:06:26.700 --> 00:06:30.252
你们中的一些人是熟悉傅里叶变换的 

79
00:06:30.252 --> 00:06:36.489
傅里叶变换就是一种变换 我们会将图像中所有的像素相加 

80
00:06:36.489 --> 00:06:39.805
记住 我们有n个元素 

81
00:06:39.805 --> 00:06:48.392
所以我们将从 0 操作到 n-1 这里也是从 0 操作到 n-1 

82
00:06:48.392 --> 00:07:01.773
用图像 f(x,y) 乘以变换系数 

83
00:07:01.773 --> 00:07:08.889
这是我们将得到的 我必须给你 

84
00:07:08.889 --> 00:07:13.163
关于离散余弦变换 (DCT) 系数的公式 

85
00:07:13.163 --> 00:07:18.060
对于K-L变换 这些系数完全依赖于图像 

86
00:07:18.060 --> 00:07:24.022
不仅依赖于所取的位置 

87
00:07:24.022 --> 00:07:28.712
还依赖于你图像上实际的灰度值 

88
00:07:28.712 --> 00:07:34.038
这就是一个变换 我在 x和y 方向求和 

89
00:07:34.038 --> 00:07:38.092
那意味着 求和之后 x和y 都将消失 

90
00:07:38.092 --> 00:07:45.578
然后我得到一个新图像 是 8 x 8 或者 n x n 这是 n x n 的 

91
00:07:45.578 --> 00:07:49.919
这是在变换域中 然后 你可以写成矩阵形式 

92
00:07:49.919 --> 00:07:54.971
当然 一个变换只有在可逆的时候才有用 

93
00:07:54.971 --> 00:07:58.386
如果你给我一幅图 

94
00:07:58.386 --> 00:08:03.794
我进入变换域 但是视觉上我却看不懂 这就造成了不便 

95
00:08:03.794 --> 00:08:07.281
所以还有一个逆变换公式 

96
00:08:07.281 --> 00:08:14.706
这样我可以回到f(x,y) 这将会是从u=0到n-1求和 

97
00:08:14.706 --> 00:08:22.978
以及 v=0到n-1 求和 

98
00:08:22.978 --> 00:08:26.000
变换系数 T(u,v) 

99
00:08:26.000 --> 00:08:34.450
然后是 逆变换 有时会等于 r   

100
00:08:34.450 --> 00:08:40.630
有时候不会 这里是 s(x,y,u,v) 

101
00:08:40.630 --> 00:08:47.627
如果我拿一幅图 进行这种操作 在变换域里得到一幅新图 

102
00:08:47.627 --> 00:08:51.790
然后继续 进行反变换 

103
00:08:51.790 --> 00:08:57.541
为了说清什么是变换 我需要告诉你这些是什么 

104
00:08:57.541 --> 00:09:02.172
r是什么？s是什么？ 再次说明 不难看出 

105
00:09:02.172 --> 00:09:07.700
你可以把这些写成矩阵形式 作为自选的作业 

106
00:09:07.700 --> 00:09:13.212
这一点也不难 现在我需要说明这两个是什么 

107
00:09:13.212 --> 00:09:19.433
这两个函数 r和s 理想化情况下会使均方误差极小 

108
00:09:19.433 --> 00:09:26.285
我们希望它是 K-L变换 但做不到 

109
00:09:26.285 --> 00:09:30.380
所以会使用DCT 接下来我会写出来 

110
00:09:30.380 --> 00:09:40.140
DCT是什么？在DCT中 r(x,y,u,v) 

111
00:09:40.140 --> 00:09:50.060
实际上等于 s(x,y,u,v) 

112
00:09:50.060 --> 00:10:02.681
这个实际上等于 归一化系数 α(u) × α(v) 这两个v是一样的 

113
00:10:02.681 --> 00:10:07.640
抱歉我写了两个不一样的v 

114
00:10:08.940 --> 00:10:15.500
cos[(2x + 1) u π / (2n)]   

115
00:10:15.500 --> 00:10:37.443
这是大小 乘上 完全一样但是是另外一个坐标 

116
00:10:37.443 --> 00:10:40.355
cos[(2y + 1) v π / (2n)]   

117
00:10:45.940 --> 00:10:51.198
这是通用公式 现在我将写下来 

118
00:10:51.198 --> 00:10:56.770
这个是什么 这是归一化 在这类变换中很常见的 

119
00:10:56.770 --> 00:11:08.040
当u=0时 对(1/n)求平方根 

120
00:11:08.040 --> 00:11:11.104
当 u不为0时 对(2/n)求平方根 

121
00:11:11.104 --> 00:11:16.344
所以 我刚给出了DCT 即离散余弦变换的公式 

122
00:11:16.344 --> 00:11:21.659
对于熟悉傅里叶变换的人来说 

123
00:11:21.659 --> 00:11:27.134
这基本就是傅里叶变换的实部 

124
00:11:27.134 --> 00:11:30.070
几乎就是那个部分 

125
00:11:30.070 --> 00:11:35.382
再说一次 正变换和逆变换在这里是一样的公式 

126
00:11:35.382 --> 00:11:36.975
很好 

127
00:11:36.975 --> 00:11:42.221
当你需要用软件或者硬件实现 

128
00:11:42.221 --> 00:11:47.002
这些正变换和逆变换的时候 只要实现余弦变换就行了 

129
00:11:47.002 --> 00:11:49.923
所以这是余弦 这也是余弦 

130
00:11:49.923 --> 00:11:53.310
然后这些是归一化系数 

131
00:11:53.310 --> 00:11:58.570
这就是离散余弦变换 

132
00:11:58.570 --> 00:12:02.555
我想要告诉你这些函数 

133
00:12:02.555 --> 00:12:08.613
这些是我们在变换中 将用来和图像相乘的矩阵 

134
00:12:08.613 --> 00:12:12.200
正如之前所见 

135
00:12:13.260 --> 00:12:21.546
这个例子中 为了使演示简单一些 

136
00:12:21.546 --> 00:12:26.720
我们取n=4 对于每一个基函数 

137
00:12:26.720 --> 00:12:34.120
如果我用公式表达 当 u 和 v 都为 0 时 我得到一个余弦函数 

138
00:12:34.120 --> 00:12:41.046
这是一个仅关于x和y的函数 这些公式之前是关于u、v、x、y的函数 

139
00:12:41.046 --> 00:12:43.703
但现在我固定u和v 

140
00:12:43.703 --> 00:12:48.636
让 u和v 均为0 我得到一个只有 x和y 的公式 

141
00:12:48.636 --> 00:12:53.950
这是我得到的 4 x 4 图像 

142
00:12:53.950 --> 00:12:59.440
如果我让 v=1 且 u=0 我得到这个 以此类推 

143
00:12:59.440 --> 00:13:06.791
所以实际上 r和s 就是我们说的 基函数 

144
00:13:06.791 --> 00:13:14.235
而我们是在试着将 n×n 大小的小图像 

145
00:13:14.235 --> 00:13:19.074
分解成这些基函数的线性组合 

146
00:13:19.074 --> 00:13:27.932
如果是纯色图像 这里的T(u,v) 只要 u和v 的值都为0即可 

147
00:13:27.932 --> 00:13:34.373
如果图像中变化频繁 

148
00:13:34.373 --> 00:13:42.760
那么你就需要一些系数 像 T(3,3) 这样  每一个 T(u,v) 

149
00:13:42.760 --> 00:13:50.540
都会描述你有多少这样的组成部分 

150
00:13:50.540 --> 00:13:53.960
现在我们已经用此类图像的线性组合 

151
00:13:53.960 --> 00:13:58.780
来表示 n × n 的图像了 

152
00:13:58.780 --> 00:14:02.900
很重要的一点是 这些图像是不变的 

153
00:14:02.900 --> 00:14:09.041
而我们提到过 在卡洛南-洛伊变换中它们并非如此 

154
00:14:09.041 --> 00:14:14.638
因此很难有高效的硬件实现可以实时完成那种变换 

155
00:14:14.638 --> 00:14:19.225
而此处的基图像是固定不变的 你给我一张图 

156
00:14:19.225 --> 00:14:23.190
我就会用这些基图像的一种线性组合来表示它 

157
00:14:23.190 --> 00:14:31.321
T(u, v) 也告诉我们 我们的图像里 要乘以的 n × n 图像里 

158
00:14:31.321 --> 00:14:34.550
有多少这些基图像 这就是变换 

159
00:14:34.550 --> 00:14:40.469
实际上这些系数最能告诉我们这些基图像 

160
00:14:40.469 --> 00:14:45.542
都包含了多少信息 我把图像 

161
00:14:45.542 --> 00:14:49.385
分解成这些分量 这些属于频率成分 

162
00:14:49.385 --> 00:14:55.535
可以看到 当u和v分别沿纵向和横向增大时   

163
00:14:55.535 --> 00:15:01.129
图像的变化更多了 有一点我之前没有告诉大家 

164
00:15:01.129 --> 00:15:06.781
我说过我们不能做卡洛南-洛伊变换 对于 K-L变换 

165
00:15:06.781 --> 00:15:11.139
计算其基函数太过繁复 因此我们进行离散余弦变换 

166
00:15:11.139 --> 00:15:14.544
为什么选择离散余弦变换？ 

167
00:15:14.544 --> 00:15:19.447
为什么不选择傅里叶变换或其他变换方法 譬如哈达玛变换 (Hadamard Transform)？ 

168
00:15:19.447 --> 00:15:24.145
变换方法有很多种 我们选择离散余弦变换有几个理由 

169
00:15:24.145 --> 00:15:27.816
其一是 虽然我想进行卡洛南-洛伊变换   

170
00:15:27.816 --> 00:15:31.286
我需要做离散余弦变换 

171
00:15:31.286 --> 00:15:36.793
其实在一些特定情况下 离散余弦变换 

172
00:15:36.793 --> 00:15:41.696
完全等同于卡洛南-洛伊变换 这些特例中的图像 

173
00:15:41.696 --> 00:15:47.202
其像素排列符合马尔可夫链 即每个像素都以一种特殊的形式 

174
00:15:47.202 --> 00:15:52.860
依赖于相邻像素 然后相邻像素也是如此 

175
00:15:52.860 --> 00:15:56.405
以此类推 这就是所谓的一阶马尔可夫图像源 

176
00:15:56.405 --> 00:16:04.616
即 Markovian 如果可以设定一张图像 

177
00:16:04.616 --> 00:16:10.482
就可以证明卡洛南-洛伊变换最终就是离散余弦变换 

178
00:16:10.482 --> 00:16:14.747
所以最终 像我们这里看到的一样 

179
00:16:14.747 --> 00:16:19.990
它的基图像是固定不变的 这就是我们使用离散余弦变换的一个原因 

180
00:16:19.990 --> 00:16:24.878
另一个我们使用离散余弦变换的 

181
00:16:24.878 --> 00:16:32.340
原因是这样的 我们是从整个图像着手操作的 

182
00:16:32.340 --> 00:16:40.004
然后是这样的 n × n 的小块 

183
00:16:40.004 --> 00:16:45.780
有人可能会疑惑为什么不用傅里叶变换之类的方法呢？ 

184
00:16:45.780 --> 00:16:52.931
如果回去看傅里叶变换的理论 当我们进行离散傅里叶变换时 

185
00:16:52.931 --> 00:16:58.512
我们对周期性有一个潜在的假设 

186
00:16:58.512 --> 00:17:05.489
我们是假设图像像我们看到的一样在自我重复 

187
00:17:05.489 --> 00:17:09.326
这一点在此处再次出现 而这一点则在这儿重复 

188
00:17:09.326 --> 00:17:14.340
所以这里图像在反复出现 

189
00:17:14.340 --> 00:17:19.605
有了这个潜在的数学上的假设 

190
00:17:19.605 --> 00:17:25.653
我们才能真正地对 8 × 8 的小块进行傅里叶变换 在此 我只是标出了 

191
00:17:25.653 --> 00:17:32.127
8 × 8 的小块中的一条线 但这个假设同样适用于每个方向 

192
00:17:32.127 --> 00:17:38.206
以及整个二维平面 也就是说我们处理完一个小块之后 

193
00:17:38.206 --> 00:17:44.557
我们需要下一个小块中的像素 

194
00:17:44.557 --> 00:17:50.738
与这个小块的这个像素完全相同 即是说我们需要这个小块 

195
00:17:50.738 --> 00:17:56.834
在这里和这里重复 这就是你的潜在的假设 

196
00:17:56.834 --> 00:18:03.645
这里和这里的像素一样的可能性很低 

197
00:18:03.645 --> 00:18:08.790
就算是在 8 × 8 小块中 这两个值可能也不接近 

198
00:18:08.790 --> 00:18:15.508
另一方面 离散余弦变换对周期性所作的假设是不同的 

199
00:18:15.508 --> 00:18:21.327
离散余弦变换假设边界处有镜面对称 

200
00:18:21.327 --> 00:18:24.769
即是说你的图像是在重复 

201
00:18:24.769 --> 00:18:29.523
但它可以说是翻折了 这个假设是说 

202
00:18:29.523 --> 00:18:35.670
假定这里的像素与相邻的这个像素类似 

203
00:18:35.670 --> 00:18:41.516
不是说像素与八个像素之后的那一个相同 

204
00:18:41.516 --> 00:18:47.070
而是与紧接着它的那个像素相同 这个假设更合理 

205
00:18:47.070 --> 00:18:51.614
这就是我们选用离散余弦变换的两个原因 

206
00:18:51.614 --> 00:18:56.807
其一是对一类图像而言 进行离散余弦变换就是在进行卡洛南-洛伊变换 

207
00:18:56.807 --> 00:19:03.218
其二是周期性 在我们从 n × n 或 8 × 8 小块开始处理图像时 

208
00:19:03.218 --> 00:19:10.360
离散余弦变换对周期性的假设更为实用 

209
00:19:10.360 --> 00:19:14.488
现在我们知道离散余弦变换了 我们从一幅图像开始 

210
00:19:14.488 --> 00:19:19.355
将它分为 n × n 的小块 我们进行离散余弦变换 

211
00:19:19.355 --> 00:19:25.840
所得的系数表明我们用到了多少基图像 

212
00:19:25.840 --> 00:19:30.221
我一直在讲 “8 × 8” 我们怎么得到 8 × 8 这个值的？ 

213
00:19:30.221 --> 00:19:36.501
其实 JEPG 是在大量研究之后被设定为 8 × 8 规格的 

214
00:19:36.501 --> 00:19:40.760
我就解释一下这是怎么回事 

215
00:19:40.760 --> 00:19:44.651
这张图 我们取了整个图像 

216
00:19:44.651 --> 00:19:49.306
即是说我们没有做分割 这已经是我们提到过的 

217
00:19:49.306 --> 00:19:54.828
Lena的图像的一块了 我们对整幅图 

218
00:19:54.828 --> 00:19:59.904
进行离散余弦变换 并取系数的25% 

219
00:19:59.904 --> 00:20:06.685
也就是说我们只取了四分之一的系数 并将其它系数设为零 

220
00:20:06.685 --> 00:20:11.340
之后我们进行逆变换 这是我们得到的结果 

221
00:20:11.340 --> 00:20:16.397
我们介绍过误差 记住离散余弦变换所作的是 

222
00:20:16.397 --> 00:20:21.321
尽可能把我们引入一个变换域 这会产生误差 

223
00:20:21.321 --> 00:20:25.979
因为在其中会去掉一些系数 将它们设为 0   

224
00:20:25.979 --> 00:20:31.103
或引入一些差值 但只会造成很不显眼的误差 但这里我们做得很简单 

225
00:20:31.103 --> 00:20:36.293
我们只取了 25%的离散余弦变换系数 我们很快会知道所取的系数是哪些 

226
00:20:36.293 --> 00:20:41.810
但请先想象我们取了 1/4的值最大的那些系数 

227
00:20:41.810 --> 00:20:46.259
首先我们是对整张图做处理 

228
00:20:46.259 --> 00:20:53.847
这里我们只取 2 × 2 的小块 就是说我们这里把此图分割为 2 × 2 的小块 

229
00:20:53.847 --> 00:20:58.796
我们对每个 2 × 2 小块进行离散余弦变换 然后取系数的25% 

230
00:20:58.796 --> 00:21:02.425
所以我们最终只用了一个系数 然后逆变换 

231
00:21:02.425 --> 00:21:06.880
可以看到这个非常恼人的块效应 

232
00:21:06.880 --> 00:21:13.266
我们对 4 × 4 的分块方式 以及 8 × 8 的分块方式 分别做了同样的处理 

233
00:21:13.266 --> 00:21:17.780
我们看到图像效果越来越好 

234
00:21:17.780 --> 00:21:21.030
也许大家会想 2 × 2 是太小了 

235
00:21:21.030 --> 00:21:26.425
但为什么我们停在 8 × 8 ？ 为什么不选择 16 × 16 或 32 × 32 ？   

236
00:21:26.425 --> 00:21:31.170
或者为什么不对整幅图做离散余弦变换？ 

237
00:21:31.170 --> 00:21:34.030
有这样几个原因 其一是计算方面的 

238
00:21:34.030 --> 00:21:41.504
进行多个小型离散余弦变换比一个大型变换更划算 

239
00:21:41.504 --> 00:21:50.315
所以如果你有一个 16 × 16 的图像 对四个 8 × 8 小图进行离散余弦变换 

240
00:21:50.315 --> 00:21:56.070
比对一个 16 × 16 大图做变换更方便 这是第一个原因 

241
00:21:56.070 --> 00:22:00.836
另一个原因是离散余弦变换与卡洛南-洛伊变换奇妙的相似性 

242
00:22:00.836 --> 00:22:04.882
我说过这发生在特定条件下 

243
00:22:04.882 --> 00:22:07.850
即为一阶马尔可夫图像源时 

244
00:22:07.850 --> 00:22:12.411
如果你是在 8 × 8 小块里的一个小范围内 

245
00:22:12.411 --> 00:22:17.408
马尔可夫链条件可能可以成立 

246
00:22:17.408 --> 00:22:23.224
但如果你在一个很大的图像上操作 整张图不会满足马尔可夫链条件 

247
00:22:23.224 --> 00:22:26.799
就是说 小范围中假设可能成立 

248
00:22:26.799 --> 00:22:32.246
但在很大范围中则不行 

249
00:22:32.246 --> 00:22:35.759
这并不难理解 譬如说 你现在正看着我 

250
00:22:35.759 --> 00:22:41.200
你会看到这里有很多相关性 灰度值几乎一样 

251
00:22:41.200 --> 00:22:44.920
但如果向其它地方看 

252
00:22:44.920 --> 00:22:50.430
这里和这里的像素离得这么远 

253
00:22:50.430 --> 00:22:54.838
这两个像素值之间有相关性吗？其实是没有的 

254
00:22:54.838 --> 00:23:00.150
我可以换一件衬衫 而不需要考虑之前的信息 

255
00:23:00.150 --> 00:23:05.584
当你图中的像素离得很远的时候 其实它们就没有相关性了 

256
00:23:05.584 --> 00:23:11.313
它们就是不相关的 所以你需要折中选择 

257
00:23:11.313 --> 00:23:16.748
一方面你希望有很小的小块以实现高效计算 

258
00:23:16.748 --> 00:23:21.082
另一方面你不希望小块太小 

259
00:23:21.082 --> 00:23:26.129
因为你会遇到这样的问题 小块中没有足够的信息   

260
00:23:26.129 --> 00:23:31.549
没有足够的关联性 在变换中会被去相关 

261
00:23:31.549 --> 00:23:35.528
如果你选了太大的模块 

262
00:23:35.528 --> 00:23:41.085
你将要面对低效的计算 并且你忽视了 DCT 的优点的设定条件 

263
00:23:41.085 --> 00:23:46.162
你将为此付出代价 所以 8 × 8 是个不错的选择 

264
00:23:46.162 --> 00:23:51.787
我认为这是深入研究后很有意义的成果 它是很好的折中办法 

265
00:23:51.787 --> 00:23:57.671
这就是它如今被用在 JPEG 上的原因 作为对本部分离散余弦变换的介绍的总结 

266
00:23:57.671 --> 00:24:03.660
我想要再展示一次 Lena 的图像 

267
00:24:03.660 --> 00:24:08.623
这是两个不同的例子 现在先不要担心它 

268
00:24:08.623 --> 00:24:15.725
这里 我们取用 8 × 8 模块 进行离散余弦变换 我们保留 12.5%的系数 

269
00:24:15.725 --> 00:24:21.216
然后我们进行逆变换 没有真正进行量化 那是我们下一步的内容 

270
00:24:21.216 --> 00:24:25.300
这里我们只进行离散余弦变换和它的逆变换 

271
00:24:25.300 --> 00:24:31.654
这看起来很不错 就是说 我们第一眼看到它时 

272
00:24:31.654 --> 00:24:37.176
我们已经成功压缩了 因为我们 

273
00:24:37.176 --> 00:24:43.303
只保留了像素的12.5% 但得到了看起来和原图几乎一样的效果 

274
00:24:43.303 --> 00:24:47.312
这是因为我们是在离散余弦变换的变换域中进行处理的 

275
00:24:47.312 --> 00:24:53.146
如果我们只是扔掉大量像素 只保留它的12.5% 

276
00:24:53.146 --> 00:24:57.085
我们不能得到这样质量的图像 

277
00:24:57.085 --> 00:25:01.991
这是原图和重建的图像之间的误差 

278
00:25:01.991 --> 00:25:05.187
可以看到 这是个很小的误差 

279
00:25:05.187 --> 00:25:10.687
所以说单单一个离散余弦变换 

280
00:25:10.687 --> 00:25:14.850
去除大量系数 然后逆变换 就已经完成了相当不错的压缩 

281
00:25:14.850 --> 00:25:18.788
现在我们已经了解了前端和后端 

282
00:25:18.788 --> 00:25:24.477
只差中间部分 我现在在 DCT域中 

283
00:25:24.477 --> 00:25:28.708
我能通过量化处理高明地实现更大程度的压缩么？ 

284
00:25:28.708 --> 00:25:32.720
这将是我们下一个视频的主题
// 果壳教育无边界字幕组 | 和风煦日 | leafsherry | Coowesome | wugui | 小白_远游