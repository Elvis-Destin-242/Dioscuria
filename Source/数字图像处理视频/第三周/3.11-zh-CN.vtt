WEBVTT

1
00:00:00.000 --> 00:00:03.095
大家好 欢迎回到我们的图像与视频处理课程上来 

2
00:00:03.095 --> 00:00:06.796
我们能从这些图片中得到很有趣的效果 

3
00:00:06.796 --> 00:00:11.641
仅通过这些十分简单的 局部邻域操作 

4
00:00:11.641 --> 00:00:15.948
让我们通过这个视频来看看其它操作 

5
00:00:15.948 --> 00:00:19.514
尤其是 我们将说到导数 

6
00:00:19.514 --> 00:00:23.013
我们如何对邻域求导数 

7
00:00:23.013 --> 00:00:28.329
重要的是 这些导数操作将让图片产生 

8
00:00:28.329 --> 00:00:31.425
非常非常有趣的效果 

9
00:00:31.425 --> 00:00:35.492
让我们接下来深入探讨 这里有一幅图 

10
00:00:35.492 --> 00:00:41.067
这是一幅一维的图像 这里是平的 然后下降 再是平的 接着陡升 

11
00:00:41.067 --> 00:00:45.586
然后又是平直的 我们来看看在对它求导数后会变成怎样 

12
00:00:45.586 --> 00:00:49.127
我将求导后的图形画在这儿 

13
00:00:49.127 --> 00:00:54.475
在那之前你可能会问 求导应该是在连续性条件下的运算 

14
00:00:54.475 --> 00:00:57.715
我们怎么在电脑上进行 

15
00:00:57.715 --> 00:01:01.330
有很多很多种方式能够做到 

16
00:01:01.330 --> 00:01:07.555
但我展示一种非常简单的 如果我想要对一幅 

17
00:01:07.555 --> 00:01:15.289
图像在 x方向 进行求导的话 我只要用离散的形式写成 

18
00:01:15.289 --> 00:01:23.510
f(x+1) - f(x) 

19
00:01:23.510 --> 00:01:26.349
非常简单 

20
00:01:26.349 --> 00:01:32.535
我仅需将两个相邻的像素值相减 如果我想对邻域进行操作的话 

21
00:01:32.535 --> 00:01:38.399
假设是一个 3x3 区域 就是说 f(x+1)   

22
00:01:38.399 --> 00:01:46.363
在这儿有个1 而对应-f(x) 在这儿有个-1 我将其它的都用0替代 

23
00:01:46.363 --> 00:01:52.736
基本上就是这样表示的 

24
00:01:52.736 --> 00:01:57.183
于是我就得到了 x方向 的一阶导数   

25
00:01:57.183 --> 00:02:02.783
类似的 我能得到 y方向的一阶导数 

26
00:02:02.783 --> 00:02:08.630
我们看这儿 是这条折线的假设值   

27
00:02:08.630 --> 00:02:13.160
所以从此处的 6 开始 在下降区减少 

28
00:02:13.160 --> 00:02:18.622
然后一直是1 再是陡升 一阶导数是第一行的数 

29
00:02:18.622 --> 00:02:22.880
用这个方法能很容易算出 

30
00:02:22.880 --> 00:02:26.897
我们这有几个0 

31
00:02:26.897 --> 00:02:30.593
因为这里没有导数 这些值是常数 

32
00:02:30.593 --> 00:02:37.180
接着得到-1 -1意味着像素值 

33
00:02:37.180 --> 00:02:40.876
以恒定的跃变值1下降 

34
00:02:40.876 --> 00:02:46.500
它是负的 因此是下降 接下来与之前一样 是平的 

35
00:02:46.500 --> 00:02:50.713
然后这里有个大的跃变 我们用 (6 - 1) 

36
00:02:50.713 --> 00:02:54.490
得到5 后面又一次变平缓 

37
00:02:54.490 --> 00:03:00.229
我们已经看到如果考虑一阶导数 我们可以理解 

38
00:03:00.229 --> 00:03:05.314
比如这是下降区 像素值平缓下降 

39
00:03:05.314 --> 00:03:09.745
接着是一个大的跃变 非常有趣的是 我们能通过导数 

40
00:03:09.745 --> 00:03:14.384
来感知跃变 然后我们实际上能够求二阶导数   

41
00:03:14.384 --> 00:03:17.975
同样的 我们能够写一个具体的方程 

42
00:03:17.975 --> 00:03:21.213
还有模板 来表示二阶导数 

43
00:03:21.213 --> 00:03:26.282
于是我们来求这个图像的二阶导数 

44
00:03:26.282 --> 00:03:30.084
同样也是 x方向 也是有很多很多种方式来求 

45
00:03:30.084 --> 00:03:40.548
其中一种求取二阶导数的方法 就是取 f(x+1) 加上 f(x-1)   

46
00:03:40.548 --> 00:03:47.197
再减去2乘以此处的像素值 即 2f(x) 

47
00:03:47.197 --> 00:03:56.819
对普通的 3x3 来说 实现起来也很简单 

48
00:03:56.819 --> 00:04:03.725
此时在这儿为-2 两边各一个1 

49
00:04:03.725 --> 00:04:09.940
代表这两个数 然后其它处均为0 

50
00:04:09.940 --> 00:04:14.640
如果我们这样做 就是对一阶导数再求导 

51
00:04:14.640 --> 00:04:18.854
这是非常简单的操作 

52
00:04:18.854 --> 00:04:22.177
我们对这些进行求导 

53
00:04:22.177 --> 00:04:27.040
我们可以直接对最初的数值进行这种求导 

54
00:04:27.040 --> 00:04:34.010
但是这样会更简单 连续的像素中 相邻的两个相减 

55
00:04:34.010 --> 00:04:37.251
当有较大变化时我们会看见跃变 

56
00:04:37.251 --> 00:04:39.683
而这里 (0 - 0) 还是0 

57
00:04:39.683 --> 00:04:46.191
而这里 (-1 - (-1))时 又是0 但当这里有变化时 

58
00:04:46.191 --> 00:04:47.801
我们会看见跃变 这儿是1 

59
00:04:47.801 --> 00:04:52.246
这里还有一个跃变 所以二阶导数很清楚地 

60
00:04:52.246 --> 00:04:55.772
表明在我们的图像中何处有大的变化 

61
00:04:55.772 --> 00:05:00.983
这是十分有效的 我们通过求导数 来检验大的变化   

62
00:05:00.983 --> 00:05:07.115
以最简单的形式 运用像这样的掩模来实现 

63
00:05:07.115 --> 00:05:11.330
我们继续 

64
00:05:11.330 --> 00:05:17.649
来看一些例子 这些是不同的掩模 

65
00:05:17.649 --> 00:05:22.899
可以用于计算不同类型的导数 我想问问你们 

66
00:05:22.899 --> 00:05:28.230
例如 看这个掩模 能告诉我这个实际上是计算什么吗？ 

67
00:05:28.230 --> 00:05:33.583
是用来计算 x方向的三阶导数吗？ 

68
00:05:33.583 --> 00:05:37.991
还是计算在 y方向的三阶导数？ 

69
00:05:37.991 --> 00:05:43.659
又或者是计算一阶导数 

70
00:05:43.659 --> 00:05:49.878
在 x方向和y方向的和？ 或者是计算 

71
00:05:49.878 --> 00:05:55.074
在 x方向和 y方向的二阶导数之和呢？ 

72
00:05:55.074 --> 00:05:59.640
一个非常有趣的性质 那这个掩模是怎么用呢？ 

73
00:06:00.820 --> 00:06:06.770
我觉得它对你们而言应该不难 所以把它作为你们的练习 

74
00:06:06.770 --> 00:06:11.882
但我只是写出来了 这实际上是计算   

75
00:06:11.882 --> 00:06:17.375
x方向 和 y方向的二阶导数之和 

76
00:06:17.375 --> 00:06:20.579
所以这是计算 

77
00:06:20.579 --> 00:06:28.117
f 在x方向的二阶导数 加上 在y方向的二阶导数 

78
00:06:28.117 --> 00:06:31.585
对不起 是f在y方向上的二阶导数 

79
00:06:31.585 --> 00:06:37.366
这大概就是我们从之前的课中所知道的 

80
00:06:37.366 --> 00:06:44.688
因为我们能计算出 x方向和y方向的二阶导数 

81
00:06:44.688 --> 00:06:49.602
并且将它们相加 我们知道它实际上就是 

82
00:06:49.602 --> 00:07:04.208
f(x+1) + f(x-1)-2f(x) 我就不写y方向的了 因为它们基本没变 

83
00:07:04.208 --> 00:07:10.426
这是y 这也是y 这个也一样 把它们加到前面 

84
00:07:10.426 --> 00:07:15.302
这是x方向的 我们现在写出y方向的 

85
00:07:15.302 --> 00:07:29.329
就是 f(y + 1) + f(y - 1) - 2f(y) 同样 这些都是对于常量x而言 

86
00:07:29.329 --> 00:07:35.141
这些都是对于常量y而言 

87
00:07:35.141 --> 00:07:43.407
这些都是对于常量x而言 当我们把它们相加 我们就得到了这个 

88
00:07:43.407 --> 00:07:48.917
这实际上就被称作 f 的拉普拉斯算子 

89
00:07:48.917 --> 00:07:54.443
我们简要的介绍过这个 当我们谈论 

90
00:07:54.443 --> 00:07:59.190
均值处理、高斯滤波以及热方程之间的关系时 

91
00:07:59.190 --> 00:08:02.874
所以这就是图像的拉普拉斯算子 

92
00:08:02.874 --> 00:08:07.550
是x方向与y方向上的二阶导数之和 

93
00:08:07.550 --> 00:08:11.281
这些是拉普拉斯算子的不同实现形式 

94
00:08:11.281 --> 00:08:14.945
在此 我们使得变化更为明显 

95
00:08:14.945 --> 00:08:18.270
我们将其加强 便能看到它的效果 

96
00:08:18.270 --> 00:08:20.645
基本的原理是这样 

97
00:08:20.645 --> 00:08:25.801
周围的像素值取同一种符号 这个像素取不同的符号 

98
00:08:25.801 --> 00:08:28.787
而我们基本上都以此方式计算它的二阶导数 

99
00:08:28.787 --> 00:08:32.722
这些是不同类型的计算二阶导数的方法 

100
00:08:32.722 --> 00:08:37.879
那么在一幅图中 这会产生什么效果呢？ 

101
00:08:37.879 --> 00:08:40.300
很有趣 

102
00:08:40.300 --> 00:08:49.220
这里是一幅月球的图像 接下来我们看到的就是这幅图像的拉普拉斯算子 

103
00:08:49.220 --> 00:08:56.214
就是x方向的二阶导数 加上y方向的二阶导数 

104
00:08:56.214 --> 00:09:01.308
我们看到应用这个拉普拉斯算子后的效果 

105
00:09:01.308 --> 00:09:04.671
我们将其加强 

106
00:09:04.671 --> 00:09:10.208
记得我们已经知道如何修正直方图 类似于拉伸操作 

107
00:09:10.208 --> 00:09:14.973
接下来 我们把这个和它相叠加 

108
00:09:14.973 --> 00:09:20.292
也就是我们有一幅图像 用拉普拉斯算子处理 

109
00:09:20.292 --> 00:09:26.621
将其强化后 然后将它们加起来 就得到了这幅图像 

110
00:09:26.621 --> 00:09:32.326
你能看到它被锐化了 基本上一些细节部分 

111
00:09:32.326 --> 00:09:37.140
在这幅图像中比之前的更为清晰 

112
00:09:37.140 --> 00:09:43.515
现在我们能使这些细节更加清晰 通过计算不同的拉普拉斯算子 

113
00:09:43.515 --> 00:09:46.305
相比较于用 -4 这个值 这里用了-8 

114
00:09:47.500 --> 00:09:51.724
因此它能进一步对差异进行强化 

115
00:09:51.724 --> 00:09:55.550
过程是一样的 我们拿这个图像 

116
00:09:55.550 --> 00:10:00.191
用此方法计算每个像素点的拉普拉斯算子 

117
00:10:00.191 --> 00:10:07.339
于是每个像素点都被它自身的负值与 

118
00:10:07.339 --> 00:10:14.858
周围像素点的正值之和取代 接着我们把它和原图片比较 

119
00:10:14.858 --> 00:10:21.825
你看 我们得到了一个锐化的渲染效果 在这儿你能看到很多细节 

120
00:10:21.825 --> 00:10:24.714
而原来这儿是很模糊的 这个操作很简单 

121
00:10:24.714 --> 00:10:29.725
图像叠加上它的拉普拉斯算子 给我们带来了非常好的效果 

122
00:10:29.725 --> 00:10:33.463
有很多类似的组合可以达成目的 

123
00:10:33.463 --> 00:10:38.050
我们用另外的图片来试试 

124
00:10:38.050 --> 00:10:46.888
又是一张看上去有点模糊的图片 这是它经拉普拉斯操作后的图像 

125
00:10:46.888 --> 00:10:51.384
或许有点难看出是什么 我们所做的处理是 

126
00:10:51.384 --> 00:10:55.545
求了二阶导数并将它们相加 

127
00:10:55.545 --> 00:11:00.770
看看这幅图像比之前的锐化了多少 

128
00:11:00.770 --> 00:11:05.756
真的锐化了很多 我们能从中看到许多的细节 

129
00:11:05.756 --> 00:11:10.365
而之前不太清楚 通过简单地将原始图像 

130
00:11:10.365 --> 00:11:15.200
叠加到拉普拉斯处理后的图像上 这儿就是所谓的 

131
00:11:15.200 --> 00:11:20.791
用于边缘检测的索贝尔算子 这是导数的另一种计算方式 

132
00:11:20.791 --> 00:11:24.795
就像这样 会产生很有趣的效果 

133
00:11:24.795 --> 00:11:29.404
图像与图像中不同方向上的导数相结合 

134
00:11:29.404 --> 00:11:33.560
加上求导后的那个图所产生的效果 真的很有趣 

135
00:11:33.560 --> 00:11:38.354
在这些效果中 有一种效果被称作反锐化掩模 (unsharp masking) 

136
00:11:38.354 --> 00:11:42.705
是一个很著名而又很简单的概念 

137
00:11:42.705 --> 00:11:47.688
在这里也有反锐化掩模效果 

138
00:11:47.688 --> 00:11:53.774
原理很简单 将图像平滑处理 

139
00:11:53.774 --> 00:12:01.170
比如 我们如何平滑一幅图像呢？ 我们已经知道了很多方法 

140
00:12:01.170 --> 00:12:08.754
其中一种就是取局部均值 反映在掩模中 

141
00:12:08.754 --> 00:12:13.675
就是全部都为1 然后再用 1/9 进行归一化处理 

142
00:12:13.675 --> 00:12:18.035
这样处理后 我们将其减去 

143
00:12:18.035 --> 00:12:24.860
原始图像 减去 模糊化的图像 那么原始图像对应的掩模是什么呢？ 

144
00:12:24.860 --> 00:12:28.340
很简单 

145
00:12:28.340 --> 00:12:35.440
如果是不起任何作用的掩模 它这里为1 其余为0 

146
00:12:35.440 --> 00:12:41.059
其他地方也是1和0 所以原始图像对应这个掩模 

147
00:12:41.059 --> 00:12:45.816
而模糊图像对应这个掩膜  我们取其差异 

148
00:12:45.816 --> 00:12:49.220
所以是用这个掩模减去这个掩模 就得到了这个图 

149
00:12:49.220 --> 00:12:54.460
注意符号 那么如果我从这个掩模中减去这个模糊图像掩模 

150
00:12:54.460 --> 00:13:00.672
中间得到0 这是我将得到的 

151
00:13:00.672 --> 00:13:06.271
那么如果做了归一化 就不会得到0 而将得到 8/9 

152
00:13:06.271 --> 00:13:12.678
在用正数进行归一化的情况下 并且 

153
00:13:12.678 --> 00:13:18.591
其它处为-1/9 是负数 这是一种导数 和我们之前看的一样 

154
00:13:18.591 --> 00:13:24.340
水平方向和垂直方向结合在一起的 导数的实现方法 

155
00:13:24.340 --> 00:13:30.337
我们将此结果和原图像相加 

156
00:13:30.337 --> 00:13:34.884
看看我们得到的 

157
00:13:34.884 --> 00:13:41.438
实际上边界被强化了 和我们在之前的例子中所见的一样 

158
00:13:41.438 --> 00:13:47.500
 图像被锐化了 这是因为我们模糊化是通过  

159
00:13:47.500 --> 00:13:53.971
削弱边界得到的 当我们将边界叠加回去后 就得到了更加锐化的边界 

160
00:13:53.971 --> 00:14:00.197
以及锐化的图像 这就是所谓的反锐化掩模 

161
00:14:00.197 --> 00:14:04.395
一个虽简单但强大的操作 

162
00:14:04.395 --> 00:14:09.489
我接下来总结下 实际上下一个视频 

163
00:14:09.489 --> 00:14:14.191
将在 MATLAB 中给你们演示我们如何进行这些操作 

164
00:14:14.191 --> 00:14:19.153
怎样进行平滑处理 并叠加图像 很简单的操作 

165
00:14:19.153 --> 00:14:23.072
并能给我们的图像带来明显的效果 那么下个视频 

166
00:14:23.072 --> 00:14:24.574
会有 MATLAB 演示 再见
// 果壳教育无边界字幕组 | Coowesome | Mosesdc | 小白_远游