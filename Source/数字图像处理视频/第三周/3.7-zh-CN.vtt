WEBVTT

1
00:00:00.000 --> 00:00:05.380
正如刚才看到的 局部平均有着某种非常有趣的数学特性 

2
00:00:05.380 --> 00:00:10.894
同时这个操作很简单 从之前的例子可以看到这很有用 

3
00:00:10.894 --> 00:00:13.883
但是我们同时也看到 这会导致 

4
00:00:13.883 --> 00:00:17.603
图像中的内容变模糊 边缘变模糊 

5
00:00:17.603 --> 00:00:21.921
所以 我们该怎么解决这个问题呢？ 我们有几种思路 

6
00:00:21.921 --> 00:00:24.911
一种是用不同的局部运算来代替局部平均 

7
00:00:24.911 --> 00:00:29.959
这个我们稍后可以看到 

8
00:00:29.959 --> 00:00:35.079
而另外一种是这样的 我们可以先问问自己 我们只局限于对局部邻域求平均吗？ 

9
00:00:35.079 --> 00:00:38.561
或许我们可以选择一个更好的求平均的方法 

10
00:00:38.561 --> 00:00:41.969
记住平均就像热量的流动 

11
00:00:41.969 --> 00:00:47.542
那么我们应该是在最大和最小的像素值之间取平均 

12
00:00:47.542 --> 00:00:52.368
还是只对相似的像素点求平均 

13
00:00:52.368 --> 00:00:57.319
并且不对相差很大的像素点求平均 这是一个非常有趣的想法 

14
00:00:57.319 --> 00:01:02.459
我们可以用多种方法 用不同方式来实现它 

15
00:01:02.459 --> 00:01:06.031
现在我们来介绍一个特别简洁的方法 

16
00:01:06.031 --> 00:01:09.603
从某种程度上说它简洁是因为它很简单 

17
00:01:09.603 --> 00:01:12.612
它就是非局部均值算法 

18
00:01:12.612 --> 00:01:17.437
与在局部邻域求平均不同   

19
00:01:17.437 --> 00:01:21.835
我们将在整个图像中求平均 一起来看看为什么能这样做 

20
00:01:21.835 --> 00:01:23.967
以及如何才能做到这点 这个思路非常简单 

21
00:01:23.967 --> 00:01:28.264
一起来观察下这幅图像 我们能看到图像里有重复的东西 

22
00:01:28.264 --> 00:01:31.197
有时候这些被称为图像的自相似性 

23
00:01:31.197 --> 00:01:34.812
例如 如果我们着眼于这个局部邻域 

24
00:01:34.812 --> 00:01:40.132
它与这一个局部邻域非常相似 

25
00:01:40.132 --> 00:01:44.477
也跟这个局部邻域非常相似 我们同样可以观察到这里的这个局部邻域 

26
00:01:44.477 --> 00:01:48.689
与这个局部邻域非常相似 

27
00:01:48.689 --> 00:01:52.825
甚至与这个也相似 虽然它们隔得很远 但是它们很相似 

28
00:01:52.825 --> 00:01:54.480
这里也是同样的道理 

29
00:01:54.480 --> 00:01:59.953
因此 我们之前只平均这里的像素 

30
00:01:59.953 --> 00:02:04.302
也许我们应该平均相似的局部邻域 

31
00:02:04.302 --> 00:02:10.001
或者我们可以对这三个进行平均 这样我们可以用 

32
00:02:10.001 --> 00:02:16.075
这几个相似的像素计算并代替这个像素 但是不能把这个与这些混在一起 

33
00:02:16.075 --> 00:02:21.496
因为它们的局部邻域非常不一样 所以 非局部均值或者是非局部平均的 

34
00:02:21.496 --> 00:02:27.616
基本思路是尝试去平均某些局部邻域 并利用它们的特性 

35
00:02:27.616 --> 00:02:31.166
而不是限定在一个局部邻域里 

36
00:02:31.166 --> 00:02:35.020
那么我们为什么要这么做 以及 我们该怎么做呢？ 

37
00:02:35.020 --> 00:02:41.441
基本的思想是如果我们假设这些是相同的东西 

38
00:02:41.441 --> 00:02:45.106
有着相同的结构 但是或许有不同的噪声 

39
00:02:45.106 --> 00:02:49.758
一起来看看这种假设的效果 现在假设有某个像素P 

40
00:02:49.758 --> 00:02:53.260
它是我们观察到的像素 

41
00:02:53.260 --> 00:03:02.314
它是无噪的像素和噪声相加的结果 而这个噪声是一个随机变量 

42
00:03:02.314 --> 00:03:05.915
因此结果总会有稍稍的不同 

43
00:03:05.915 --> 00:03:09.683
所以 我们可以多次观察这个像素 

44
00:03:09.683 --> 00:03:16.460
我们观察到了 P1 叠加了某一噪声 我们再次观察同一像素 

45
00:03:16.460 --> 00:03:22.510
但是叠加了不同的噪声 我们可以观察多次 

46
00:03:22.510 --> 00:03:29.364
比如说观察了 N 次 每次都是相同的像素和不同的噪声 

47
00:03:29.364 --> 00:03:35.450
如果我们把这些做个平均 

48
00:03:35.450 --> 00:03:41.145
我们可以看到一些信号分析中的特性 

49
00:03:41.145 --> 00:03:47.749
噪声按照我们平均的数量成平方下降 

50
00:03:47.749 --> 00:03:51.381
也就是说 我们总是在平均相同的像素 

51
00:03:51.381 --> 00:03:54.682
而噪声是个随机变量 

52
00:03:54.682 --> 00:03:59.635
于是噪声以N的平方成比例下降 

53
00:03:59.635 --> 00:04:03.350
我们对越多像素值求平均 噪声减少得越多 

54
00:04:03.350 --> 00:04:09.494
当然 很重要的一点是我们总是平均相同的像素 

55
00:04:09.494 --> 00:04:16.286
噪声是唯一改变的地方 所以这是非局部均值产生的一个原因 

56
00:04:16.286 --> 00:04:22.997
或许我可以找到一些相同的或者很相似的结构 

57
00:04:22.997 --> 00:04:28.899
它们的噪声都是不一样的 

58
00:04:28.899 --> 00:04:32.784
但我可基于这些 利用均值来降低噪声 

59
00:04:32.784 --> 00:04:40.097
那么 基本思路就是 首先找相似的邻域 然后求平均值 

60
00:04:40.097 --> 00:04:44.612
如果我想替换中心的像素 

61
00:04:44.612 --> 00:04:50.762
可以根据这个邻域来寻找近似的邻域 

62
00:04:50.762 --> 00:04:56.756
然后用近似邻域的中心像素的均值来替换它 

63
00:04:56.756 --> 00:05:00.863
那怎样寻找近似邻域呢？ 

64
00:05:00.863 --> 00:05:04.542
有专门讨论非局部均值的文献 

65
00:05:04.542 --> 00:05:09.798
其中包括两部分 第一部分是怎样找到相似邻域 

66
00:05:09.798 --> 00:05:14.679
找出它们之后 第二部分就是如何求得均值 

67
00:05:14.679 --> 00:05:20.535
这时可以采用加权平均处理它们 或者也可以推演出它们之间不同的关系 

68
00:05:20.535 --> 00:05:25.933
但总体最简单的做法是通过比较来寻找邻域 

69
00:05:25.933 --> 00:05:31.036
比如 比较对象之间的均方误差 要确保它非常小 

70
00:05:31.036 --> 00:05:34.565
这是非常简单的操作 

71
00:05:34.565 --> 00:05:40.290
你可以用 3x3 或 5x5 或 7x7 的邻域来扫描整个图像 

72
00:05:41.435 --> 00:05:42.702
这样做就可以了 

73
00:05:42.702 --> 00:05:45.689
扫描整个图像 看看哪些与这个相似 

74
00:05:45.689 --> 00:05:49.074
你会找到一组邻域 你可以用所有这些邻域 

75
00:05:49.074 --> 00:05:51.928
你也可以只用最相似的一些邻域 

76
00:05:51.928 --> 00:05:56.175
你一旦找到它们 就可以利用每个邻域的中心像素 

77
00:05:56.175 --> 00:06:00.888
用它们的均值来替换那个像素 

78
00:06:00.888 --> 00:06:05.910
如果你想消除这个像素上的噪声 

79
00:06:05.910 --> 00:06:09.747
你可以寻找拥有这样像素的邻域 

80
00:06:09.747 --> 00:06:13.786
通过扫描整个图像 你会找到一些邻域 

81
00:06:13.786 --> 00:06:18.430
用这些近似邻域的中心像素的均值来替换这个像素 

82
00:06:18.430 --> 00:06:23.613
再一次说明 这个只是一个例子 你可以用不同的方法寻找相似的邻域 

83
00:06:23.613 --> 00:06:27.719
实际上 一旦你找到它们 

84
00:06:27.719 --> 00:06:32.902
除了计算均值 还可以计算加权平均值 或者用其它的函数关系进行计算 

85
00:06:32.902 --> 00:06:37.741
这些操作都是基于同样的概念的 

86
00:06:37.741 --> 00:06:43.785
这与仅仅在邻域内计算均值并以此代替像素不同 

87
00:06:43.785 --> 00:06:48.715
我们用一种方法去衡量相似性 在整个图像中寻找相似的邻域 

88
00:06:48.715 --> 00:06:52.133
而一旦找到这些邻域 就可以结合它们 

89
00:06:52.133 --> 00:06:57.436
用刚才所讲的概念对这个像素降噪 

90
00:06:57.436 --> 00:07:02.878
这样的处理都很相似 比如在 MATLAB 里 一到两行的命令 

91
00:07:02.878 --> 00:07:07.553
就可以完成这个处理过程 

92
00:07:07.553 --> 00:07:12.925
这样的处理非常有用 而且在最近几年里 

93
00:07:12.925 --> 00:07:17.600
图像处理领域中展开了很多这方面的研究 很前沿的研究 

94
00:07:17.600 --> 00:07:22.335
接下来我准备用一些图片来做例子 

95
00:07:22.335 --> 00:07:25.349
进行演示 我会实时处理这些图像 

96
00:07:25.349 --> 00:07:27.686
那么 下一个视频再见
// 果壳教育无边界字幕组 | Cynthy |  luoyetx | 小白_远游