WEBVTT

1
00:00:00.000 --> 00:00:04.261
我们来讲解一些 

2
00:00:04.261 --> 00:00:08.184
非常简单而有趣的均值滤波(Mean filtering)的性质 

3
00:00:08.184 --> 00:00:12.600
也就是局部平均(local averaging)
我们这就开始吧 

4
00:00:12.600 --> 00:00:17.381
大家看到这个标题 “取平均 高斯滤波(Gaussian Filter) 和热流(Heat Flow)” 

5
00:00:17.381 --> 00:00:21.596
我们会一一进行解释
不过我们首先从 

6
00:00:21.596 --> 00:00:26.188
一个很简单的练习讲起
假设我给你三个数字 

7
00:00:26.188 --> 00:00:28.880
1 2 

8
00:00:28.880 --> 00:00:33.927
和3
然后我要提这样一个问题 

9
00:00:33.927 --> 00:00:39.796
我需要你找到一个数字a 

10
00:00:39.796 --> 00:00:51.226
使(a -1)^2 + (a - 2)^2 + (a - 3)^2取得其最小值 

11
00:00:51.226 --> 00:00:53.121
找到这个数字 

12
00:00:53.121 --> 00:00:58.952
如果你需要进行大量计算的话 

13
00:00:58.952 --> 00:01:03.398
我希望你回答我说 不 我不知道怎样迅速解决它 

14
00:01:03.398 --> 00:01:08.791
也就是说 你可以选择说 

15
00:01:08.791 --> 00:01:14.622
不 我不知道怎样即刻或快速解决它
或回答是的我知道 所以否是一个选项 

16
00:01:14.622 --> 00:01:18.207
如果你知道怎么快速解决它的话 是也是一个选项   

17
00:01:18.207 --> 00:01:24.337
我的非常快速指的是 你只是心算 而不进行笔算或其他什么运算   

18
00:01:24.337 --> 00:01:27.140
你可以选择 是 a为0 是 a为2   

19
00:01:30.860 --> 00:01:32.504
和 是 a为4   

20
00:01:32.504 --> 00:01:39.261
来看一下你知不知道答案
好的 

21
00:01:39.261 --> 00:01:44.262
我们来解释一下吧
答案是2 

22
00:01:44.262 --> 00:01:49.605
我怎么解出来的？
因为这是这三个数字的平均数 

23
00:01:49.605 --> 00:01:54.316
能使这个求和等式取最小值的数字 

24
00:01:54.316 --> 00:02:02.699
是这三个数的平均数
这是个很有趣的性质 

25
00:02:02.699 --> 00:02:10.366
它通常被表述如下
给定一组数 

26
00:02:10.366 --> 00:02:18.442
称它们为ai a下标i 求数字a 

27
00:02:18.442 --> 00:02:25.379
使在i取所有值时 (a-ai)^2的总和为最小值 

28
00:02:25.379 --> 00:02:35.837
这个式子的结果是a的平均值
所以我要找的这个数字 

29
00:02:35.837 --> 00:02:41.838
就是我所有数字的平均值
所以你只需将所有数字求和 

30
00:02:41.838 --> 00:02:45.923
除以ai的个数 

31
00:02:45.923 --> 00:02:52.591
这其实不难证明 如果你对微积分还有些印象   

32
00:02:52.591 --> 00:02:58.039
非常初级的微积分
你把它定义为N 

33
00:02:58.039 --> 00:03:02.109
并对a进行求导 

34
00:03:02.109 --> 00:03:07.376
令导数值为0 你会发现所得结果就是平均值 

35
00:03:07.376 --> 00:03:11.366
这很有意思 

36
00:03:11.366 --> 00:03:18.169
当我们处理图像时
假设是 3 x 3平均 

37
00:03:18.169 --> 00:03:21.958
用这九个数字的平均值代替这个 

38
00:03:21.958 --> 00:03:27.912
我所做的其实是用一个数字来代替这个像素值 

39
00:03:27.912 --> 00:03:30.312
以最小化平方差 

40
00:03:30.312 --> 00:03:35.304
这就是所谓的均方差
记住 我们在做压缩时曾说到它 

41
00:03:35.304 --> 00:03:38.923
再说一次 这是个用求导就可以证明的 

42
00:03:38.923 --> 00:03:44.041
简单等式
这就是平均数的一个有趣的特征 

43
00:03:44.041 --> 00:03:47.433
我们所做的图像处理 

44
00:03:47.433 --> 00:03:50.540
其实就是在找能代替它的值 

45
00:03:50.540 --> 00:03:55.695
这就会变得很有趣
我们会在接下来的几个视频里看到 

46
00:03:55.695 --> 00:03:59.000
如果采用其它方法来计算误差的话 

47
00:03:59.000 --> 00:04:04.353
我们能够找到它的其他替换值
这就是取平均的 

48
00:04:04.353 --> 00:04:08.650
一个有趣的性质
我们再来看一个不同的性质 

49
00:04:08.650 --> 00:04:14.323
再次强调 我们是在一个窗口中取平均 

50
00:04:14.323 --> 00:04:19.443
它可以是 3 x 3, 5 x 5, 10 x 10
是个窗口就可以 

51
00:04:19.443 --> 00:04:23.207
我们所做的其实是卷积 

52
00:04:23.207 --> 00:04:29.005
对那些有点信号处理(Signal processing)基础的同学来讲
这并不令人惊讶 

53
00:04:29.005 --> 00:04:31.941
但是我会通过 

54
00:04:31.941 --> 00:04:36.910
一种略有不同的卷积运算来解释这一点 

55
00:04:36.910 --> 00:04:46.182
我们的思路是 我们取图像(x,y) 

56
00:04:46.182 --> 00:04:51.962
并用滤波器对其进行卷积
我们用所谓的高斯滤波器 

57
00:04:51.962 --> 00:04:58.764
进行卷积操作
就是一个均值为0 方差为某数的 

58
00:04:58.764 --> 00:05:04.820
高斯函数
记住 高斯函数的形式 

59
00:05:04.820 --> 00:05:06.767
就是这样 好的 

60
00:05:06.767 --> 00:05:10.350
这是我们所知的最简单的函数之一 

61
00:05:10.350 --> 00:05:14.557
这是一个加权平均数
在离散形式下 

62
00:05:14.557 --> 00:05:19.776
我们不让每个地方的权重都为1 

63
00:05:19.776 --> 00:05:24.995
而是使用高斯函数所提供的权值 

64
00:05:24.995 --> 00:05:30.943
这样我们会得到一个叫做(x,y, sigma)的新函数 

65
00:05:30.943 --> 00:05:34.913
因为这个函数是基于高斯函数的 

66
00:05:34.913 --> 00:05:40.206
我们可以取一个普通意义上的平均
但更好 更讲究的方法是 

67
00:05:40.206 --> 00:05:43.809
用高斯滤波来解析它 

68
00:05:43.809 --> 00:05:48.146
所以我们这样做的时候 就是在做加权平均 

69
00:05:48.146 --> 00:05:52.483
我们用一个像素周围的加权平均数来取代它 

70
00:05:52.483 --> 00:05:54.910
这就是我们正在做的 

71
00:05:54.910 --> 00:06:00.013
这个函数很有意思
再次强调 这里是(x, y, sigma) 

72
00:06:00.013 --> 00:06:05.946
是因为它基于高斯函数的方差
我们在这里写一些有趣的东西 

73
00:06:05.946 --> 00:06:09.323
你可能记得所谓的热流 

74
00:06:09.323 --> 00:06:12.196
如果不记得了 我接下来会解释一下 

75
00:06:12.196 --> 00:06:15.859
我会把它写下来然后解释给大家听 

76
00:06:15.859 --> 00:06:20.816
我们开始写了 我特意使用相同的符号 

77
00:06:20.816 --> 00:06:25.666
我这里要写的函数f 随时间变化 

78
00:06:25.666 --> 00:06:32.276
所以我这里依据f的拉普拉斯算子(Laplacian) 

79
00:06:32.276 --> 00:06:38.265
对时间进行求导
它就等于 

80
00:06:38.265 --> 00:06:47.888
f分别对x和对y的二阶导数之和 

81
00:06:47.888 --> 00:06:51.624
图像依据拉普拉斯算子进行变化 

82
00:06:51.624 --> 00:06:55.140
我只是观察x方向上的变化 

83
00:06:55.140 --> 00:06:58.655
求二阶导数 同样地 观察y方向上的变化 

84
00:06:58.655 --> 00:07:03.135
求该方向上的二阶导数
使变化加倍 

85
00:07:03.135 --> 00:07:07.685
这就是所谓的热流
你可能记得 

86
00:07:07.685 --> 00:07:12.027
热流的性质基本都是在讲扩散 

87
00:07:12.027 --> 00:07:16.232
就像是你的房间有热量 而热量在其中扩散 

88
00:07:16.232 --> 00:07:19.471
如果所有东西都是单折射性的 那什么都不会阻止它 

89
00:07:19.471 --> 00:07:25.435
它们依据这个等式来扩散
为什么我写下这个呢？ 

90
00:07:25.435 --> 00:07:32.160
这是因为高斯滤波满足这个等式 

91
00:07:32.160 --> 00:07:38.792
这很有趣 而且它是由时间变化决定的 

92
00:07:38.792 --> 00:07:45.619
你这里扩散得更充分 就等同于有一个大的sigma 或者说一个大的方差 

93
00:07:45.619 --> 00:07:48.350
再次强调 

94
00:07:48.350 --> 00:07:55.007
用高斯滤波器进行这个局部平均所得的结果 

95
00:07:55.007 --> 00:08:01.090
等同于把图像的像素值 灰度值想象成热量 

96
00:08:01.090 --> 00:08:05.857
让它遵循着热流来运作 

97
00:08:05.857 --> 00:08:10.050
也就是遵循这个等式
这两个是等价的运算 

98
00:08:10.050 --> 00:08:15.264
如果我们让它运作一段时间
再讲一次 这里像素值是热量 

99
00:08:15.264 --> 00:08:20.914
它运作一段时间 这就等同于 

100
00:08:20.914 --> 00:08:26.490
选择一个完全由时间决定的方差 并对图像做高斯滤波 

101
00:08:26.490 --> 00:08:32.285
所以像素值的扩散就像是热量基于热流的扩散 

102
00:08:32.285 --> 00:08:35.182
这两个大致相通 

103
00:08:35.182 --> 00:08:38.513
这也是不难证明的 

104
00:08:38.513 --> 00:08:41.628
如果你想再看一个有趣的练习 

105
00:08:41.628 --> 00:08:48.624
可以用这个表达式代替f
就是说 我们进行求导 

106
00:08:48.624 --> 00:08:53.727
但不是对t求导 而是对sigma求导 

107
00:08:53.727 --> 00:08:59.325
在这里则对x和y求导 

108
00:08:59.325 --> 00:09:04.594
你就会发现这满足这个等式
这是因为求导是线性的 

109
00:09:04.594 --> 00:09:11.014
这是一个线性运算
如果你不清楚怎么做 

110
00:09:11.014 --> 00:09:17.355
就把它当做一个给那些 

111
00:09:17.355 --> 00:09:20.922
想在与此视频有关的数学上稍稍深入的人的练习吧 

112
00:09:20.922 --> 00:09:26.866
这个很有趣的原因是 像我们接下来几周会了解到的那样 

113
00:09:26.866 --> 00:09:32.733
有些人可能会问 你刚才讲到 

114
00:09:32.733 --> 00:09:37.995
局部图像处理与热流有关
也许我可以设计一个与此不同的等式 

115
00:09:37.995 --> 00:09:42.656
来做另外一些有趣的图像处理 

116
00:09:42.656 --> 00:09:47.070
我们会看到这是有可能的
一样的 它会涉及到更高等的数学知识 

117
00:09:47.070 --> 00:09:51.342
接下来几周会讲到它们 

118
00:09:51.342 --> 00:09:56.140
那么我们已经学会了局部平均的一些有趣性质 

119
00:09:56.140 --> 00:10:01.211
第一点 其类似于计算平均数 使一定区域内 

120
00:10:01.211 --> 00:10:05.154
均方差取最小值
第二点是 

121
00:10:05.154 --> 00:10:07.960
像素值和热量之间有相通的地方 

122
00:10:07.960 --> 00:10:13.440
所以局部平均就是在扩散像素值 

123
00:10:13.440 --> 00:10:17.450
这就是为什么它使图像变模糊了
如果你记得 

124
00:10:17.450 --> 00:10:22.528
我们看到它使图像模糊 就是因为像素值被扩散了
我们也知道 

125
00:10:22.528 --> 00:10:25.957
这同样适用于热量
如果在开始时 一个地方热 

126
00:10:25.957 --> 00:10:30.258
而另一个地方冷
热流会使热量扩散 

127
00:10:30.258 --> 00:10:34.930
使之变得更均衡
当然 如果你等足够长时间 

128
00:10:34.930 --> 00:10:38.494
那就等价于有一个很大的方差 

129
00:10:38.494 --> 00:10:43.712
那我们就会得到平均数
那就得到的就是 

130
00:10:43.712 --> 00:10:48.211
整个图像的均值
像我们说过的那样 这就是一些 

131
00:10:48.211 --> 00:10:53.402
有趣的局部平均的性质
接下来 我们会看到不同类型的局部运算 

132
00:10:53.402 --> 00:10:58.108
它们能让我们使边缘不变模糊 

133
00:10:58.108 --> 00:11:00.600
下次视频见 谢谢
// 果壳教育无边界字幕组 | leafsherry | 风过成伤 | zeadoit