WEBVTT

1
00:00:00.000 --> 00:00:04.615
让我们来看看 我们是否可以用直方图来估计噪声 

2
00:00:04.615 --> 00:00:07.610
我们需要估计噪声的形状 

3
00:00:07.610 --> 00:00:12.537
也就是噪声的方程 它到底是高斯噪声 还是均匀分布噪声 又或是椒盐噪声 

4
00:00:12.537 --> 00:00:15.282
一旦我们估计出了方程 我们还需要 

5
00:00:15.282 --> 00:00:19.983
估算它的实际参数 接下来我们将要使用大家之前见过的 

6
00:00:19.983 --> 00:00:23.010
这张图像 这张很简单的图像 

7
00:00:23.010 --> 00:00:28.484
然后假设我们已经获取到一个区域 

8
00:00:28.484 --> 00:00:31.974
这个在原图像中的区域 只有一种像素值 

9
00:00:31.974 --> 00:00:36.421
原图像中的这个区域只有一个灰度值 

10
00:00:36.421 --> 00:00:41.457
正如这里展示的 如果我们获得了这个区域 接下来 

11
00:00:41.457 --> 00:00:45.801
就可以画出它的直方图 也就是这个区域像素值的分布 

12
00:00:45.801 --> 00:00:48.436
例如 这就是 

13
00:00:48.436 --> 00:00:53.564
像素值的分布 现在当我们看到这个分布 我们可以 

14
00:00:53.564 --> 00:00:56.768
很快地猜出来这个地方的噪声类型是什么 

15
00:00:56.768 --> 00:01:02.394
那么我来问问大家 这个区域是加了什么样的噪声 

16
00:01:02.394 --> 00:01:08.284
导致我们看到这种直方图? 这应该是很容易看出来的 

17
00:01:08.284 --> 00:01:10.660
这是一个高斯噪声 我们现在已经是专家啦 

18
00:01:10.660 --> 00:01:14.713
当我们看到这个图的时候 我们马上就认出它了 

19
00:01:14.713 --> 00:01:20.164
现在我们知道它是高斯噪声 我们需要估计它的平均值和它的方差 

20
00:01:20.164 --> 00:01:25.824
这个只需要从像素值来简单计算一下就可以了 

21
00:01:25.824 --> 00:01:29.038
也许这里加入的是瑞利噪声 如此图所示 

22
00:01:29.038 --> 00:01:32.602
如果是那样的话 我们再一次使用 

23
00:01:32.602 --> 00:01:38.471
直方图分布来确定和计算平均值和方差   

24
00:01:38.471 --> 00:01:42.568
有了这些 我们就可以尝试 

25
00:01:42.568 --> 00:01:49.056
用我们接下来要讨论的方法把它转换回来 现在 我们已经完全是噪声专家了 

26
00:01:49.056 --> 00:01:52.811
很明显 这里这个区域 

27
00:01:52.811 --> 00:01:57.977
加的是均匀噪声 再一次地 我们可以 

28
00:01:57.977 --> 00:02:03.506
很简单地估算这个被加入了均匀噪声的区域的噪声   

29
00:02:03.506 --> 00:02:09.250
和加入噪声的具体数值 或者那些值的概率 

30
00:02:09.250 --> 00:02:13.929
但是 如果我们不知道噪声的类型又怎么办呢? 

31
00:02:13.929 --> 00:02:17.225
实际上这个也很简单 让我们假设 这个就是 

32
00:02:17.225 --> 00:02:20.520
我们观察到的分布 那么让我们来尝试一下 

33
00:02:20.520 --> 00:02:25.464
我们先试试高斯分布 找与这个分布最匹配的高斯分布 

34
00:02:25.464 --> 00:02:28.562
再试瑞利分布 再试伽马分布 或者均匀分布 

35
00:02:28.562 --> 00:02:33.439
我们就这样使用这些标准工具来做函数拟合 

36
00:02:33.439 --> 00:02:37.328
我们找到每个分布类型中与这个分布最匹配的参数 

37
00:02:37.328 --> 00:02:42.140
哪一个产生的误差最小 我们就选择哪一个 

38
00:02:42.140 --> 00:02:47.024
虽然有可能并不是原来的噪声分布 但是我们希望 

39
00:02:47.024 --> 00:02:50.465
这是一个对噪声的较好近似 

40
00:02:50.465 --> 00:02:57.080
如果我们可以找到一个原本有着相同像素值的区域 

41
00:02:57.080 --> 00:03:02.694
我们就可以这样来估计噪声 否则 我们就要多做一些工作 

42
00:03:02.694 --> 00:03:05.434
首先 我们可以尝试 

43
00:03:05.434 --> 00:03:09.767
相对较小的区域 如果我们有一个比较小的区域 那么 

44
00:03:09.767 --> 00:03:13.335
就有更大的可能性选中一个均一的区域 

45
00:03:13.335 --> 00:03:17.923
小区域有一个问题 就是我们没有足够的像素值 

46
00:03:17.923 --> 00:03:22.320
来估计平均值和标准差或者方差 

47
00:03:22.320 --> 00:03:27.353
例如 如果我选择一块只有一个像素点的区域 

48
00:03:27.353 --> 00:03:30.540
就无法从这个像素点中估计出任何噪声的统计信息 

49
00:03:30.540 --> 00:03:36.606
如果我们选择了太大的区域 可能会选取到 

50
00:03:36.606 --> 00:03:42.110
原图像中像素值变化很大的部分 可能有两种或以上的像素值 

51
00:03:42.110 --> 00:03:45.654
这样的话又会如何呢? 我们已经知道了 

52
00:03:45.654 --> 00:03:50.028
我们实际上会得到一个看起来像这样的直方图 

53
00:03:50.028 --> 00:03:54.250
它有着两个峰值 如果是这样 

54
00:03:54.250 --> 00:04:00.132
我们也有方法来检测到 直方图中不只一个峰值 

55
00:04:00.132 --> 00:04:06.240
如果这种情况发生了 可以把区域缩小 或者 

56
00:04:06.240 --> 00:04:10.829
分离直方图 然后再对每一个区域分别估计 

57
00:04:10.829 --> 00:04:14.021
另一件需要小心的事是 

58
00:04:14.021 --> 00:04:19.209
我们很可能需要对图像中的每一个区域都做这样的估计 

59
00:04:19.209 --> 00:04:24.397
因为 除非我们事先知道这些噪声是均匀噪声 

60
00:04:24.397 --> 00:04:29.519
否则我们无法保证噪声的一致 如果全图都是同样的噪声 那么我们可以 

61
00:04:29.519 --> 00:04:33.860
在图中只选取一部分区域 

62
00:04:33.860 --> 00:04:37.927
来做我们的估计 例如 把所有的估计值都平均一下 

63
00:04:37.927 --> 00:04:43.374
我们对每一个区域都计算出平均值、标准差以及方差 

64
00:04:43.374 --> 00:04:46.545
然后我们就说 这个噪声是 

65
00:04:46.545 --> 00:04:49.923
这样一个分布 我们算出所有平均值的平均 

66
00:04:49.923 --> 00:04:53.646
算出所有方差的平均值 

67
00:04:53.646 --> 00:04:56.473
我们把这个平均作为我们的估计 

68
00:04:56.473 --> 00:05:01.299
这就是从图像中计算噪声的标准方法 

69
00:05:01.299 --> 00:05:06.333
为什么说这个非常有用呢？ 我们最开始讲过 

70
00:05:06.333 --> 00:05:10.558
我们的模型 暂时不考虑 

71
00:05:10.558 --> 00:05:16.420
图像中的退化部分 我们假设现在只有噪声 

72
00:05:16.420 --> 00:05:26.010
我们让 g(x, y) 等于原来的图像加上噪声 

73
00:05:26.010 --> 00:05:32.457
现在 一旦我们估计出了噪声的参数和噪声的类型 

74
00:05:32.457 --> 00:05:38.035
根据经验 例如我知道什么样的滤波器 

75
00:05:38.035 --> 00:05:41.779
对不同的噪声有效 比如对于高斯噪声的过滤 

76
00:05:41.779 --> 00:05:47.578
我们已经看到过均值滤波器 包括均值滤波器和非局部平均滤波 

77
00:05:47.578 --> 00:05:50.808
如果我们能够切出一块区域 

78
00:05:50.808 --> 00:05:56.240
其中的像素值是相同或者相似的 那么平均的效果会很好 

79
00:05:56.240 --> 00:06:01.305
如果我们得到的是一个像素的分布 比如说在0附近   

80
00:06:01.305 --> 00:06:04.787
平均也能几乎完全去除那种噪声 

81
00:06:04.787 --> 00:06:09.606
均匀分布噪声也是一样的 所以 根据噪声的类型 

82
00:06:09.606 --> 00:06:14.002
我们可以使用不同的滤波器 而对于椒盐噪声 

83
00:06:14.002 --> 00:06:18.095
中值滤波器对椒盐噪声来说是很好的滤波器 

84
00:06:18.095 --> 00:06:21.624
我们知道椒盐噪声从某种意义上来讲是孤立的 

85
00:06:21.624 --> 00:06:25.011
我们在前一周里看过它的一个例子 

86
00:06:25.011 --> 00:06:30.163
它们是一些孤立的点 当我们算出中值   

87
00:06:30.163 --> 00:06:35.879
我们就能消除这些孤立的像素 最终把它们替换成周围点的 

88
00:06:35.879 --> 00:06:40.580
像素值 所以知道了噪声的类型会帮助我们 

89
00:06:40.580 --> 00:06:47.300
设计和决定使用哪种滤波器 哪种操作 可以用来 

90
00:06:47.300 --> 00:06:53.600
从掺入了噪声的图片中 

91
00:06:53.600 --> 00:06:59.095
重建出原始图像来 我们将会在以后几周看到 

92
00:06:59.095 --> 00:07:04.824
在我们讲解更多的高级技术之后 知道了噪声的类型 

93
00:07:04.824 --> 00:07:10.242
还能帮助我们以完全不同的方式来设计算法 

94
00:07:10.242 --> 00:07:14.035
 例如 如果我们知道  

95
00:07:14.035 --> 00:07:17.518
我们要处理高斯噪声 

96
00:07:17.518 --> 00:07:20.770
提醒一下 我们要尝试获得一个F的估计 

97
00:07:20.770 --> 00:07:26.682
它要跟原图像非常相似或者尽可能相似 

98
00:07:26.682 --> 00:07:34.020
如果我们知道这是高斯噪声 我们将把它约束在 

99
00:07:34.020 --> 00:07:37.613
这个是 g 不好意思 

100
00:07:37.613 --> 00:07:42.500
这个是 g 那么 对于高斯噪声 

101
00:07:43.560 --> 00:07:49.876
它们两个之间的误差就得是一个高斯噪声 

102
00:07:49.876 --> 00:07:53.981
好的 这是我的估计 我的无噪图像   

103
00:07:53.981 --> 00:07:59.140
这个是我们能看到的 有噪声的图像   

104
00:07:59.140 --> 00:08:02.996
这个必须跟原始图像尽可能地接近 

105
00:08:02.996 --> 00:08:06.635
让我们假设它跟原始图像是一样的 

106
00:08:06.635 --> 00:08:12.020
那么它们两个之间的差异就是一个高斯分布 

107
00:08:12.020 --> 00:08:18.575
我预期这个噪声有一个高斯分布 我们将会看到 

108
00:08:18.575 --> 00:08:25.130
我们可以得到均方误差的一些性质 

109
00:08:25.130 --> 00:08:31.331
也就是误差的平方 或者说实际图像和估计图像的差 的一些性质 

110
00:08:31.331 --> 00:08:37.658
现在 如果我们的噪声被估计为 

111
00:08:37.658 --> 00:08:42.655
均匀分布 将会得到一个不同的误差 

112
00:08:42.655 --> 00:08:47.069
例如 我们将会看到 

113
00:08:47.069 --> 00:08:50.401
如果这个噪声是指数噪声 

114
00:08:50.401 --> 00:08:56.814
我们就可以试着用估计值减去实际值 

115
00:08:56.814 --> 00:09:01.705
但是不需要取平方 这就是为什么我们要测定和确认 

116
00:09:01.705 --> 00:09:08.486
这些误差的表现 与我期望的指数噪声一致 

117
00:09:08.486 --> 00:09:12.290
那么我再强调一次 这里的核心思想是 

118
00:09:12.290 --> 00:09:19.741
如果我们知道了噪声分布 那么估计值减去观察值 

119
00:09:19.741 --> 00:09:23.340
这个差应该跟已知噪声的分布一致 所以如果我们 

120
00:09:23.340 --> 00:09:28.690
已经知道这个噪声是均匀分布的 而且计算出了估计值 我们这个估计 

121
00:09:28.690 --> 00:09:33.564
减去实际的观察值 所得到的却是高斯分布 

122
00:09:33.564 --> 00:09:37.129
那我就说 好吧 我这里可能有两种错误 

123
00:09:37.129 --> 00:09:42.629
要么我对噪声的估计是错的 要么我的去噪是错的 

124
00:09:42.629 --> 00:09:46.364
因为我没有得回我假设的噪声类型 

125
00:09:46.364 --> 00:09:51.389
这就是我们如何将噪声估计应用到 

126
00:09:51.389 --> 00:09:56.753
图像复原技术的设计上的 再强调一次 这里并不会 

127
00:09:56.753 --> 00:10:01.383
看到图像增强 但是我们还是可以看得到图像复原 

128
00:10:01.383 --> 00:10:07.649
我们将其应用到滤波器的设计 或者只是选择滤波器的参数 

129
00:10:07.649 --> 00:10:10.710
当然 如果我们有更多的噪声 更多的 

130
00:10:10.710 --> 00:10:16.050
椒盐噪声 我有可能需要确定中值滤波器的 

131
00:10:16.050 --> 00:10:20.037
窗口大小 使用的方法跟噪声较少的时候相比有所不同 

132
00:10:20.037 --> 00:10:25.020
那么 这就是我们如何将这些信息应用到 

133
00:10:25.020 --> 00:10:28.755
设计中的 关于这点我们已经讲了很多 

134
00:10:28.755 --> 00:10:32.724
但是请记住一点 原始模型中 这里还有一个 H函数 

135
00:10:32.724 --> 00:10:37.533
也就是退化函数 那么 让我们在下一次的视频中 

136
00:10:37.533 --> 00:10:40.740
再花一点时间讨论它 感谢大家
//果壳教育无边界字幕组 | ctzsm | 冰之冷 | 某音某莹